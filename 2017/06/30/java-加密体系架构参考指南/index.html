

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <meta name="description" content="JUST DO IT">
    <title>
        java 加密体系架构参考指南 | YFHan的博客
    </title>
    <link rel="shortcut icon" href="/favicon.jpg"/>
    

    
    
    
    <!-- stylesheets list from config.yml -->
        
            <link rel="stylesheet" href="/css/aloha.css">
        
            <link rel="stylesheet" href="//cdn.bootcss.com/semantic-ui/2.2.4/semantic.min.css">
        
    

</head>

<body id="body" style="margin-bottom: 0;" class="pushable">

    <div class="ui top fixed menu">
        <a class="item" id="menu-icon"><i class="sidebar icon"></i></a>

        
        

        

        
        <a href="/index.html" class="item" >
            <i class="home icon"></i>
            首页
        </a>

        
        

        

        
        <a href="/archives/" class="item" >
            <i class="archive icon"></i>
            归档
        </a>

        
        

        

        
        <a href="/atom.xml" class="item" >
            <i class="rss icon"></i>
            RSS
        </a>

        
        

        

        
        <a href="/about" class="item" >
            <i class="mail icon"></i>
            关于
        </a>

        
        

        

        
        <a href="https://github.com/yyhan" class="item" >
            <i class="github icon"></i>
            github
        </a>

        
        <!--<a class="item" href=""><i class="github icon"></i></a>-->
    </div>

    <div id="menu-sidebar" class="ui left vertical sidebar menu">

    <div id="sidebar-top">
        <div class="content">
            <h3>YFHan的博客</h3>
        </div>
    </div>
    <div class="ui container sidebar-card">
    <div class="ui people shape content">
        <div class="active side">
            <div class="ui card">
                <div class="image">
                    <img class="ui medium bordered image" src="/favicon_400x400.jpg">
                </div>
                <div class="content">
                    <a class="header">
                        YFHan
                    </a>
                    
                        <div class="meta">
                            Programer / Dotaor
                        </div>
                        
                </div>
                <div class="extra content">
                    <div class="ui list">
                        
                            <div class="item">
                                <i class="marker icon" style="float: left"></i>
                                <div class="content">
                                    杭州
                                </div>
                            </div>
                            
                                
                    </div>

                </div>
                <div class="extra content">
                    <div class="ui list">
                        

                            <a href="https://github.com/yyhan"><i class="large github icon" style="float: left"></i></a>

                            
                    </div>
                </div>
            </div>
        </div>
    </div>


</div>

    
    

    

    
    <a href="/index.html" class="item" >
        <i class="home icon"></i>
        首页
    </a>

    
    

    

    
    <a href="/archives/" class="item" >
        <i class="archive icon"></i>
        归档
    </a>

    
    

    

    
    <a href="/atom.xml" class="item" >
        <i class="rss icon"></i>
        RSS
    </a>

    
    

    

    
    <a href="/about" class="item" >
        <i class="mail icon"></i>
        关于
    </a>

    
    

    

    
    <a href="https://github.com/yyhan" class="item" >
        <i class="github icon"></i>
        github
    </a>

    

</div>

        <div class="pusher body-content">
            <div id="content" class="ui main container">
                <div id="post-java-加密体系架构参考指南" class="ui main container article-type-post">

    

    <div class="ui divided grid">

        <div class="two column row" id="article-content">

            <div class="thirteen wide computer thirteen wide tablet sixteen wide mobile column">
                

<h1 class="ui header">
    
    java 加密体系架构参考指南
</h1>



                <div class="article-inner">

                    <div class="article-entry" itemprop="articleBody">
                        
                        <p>&#x539F;&#x6587;&#x5730;&#x5740;&#xFF1A;<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/crypto/CryptoSpec.html" target="_blank" rel="noopener">Java Cryptography Architecture (JCA) Reference Guide</a></p>
<h1>&#x4ECB;&#x7ECD;</h1>
<p>The Java platform strongly emphasizes security, including language safety, cryptography, public key infrastructure, authentication, secure communication, and access control.</p>
<p>The JCA is a major piece of the platform, and contains a &quot;provider&quot; architecture and a set of APIs for digital signatures, message digests (hashes), certificates and certificate validation, encryption (symmetric/asymmetric block/stream ciphers), key generation and management, and secure random number generation, to name a few. These APIs allow developers to easily integrate security into their application code. The architecture was designed around the following principles:</p>
<p>Implementation independence: Applications do not need to implement security algorithms. Rather, they can request security services from the Java platform. Security services are implemented in providers (see below), which are plugged into the Java platform via a standard interface. An application may rely on multiple independent providers for security functionality.</p>
<p>Implementation interoperability: Providers are interoperable across applications. Specifically, an application is not bound to a specific provider, and a provider is not bound to a specific application.</p>
<p>Algorithm extensibility: The Java platform includes a number of built-in providers that implement a basic set of security services that are widely used today. However, some applications may rely on emerging standards not yet implemented, or on proprietary services. The Java platform supports the installation of custom providers that implement such services.</p>
<p>Other cryptographic communication libraries available in the JDK use the JCA provider architecture, but are described elsewhere. The Java Secure Socket Extension (JSSE) provides access to Secure Socket Layer (SSL) and Transport Layer Security (TLS) implementations. The Java Generic Security Services (JGSS) (via Kerberos) APIs, and the Simple Authentication and Security Layer (SASL) can also be used for securely exchanging messages between communicating applications.</p>
<p>Notes on Terminology</p>
<p>Prior to JDK 1.4, the JCE was an unbundled product, and as such, the JCA and JCE were regularly referred to as separate, distinct components. As JCE is now bundled in the JDK, the distinction is becoming less apparent. Since the JCE uses the same architecture as the JCA, the JCE should be more properly thought of as a part of the JCA.</p>
<p>The JCA within the JDK includes two software components:</p>
<p>the framework that defines and supports cryptographic services for which providers supply implementations. This framework includes packages such as java.security, javax.crypto, javax.crypto.spec, and javax.crypto.interfaces.
the actual providers such as Sun, SunRsaSign, SunJCE, which contain the actual cryptographic implementations.
Whenever a specific JCA provider is mentioned, it will be referred to explicitly by the provider&apos;s name.</p>
<p>WARNING: The JCA makes it easy to incorporate security features into your application. However, this document does not cover the theory of security/cryptography beyond an elementary introduction to concepts necessary to discuss the APIs. This document also does not cover the strengths/weaknesses of specific algorithms, not does it cover protocol design. Cryptography is an advanced topic and one should consult a solid, preferably recent, reference in order to make best use of these tools.</p>
<p>You should always understand what you are doing and why: DO NOT simply copy random code and expect it to fully solve your usage scenario. Many applications have been deployed that contain significant security or performance problems because the wrong tool or algorithm was selected.</p>
<h1>&#x8BBE;&#x8BA1;&#x539F;&#x5219;</h1>
<p>The JCA was designed around these principles:</p>
<p>implementation independence and interoperability
algorithm independence and extensibility
Implementation independence and algorithm independence are complementary; you can use cryptographic services, such as digital signatures and message digests, without worrying about the implementation details or even the algorithms that form the basis for these concepts. While complete algorithm-independence is not possible, the JCA provides standardized, algorithm-specific APIs. When implementation-independence is not desirable, the JCA lets developers indicate a specific implementation.</p>
<p>Algorithm independence is achieved by defining types of cryptographic &quot;engines&quot; (services), and defining classes that provide the functionality of these cryptographic engines. These classes are called engine classes, and examples are the MessageDigest, Signature, KeyFactory, KeyPairGenerator, and Cipher classes.</p>
<p>Implementation independence is achieved using a &quot;provider&quot;-based architecture. The term Cryptographic Service Provider (CSP) (used interchangeably with &quot;provider&quot; in this document) refers to a package or set of packages that implement one or more cryptographic services, such as digital signature algorithms, message digest algorithms, and key conversion services. A program may simply request a particular type of object (such as a Signature object) implementing a particular service (such as the DSA signature algorithm) and get an implementation from one of the installed providers. If desired, a program may instead request an implementation from a specific provider. Providers may be updated transparently to the application, for example when faster or more secure versions are available.</p>
<p>Implementation interoperability means that various implementations can work with each other, use each other&apos;s keys, or verify each other&apos;s signatures. This would mean, for example, that for the same algorithms, a key generated by one provider would be usable by another, and a signature generated by one provider would be verifiable by another.</p>
<p>Algorithm extensibility means that new algorithms that fit in one of the supported engine classes can be added easily.</p>
<h1>&#x67B6;&#x6784;</h1>
<h2>&#x52A0;&#x5BC6;&#x670D;&#x52A1;&#x63D0;&#x4F9B;&#x8005;</h2>
<p><code>java.security.Provider</code> is the base class for all security providers. Each CSP contains an instance of this class which contains the provider&apos;s name and lists all of the security services/algorithms it implements. When an instance of a particular algorithm is needed, the JCA framework consults the provider&apos;s database, and if a suitable match is found, the instance is created.</p>
<p>Providers contain a package (or a set of packages) that supply concrete implementations for the advertised cryptographic algorithms. Each JDK installation has one or more providers installed and configured by default. Additional providers may be added statically or dynamically (see the Provider and Security classes). Clients may configure their runtime environment to specify the provider preference order. The preference order is the order in which providers are searched for requested services when no specific provider is requested.</p>
<p>To use the JCA, an application simply requests a particular type of object (such as a MessageDigest) and a particular algorithm or service (such as the &quot;MD5&quot; algorithm), and gets an implementation from one of the installed providers. Alternatively, the program can request the objects from a specific provider. Each provider has a name used to refer to it.
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">md = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">md = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>, <span class="string">&quot;ProviderC&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>The following figure illustrates requesting an &quot;MD5&quot; message digest implementation. The figure show three different providers that implement various message digest algorithms (&quot;SHA-1&quot;, &quot;MD5&quot;, &quot;SHA-256&quot;, and &quot;SHA-512&quot;). The providers are ordered by preference from left to right (1-3). In the first illustration, an application requests an MD5 algorithm implementation without specifying a provider name. The providers are searched in preference order and the implementation from the first provider supplying that particular algorithm, ProviderB, is returned. In the second figure, the application requests the MD5 algorithm implementation from a specific provider, ProviderC. This time the implementation from ProviderC is returned, even though a provider with a higher preference order, ProviderB, also supplies an MD5 implementation.</p>
<p><a class="magnific-img" href="/img/java/security/Overview.gif"><img src="/img/java/security/Overview.gif" alt="Image of Yaktocat" class="ui centered image"></a></p>
<p>MD5 Message Digest Implementation
Description of Figure MD5 Message Digest Implementation</p>
<p>Cryptographic implementations in the JDK are distributed via several different providers (Sun, SunJSSE, SunJCE, SunRsaSign) primarily for historical reasons, but to a lesser extent by the type of functionality and algorithms they provide. Other Java runtime environments may not necessarily contain these Sun providers, so applications should not request an provider-specific implementation unless it is known that a particular provider will be available.</p>
<p>The JCA offers a set of APIs that allow users to query which providers are installed and what services they support.</p>
<p>This architecture also makes it easy for end-users to add additional providers. Many third party provider implementations are already available. See The Provider Class for more information on how providers are written, installed, and registered.</p>
<h2>How Providers Are Actually Implemented</h2>
<p>As mentioned earlier, algorithm independence is achieved by defining a generic high-level Application Programming Interface (API) that all applications use to access a service type. Implementation independence is achieved by having all provider implementations conform to well-defined interfaces. Instances of engine classes are thus &quot;backed&quot; by implementation classes which have the same method signatures. Application calls are routed through the engine class and are delivered to the underlying backing implementation. The implementation handles the request and return the proper results.</p>
<p>The application API methods in each engine class are routed to the provider&apos;s implementations through classes that implement the corresponding Service Provider Interface (SPI). That is, for each engine class, there is a corresponding abstract SPI class which defines the methods that each cryptographic service provider&apos;s algorithm must implement. The name of each SPI class is the same as that of the corresponding engine class, followed by Spi. For example, the Signature engine class provides access to the functionality of a digital signature algorithm. The actual provider implementation is supplied in a subclass of SignatureSpi. Applications call the engine class&apos; API methods, which in turn call the SPI methods in the actual implementation.</p>
<p>Each SPI class is abstract. To supply the implementation of a particular type of service for a specific algorithm, a provider must subclass the corresponding SPI class and provide implementations for all the abstract methods.</p>
<p>For each engine class in the API, implementation instances are requested and instantiated by calling the getInstance() factory method in the engine class. A factory method is a static method that returns an instance of a class. The engine classes use the framework provider selection mechanism described above to obtain the actual backing implementation (SPI), and then creates the actual engine object. Each instance of the engine class encapsulates (as a private field) the instance of the corresponding SPI class, known as the SPI object. All API methods of an API object are declared final and their implementations invoke the corresponding SPI methods of the encapsulated SPI object.</p>
<p>To make this clearer, review the following code and illustration:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"></span><br><span class="line">Cipher c = Cipher.getInstance(<span class="string">&quot;AES&quot;</span>);</span><br><span class="line">c.init(ENCRYPT_MODE, key);</span><br></pre></td></tr></table></figure></p>
<p>Example of How Application Retrieves AES Cipher Intstance
Description of Example of How Application Retrieves &quot;AES&quot; Cipher Instance</p>
<p>Here an application wants an &quot;AES&quot; javax.crypto.Cipher instance, and doesn&apos;t care which provider is used. The application calls the getInstance() factory methods of the Cipher engine class, which in turn asks the JCA framework to find the first provider instance that supports &quot;AES&quot;. The framework consults each installed provider, and obtains the provider&apos;s instance of the Provider class. (Recall that the Provider class is a database of available algorithms.) The framework searches each provider, finally finding a suitable entry in CSP3. This database entry points to the implementation class com.foo.AESCipher which extends CipherSpi, and is thus suitable for use by the Cipher engine class. An instance of com.foo.AESCipher is created, and is encapsulated in a newly-created instance of javax.crypto.Cipher, which is returned to the application. When the application now does the init() operation on the Cipher instance, the Cipher engine class routes the request into the corresponding engineInit() backing method in the com.foo.AESCipher class.</p>
<p>Appendix A lists the Standard Names defined for the Java environment. Other third-party providers may define their own implementations of these services, or even additional services.</p>
<h2>Key Management</h2>
<p>A database called a &quot;keystore&quot; can be used to manage a repository of keys and certificates. Keystores are available to applications that need data for authentication, encryption, or signing purposes.</p>
<p>Applications can access a keystore via an implementation of the KeyStore class, which is in the java.security package. A default KeyStore implementation is provided by Sun Microsystems. It implements the keystore as a file, using a proprietary keystore type (format) named &quot;jks&quot;. Other keystore formats are available, such as &quot;jceks&quot; which is an alternate proprietary keystore format with much stronger encryption than &quot;jks&quot;, and &quot;pkcs12&quot;, which is based on the RSA PKCS12 Personal Information Exchange Syntax Standard.</p>
<p>Applications can choose different keystore implementations from different providers, using the same provider mechanism described above.</p>
<p>See the Key Management section for more information.</p>
<h1>JCA &#x6982;&#x5FF5;</h1>
<p>&#x8FD9;&#x5757;&#x4ECB;&#x7ECD;JCA &#x91CD;&#x8981;&#x7684; API.</p>
<h2>&#x5F15;&#x64CE;&#x7C7B;&#x548C;&#x7B97;&#x6CD5;</h2>
<p>An engine class provides the interface to a specific type of cryptographic service, independent of a particular cryptographic algorithm or provider. The engines either provide:</p>
<p>cryptographic operations (encryption, digital signatures, message digests, etc.),
generators or converters of cryptographic material (keys and algorithm parameters), or
objects (keystores or certificates) that encapsulate the cryptographic data and can be used at higher layers of abstraction.
&#x4E0B;&#x9762;&#x7684;&#x5F15;&#x64CE;&#x7C7B;&#x90FD;&#x662F;&#x53EF;&#x7528;&#x7684;:</p>
<ul class="ui list">
<li>SecureRandom: used to generate random or pseudo-random numbers.</li>
<li>MessageDigest: used to calculate the message digest (hash) of specified data.</li>
<li>Signature: initialized with keys, these are used to sign data and verify digital signatures.</li>
<li>Cipher: initialized with keys, these used for encrypting/decrypting data. There are various types of algorithms: symmetric bulk + encryption (e.g. AES, DES, DESede, Blowfish, IDEA), stream encryption (e.g. RC4), asymmetric encryption (e.g. RSA), and + password-based encryption (PBE).</li>
<li>Message Authentication Codes (MAC): like MessageDigests, these also generate hash values, but are first initialized with keys + to protect the integrity of messages.</li>
<li>KeyFactory: used to convert existing opaque cryptographic keys of type Key into key specifications (transparent representations + of the underlying key material), and vice versa.</li>
<li>SecretKeyFactory: used to convert existing opaque cryptographic keys of type SecretKey into key specifications (transparent + representations of the underlying key material), and vice versa. SecretKeyFactorys are specialized KeyFactorys that create + secret (symmetric) keys only.</li>
<li>KeyPairGenerator: used to generate a new pair of public and private keys suitable for use with a specified algorithm.</li>
<li>KeyGenerator: used to generate new secret keys for use with a specified algorithm.</li>
<li>KeyAgreement: used by two or more parties to agree upon and establish a specific key to use for a particular cryptographic + operation.</li>
<li>AlgorithmParameters: used to store the parameters for a particular algorithm, including parameter encoding and decoding.</li>
<li>AlgorithmParameterGenerator : used to generate a set of AlgorithmParameters suitable for a specified algorithm.</li>
<li>KeyStore: used to create and manage a keystore. A keystore is a database of keys. Private keys in a keystore have a certificate + chain associated with them, which authenticates the corresponding public key. A keystore also contains certificates from + trusted entities.</li>
<li>CertificateFactory: used to create public key certificates and Certificate Revocation Lists (CRLs).</li>
<li>CertPathBuilder: used to build certificate chains (also known as certification paths).</li>
<li>CertPathValidator: used to validate certificate chains.</li>
<li>CertStore: used to retrieve Certificates and CRLs from a repository.</li>
</ul>
<p>NOTE: A generator creates objects with brand-new contents, whereas a factory creates objects from existing material (for example, an encoding).</p>
<h2>&#x6838;&#x5FC3;&#x7684;&#x7C7B;&#x548C;&#x63A5;&#x53E3;</h2>
<p>&#x8FD9;&#x5757;&#x8BA8;&#x8BBA;JCA&#x63D0;&#x4F9B;&#x7684;&#x6838;&#x5FC3;&#x7C7B;&#x548C;&#x63A5;&#x53E3;.</p>
<ul class="ui list">
<li>the Provider and Security classes,</li>
<li>the SecureRandom, MessageDigest, Signature, Cipher, Mac, KeyFactory, SecretKeyFactory, KeyPairGenerator, KeyGenerator, + KeyAgreement, AlgorithmParameters, AlgorithmParameterGenerator , KeyStore, and CertificateFactory, engine classes,</li>
<li>the Key interfaces and classes,</li>
<li>the Algorithm Parameter Specification Interfaces and Classes and the Key Specification Interfaces and Classes, and</li>
<li>miscellaneous support and convenience interfaces and classes.</li>
</ul>
<p>NOTE: For more information on the CertPathBuilder, CertPathValidator, and CertStore engine classes, please see the Java PKI Programmer&apos;s Guide.</p>
<p>The guide will cover the most useful high-level classes first (Provider, Security, SecureRandom, MessageDigest, Signature, Cipher, and Mac), then delve into the various support classes. For now, it is sufficient to simply say that Keys (public, private, and secret) are generated and represented by the various JCA classes, and are used by the high-level classes as part of their operation.</p>
<p>This section shows the signatures of the main methods in each class and interface. Examples for some of these classes (MessageDigest, Signature, KeyPairGenerator, SecureRandom, KeyFactory, and key specification classes) are supplied in the corresponding Examples sections.</p>
<p>The complete reference documentation for the relevant Security API packages can be found in the package summaries:</p>
<ul class="ui list">
<li>java.security</li>
<li>javax.crypto</li>
<li>java.security.cert</li>
<li>java.security.spec</li>
<li>javax.crypto.spec</li>
<li>java.security.interfaces</li>
<li>javax.crypto.interfaces</li>
</ul>
<h2>&#x63D0;&#x4F9B;&#x8005;&#x7C7B;</h2>
<p>The term &quot;Cryptographic Service Provider&quot; (used interchangeably with &quot;provider&quot; in this document) refers to a package or set of packages that supply a concrete implementation of a subset of the JDK Security API cryptography features. The Provider class is the interface to such a package or set of packages. It has methods for accessing the provider name, version number, and other information. Please note that in addition to registering implementations of cryptographic services, the Provider class can also be used to register implementations of other security services that might get defined as part of the JDK Security API or one of its extensions.</p>
<p>To supply implementations of cryptographic services, an entity (e.g., a development group) writes the implementation code and creates a subclass of the Provider class. The constructor of the Provider subclass sets the values of various properties; the JDK Security API uses these values to look up the services that the provider implements. In other words, the subclass specifies the names of the classes implementing the services.</p>
<p>Example of Provider Subclass
Description of Figure Example of Provider Subclass</p>
<p>There are several types of services that can be implemented by provider packages; for more information, see Engine Classes and Algorithms.</p>
<p>The different implementations may have different characteristics. Some may be software-based, while others may be hardware-based. Some may be platform-independent, while others may be platform-specific. Some provider source code may be available for review and evaluation, while some may not. The JCA lets both end-users and developers decide what their needs are.</p>
<p>In this section we explain how end-users install the cryptography implementations that fit their needs, and how developers request the implementations that fit theirs.</p>
<p>NOTE: For information about implementing a provider, see the guide How To Implement a Provider for the Java Cryptography Architecture.</p>
<h2>How Provider Implementations Are Requested and Supplied</h2>
<p>For each engine class in the API, a implementation instance is requested and instantiated by calling one of the getInstance methods on the engine class, specifying the name of the desired algorithm and, optionally, the name of the provider (or the Provider class) whose implementation is desired.
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> EngineClassName <span class="title">getInstance</span><span class="params">(String algorithm)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> NoSuchAlgorithmException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> EngineClassName <span class="title">getInstance</span><span class="params">(String algorithm, String provider)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> NoSuchAlgorithmException, NoSuchProviderException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> EngineClassName <span class="title">getInstance</span><span class="params">(String algorithm, Provider provider)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> NoSuchAlgorithmException</span></span><br></pre></td></tr></table></figure></p>
<p>where EngineClassName is the desired engine type (MessageDigest/Cipher/etc). For example:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MessageDigest md = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">KeyAgreement ka = KeyAgreement.getInstance(<span class="string">&quot;DH&quot;</span>, <span class="string">&quot;SunJCE&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>return an instance of the &quot;MD5&quot; MessageDigest and &quot;DH&quot; KeyAgreement objects, respectively.
Appendix A contains the list of names that have been standardized for use with the Java environment. Some providers may choose to also include alias names that also refer to the same algorithm. For example, the &quot;SHA-1&quot; algorithm might be referred to as &quot;SHA1&quot;. Applications should use standard names instead of an alias, as not all providers may alias algorithm names in the same way.</p>
<p>NOTE: The algorithm name is not case-sensitive. For example, all the following calls are equivalent:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MessageDigest.getInstance(<span class="string">&quot;SHA-1&quot;</span>)</span><br><span class="line">MessageDigest.getInstance(<span class="string">&quot;sha-1&quot;</span>)</span><br><span class="line">MessageDigest.getInstance(<span class="string">&quot;sHa-1&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>If no provider is specified, getInstance searches the registered providers for an implementation of the requested cryptographic service associated with the named algorithm. In any given Java Virtual Machine (JVM), providers are installed in a given preference order, the order in which the provider list is searched if a specific provider is not requested. For example, suppose there are two providers installed in a JVM, PROVIDER_1 and PROVIDER_2. Assume that:</p>
<ul class="ui list">
<li>PROVIDER_1 implements SHA1withDSA, SHA-1, MD5, DES, and DES3.<br>
PROVIDER_1 has preference order 1 (the highest priority).</li>
<li>PROVIDER_2 implements SHA1withDSA, MD5withRSA, MD2withRSA, MD2, MD5, RC4, RC5, DES, and RSA.<br>
PROVIDER_2 has preference order 2.</li>
</ul>
<p>Now let&apos;s look at three scenarios:</p>
<ol class="ui list">
<li>If we are looking for an MD5 implementation. Both providers supply such an implementation. The PROVIDER_1 implementation is returned since PROVIDER_1 has the highest priority and is searched first.</li>
<li>If we are looking for an MD5withRSA signature algorithm, PROVIDER_1 is first searched for it. No implementation is found, so PROVIDER_2 is searched. Since an implementation is found, it is returned.</li>
<li>Suppose we are looking for a SHA1withRSA signature algorithm. Since no installed provider implements it, a NoSuchAlgorithmException is thrown.</li>
</ol>
<p>The getInstance methods that include a provider argument are for developers who want to specify which provider they want an algorithm from. A federal agency, for example, will want to use a provider implementation that has received federal certification. Let&apos;s assume that the SHA1withDSA implementation from PROVIDER_1 has not received such certification, while the DSA implementation of PROVIDER_2 has received it.
A federal agency program would then have the following call, specifying PROVIDER_2 since it has the certified implementation:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Signature dsa = Signature.getInstance(<span class="string">&quot;SHA1withDSA&quot;</span>, <span class="string">&quot;PROVIDER_2&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>In this case, if PROVIDER_2 was not installed, a NoSuchProviderException would be thrown, even if another installed provider implements the algorithm requested.</p>
<p>A program also has the option of getting a list of all the installed providers (using the getProviders method in the Security class) and choosing one from the list.</p>
<p>NOTE: General purpose applications SHOULD NOT request cryptographic services from specific providers. Otherwise, applications are tied to specific providers which may not be available on other Java implementations. They also might not be able to take advantage of available optimized providers (for example hardware accelerators via PKCS11 or native OS implementations such as Microsoft&apos;s MSCAPI) that have a higher preference order than the specific requested provider.</p>
<h2>&#x5B89;&#x88C5; Providers</h2>
<p>In order to be used, a cryptographic provider must first be installed, then registered either statically or dynamically. There are a variety of Sun providers shipped with this release (SUN, SunJCE, SunJSSE, SunRsaSign, etc.) that are already installed and registered. The following sections describe how to install and register additional providers.</p>
<h3>&#x5B89;&#x88C5; Provider Classes</h3>
<p>There are two possible ways to install the provider classes:</p>
<p>On the normal Java classpath
Place a zip or JAR file containing the classes anywhere in your classpath. Some algorithms types (Ciphers) require the provider be a signed Jar file.</p>
<p>As an Installed/Bundled Extension
The provider will be considered an installed extension if it is placed in the standard extension directory. In the JDK, that would be located in:</p>
<p>Solaris, Linux, or Mac OS X: <code>&lt;java-home&gt;/lib/ext</code><br>
Windows: <code>&lt;java-home&gt;\lib\ext</code><br>
Here <code>&lt;java-home&gt;</code> refers to the directory where the runtime software is installed, which is the top-level directory of the Java Runtime Environment (JRE) or the jre directory in the Java JDK software. For example, if you have JDK 6 installed on Solaris in a directory named <code>/home/user1/JDK1.6.0</code>, or on Microsoft Windows in a directory named <code>C:\Java\JDK1.6.0</code>, then you need to install the JAR file in the following directory:</p>
<p>Solaris, Linux, or Mac OS X: <code>/home/user1/JDK1.6.0/jre/lib/ext</code><br>
Windows: <code>C:\JDK1.6.0\jre\lib\ext</code><br>
Similarly, if you have the JRE 6 installed on Solaris in a directory named /home/user1/jre1.6.0, or on Microsoft Windows in a directory named C:\jre1.6.0, you need to install the JAR file in the following directory:</p>
<p>Solaris, Linux, or Mac OS X: <code>/home/user1/jre1.6.0/lib/ext</code><br>
Windows: <code>C:\jre1.6.0\lib\ext</code><br>
For more information on how to deploy an extension, see How is an extension deployed?</p>
<h3>&#x6CE8;&#x518C; Provider</h3>
<p>The next step is to add the provider to your list of registered providers. Providers can be registered statically by editing a security properties configuration file before running a Java application, or dynamically by calling a method at runtime. To prevent the installation of rogue providers being added to the runtime environment, applications attempting to dynamically register a provider must possess the appropriate runtime privilege.</p>
<h3>Static Registration</h3>
<p>The configuration file is located in the following location:</p>
<p>Solaris, Linux, or Mac OS X: &lt;java-home&gt;/lib/security/java.security
Windows: &lt;java-home&gt;\lib\security\java.security
For each registered provider, this file should have a statement of the following form:</p>
<pre><code>security.provider.n=masterClassName
</code></pre>
<p>This declares a provider, and specifies its preference order n. The preference order is the order in which providers are searched for requested algorithms (when no specific provider is requested). The order is 1-based: 1 is the most preferred, followed by 2, and so on.</p>
<p>masterClassName must specify the fully qualified name of provider&apos;s master class. The provider&apos;s documentation will specify its master class. This class is always a subclass of the Provider class. The subclass constructor sets the values of various properties that are required for the Java Cryptography API to look up the algorithms or other facilities the provider implements.</p>
<p>The JDK comes standard with automatically installed and configured providers such as &quot;SUN&quot; and &quot;SunJCE&quot;. The &quot;SUN&quot; provider&apos;s master class is the SUN class in the sun.security.provider package, and the corresponding java.security file entry is as follows:</p>
<pre><code>security.provider.5=sun.security.provider.Sun
</code></pre>
<p>To utilize another JCA provider, add a line referencing the alternate provider, specify the preference order ( making corresponding adjustments to the other providers&apos; orders, if needed).</p>
<p>Suppose that the master class of CompanyX&apos;s provider is com.companyx.provider.ProviderX, and that you would like to configure this provider as the eighth most-preferred. To do so, you would add the following line to the java.security file:</p>
<pre><code>security.provider.8=com.companyx.provider.ProviderX
</code></pre>
<h3>Dynamic Registration</h3>
<p>To register providers dynamically, applications call either the addProvider or insertProviderAt method in the Security class. This type of registration is not persistent across VM instances, and can only be done by &quot;trusted&quot; programs with the appropriate privilege. See Security.
Setting Provider Permissions
Whenever encryption providers are used (that is, those that supply implementations of Cipher, KeyAgreement, KeyGenerator, Mac, or SecretKeyFactory), and the provider is not an installed extension Permissions may need to be granted for when applets or applications using JCA are run while a security manager is installed. There is typically a security manager installed whenever an applet is running, and a security manager may be installed for an application either via code in the application itself or via a command-line argument. Permissions do not need to be granted to installed extensions, since the default system policy configuration file grants all permissions to installed extensions (that is, installed in the extensions directory).</p>
<p>The documentation from the vendor of each provider you will be using should include information as to which permissions it requires, and how to grant such permissions. For example, the following permissions may be needed by a provider if it is not an installed extension and a security manager is installed:</p>
<p>java.lang.RuntimePermission &quot;getProtectionDomain&quot; to get class protection domains. The provider may need to get its own protection domain in the process of doing self-integrity checking.
java.security.SecurityPermission &quot;putProviderProperty.{name}&quot; to set provider properties, where {name} is replaced by the actual provider name.
For example, a sample statement granting permissions to a provider whose name is &quot;MyJCE&quot; and whose code is in myjce_provider.jar appears below. Such a statement could appear in a policy file. In this example, the myjce_provider.jar file is assumed to be in the /localWork directory.
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grant codeBase <span class="string">&quot;file:/localWork/myjce_provider.jar&quot;</span> {</span><br><span class="line">    permission java.lang.RuntimePermission <span class="string">&quot;getProtectionDomain&quot;</span>;</span><br><span class="line">    permission java.security.SecurityPermission</span><br><span class="line">        <span class="string">&quot;putProviderProperty.MyJCE&quot;</span>;</span><br><span class="line"> };</span><br></pre></td></tr></table></figure></p>
<h3>Provider Class Methods</h3>
<p>Each Provider class instance has a (currently case-sensitive) name, a version number, and a string description of the provider and its services. You can query the Provider instance for this information by calling the following methods:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getVersion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<h3>The Security Class</h3>
<p>The Security class manages installed providers and security-wide properties. It only contains static methods and is never instantiated. The methods for adding or removing providers, and for setting Security properties, can only be executed by a trusted program. Currently, a &quot;trusted program&quot; is either</p>
<p>a local application not running under a security manager, or
an applet or application with permission to execute the specified method (see below).
The determination that code is considered trusted to perform an attempted action (such as adding a provider) requires that the applet is granted the proper permission(s) for that particular action. The policy configuration file(s) for a JDK installation specify what permissions (which types of system resource accesses) are allowed by code from specified code sources. (See below and the &quot;Default Policy Implementation and Policy File Syntax&quot; and &quot;Java Security Architecture Specification&quot; files for more information.)
Code being executed is always considered to come from a particular &quot;code source&quot;. The code source includes not only the location (URL) where the code originated from, but also a reference to any public key(s) corresponding to the private key(s) that may have been used to sign the code. Public keys in a code source are referenced by (symbolic) alias names from the user&apos;s keystore.</p>
<p>In a policy configuration file, a code source is represented by two components: a code base (URL), and an alias name (preceded by signedBy), where the alias name identifies the keystore entry containing the public key that must be used to verify the code&apos;s signature.</p>
<p>Each &quot;grant&quot; statement in such a file grants a specified code source a set of permissions, specifying which actions are allowed.</p>
<p>&#x4E00;&#x4E2A;&#x7B80;&#x5355;&#x7684;&#x7B56;&#x7565;&#x914D;&#x7F6E;&#x6587;&#x4EF6;:
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grant codeBase <span class="string">&quot;file:/home/sysadmin/&quot;</span>, signedBy <span class="string">&quot;sysadmin&quot;</span> {</span><br><span class="line">    permission java.security.SecurityPermission <span class="string">&quot;insertProvider.*&quot;</span>;</span><br><span class="line">    permission java.security.SecurityPermission <span class="string">&quot;removeProvider.*&quot;</span>;</span><br><span class="line">    permission java.security.SecurityPermission <span class="string">&quot;putProviderProperty.*&quot;</span>;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p>
<p>This configuration file specifies that code loaded from a signed JAR file from beneath the /home/sysadmin/ directory on the local file system can add or remove providers or set provider properties. (Note that the signature of the JAR file can be verified using the public key referenced by the alias name sysadmin in the user&apos;s keystore.)
Either component of the code source (or both) may be missing. Here&apos;s an example of a configuration file where the codeBase is omitted:
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant signedBy <span class="string">&quot;sysadmin&quot;</span> {</span><br><span class="line">    permission java.security.SecurityPermission <span class="string">&quot;insertProvider.*&quot;</span>;</span><br><span class="line">    permission java.security.SecurityPermission <span class="string">&quot;removeProvider.*&quot;</span>;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p>
<p>If this policy is in effect, code that comes in a JAR File signed by sysadmin can add/remove providers--regardless of where the JAR File originated.
Here&apos;s an example without a signer:
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant codeBase <span class="string">&quot;file:/home/sysadmin/&quot;</span> {</span><br><span class="line">    permission java.security.SecurityPermission <span class="string">&quot;insertProvider.*&quot;</span>;</span><br><span class="line">    permission java.security.SecurityPermission <span class="string">&quot;removeProvider.*&quot;</span>;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p>
<p>In this case, code that comes from anywhere within the /home/sysadmin/ directory on the local filesystem can add/remove providers. The code does not need to be signed.
An example where neither codeBase nor signedBy is included is:
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant {</span><br><span class="line">    permission java.security.SecurityPermission <span class="string">&quot;insertProvider.*&quot;</span>;</span><br><span class="line">    permission java.security.SecurityPermission <span class="string">&quot;removeProvider.*&quot;</span>;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p>
<p>Here, with both code source components missing, any code (regardless of where it originates, or whether or not it is signed, or who signed it) can add/remove providers. Obviously, this is definitely NOT recommended, as this grant could open a security hole. Untrusted code could install a Provider, thus affecting later code that is depending on a properly functioning implementation. (For example, a rogue Cipher object might capture and store the sensitive information it receives.)</p>
<h2>Managing Providers</h2>
<p>The following tables summarize the methods in the Security class you can use to query which Providers are installed, as well as to install or remove providers at runtime.</p>
<h3>Querying Providers</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>static Provider[] getProviders()</td>
<td>Returns an array containing all the installed providers (technically, the Provider subclass for each package provider). The order of the Providers in the array is their preference order.</td>
</tr>
<tr>
<td>static Provider getProvider(String providerName)</td>
<td>Returns the Provider named providerName. It returns null if the Provider is not found.</td>
</tr>
</tbody>
</table>
<p>Adding Providers</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>static int addProvider(Provider provider)</td>
<td>Adds a Provider to the end of the list of installed Providers. It returns the preference position in which the Provider was added, or -1 if the Provider was not added because it was already installed.</td>
</tr>
<tr>
<td>static int insertProviderAt (Provider provider, int position)</td>
<td>Adds a new Provider at a specified position. If the given provider is installed at the requested position, the provider formerly at that position and all providers with a position greater than position are shifted up one position (towards the end of the list). This method returns the preference position in which the Provider was added, or -1 if the Provider was not added because it was already installed.</td>
</tr>
</tbody>
</table>
<p>Removing Providers</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>static void removeProvider(String name)</td>
<td>Removes the Provider with the specified name. It returns silently if the provider is not installed. When the specified provider is removed, all providers located at a position greater than where the specified provider was are shifted down one position (towards the head of the list of installed providers).</td>
</tr>
</tbody>
</table>
<p>NOTE: If you want to change the preference position of a provider, you must first remove it, and then insert it back in at the new preference position.</p>
<h3>Security Properties</h3>
<p>The Security class maintains a list of system-wide security properties. These properties are similar to the System properties, but are security-related. These properties can be set statically or dynamically. We have already seen an example of static security properties (that is, registering a provider statically via the <code>&quot;security.provider.i&quot;</code> security property). If you want to set properties dynamically, trusted programs can use the following methods:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">getProperty</span><span class="params">(String key)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setProperty</span><span class="params">(String key, String datum)</span></span></span><br></pre></td></tr></table></figure></p>
<p>Note: the list of security providers is established during VM startup, therefore the methods described above must be used to alter the provider list.
As a reminder, the configuration file is located in the following location:</p>
<p>Solaris, Linux, or Mac OS X: &lt;java-home&gt;/lib/security/java.security
Windows: &lt;java-home&gt;\lib\security\java.security
The SecureRandom Class
The SecureRandom class is an engine class that provides the functionality of a Random Number Generator (RNG). It differs from the java.lang.Random class in that it produces cryptographically strong random numbers. If there is insufficient randomness in a generator, it makes it much easier to compromise your protection mechanisms. Random numbers are used throughout cryptography, such as generating cryptographic keys, algorithmic parameters, and so on.</p>
<p>All Java SE implementations must indicate the strongest (most random) implementation of SecureRandom that they provide in the securerandom.strongAlgorithms property of the java.security.Security class. This implementation can be used when a particularly strong random value is required.</p>
<h2>The SecureRandom Class</h2>
<p>Description of The SecureRandom Class</p>
<h3>&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x5B89;&#x5168;&#x968F;&#x673A;&#x6570;&#x751F;&#x6210;&#x5668;&#x5BF9;&#x8C61;</h3>
<p>There are several ways to obtain an instance of SecureRandom:</p>
<p>All Java SE implementations provide a default SecureRandom using the no-argument constructor: new SecureRandom().</p>
<p>To get a specific implementation of SecureRandom, use one of the getInstance() static factory methods.</p>
<p>Use the getInstanceStrong() method to obtain a strong SecureRandom implementation as defined by the securerandom.strongAlgorithms property of the java.security.Security class. This property lists platform implementations that are suitable for generating important values.</p>
<h3>Seeding or Re-Seeding the SecureRandom Object</h3>
<p>The SecureRandom implementation attempts to completely randomize the internal state of the generator itself unless the caller follows the call to a getInstance method with a call to one of the setSeed methods:</p>
<p>synchronized public void setSeed(byte[] seed)
public void setSeed(long seed)
Once the SecureRandom object has been seeded, it will produce bits as random as the original seeds.</p>
<p>At any time a SecureRandom object may be re-seeded using one of the setSeed methods. The given seed supplements, rather than replaces, the existing seed; therefore, repeated calls are guaranteed never to reduce randomness.</p>
<h3>Using a SecureRandom Object</h3>
<p>To get random bytes, a caller simply passes an array of any length, which is then filled with random bytes:</p>
<p>synchronized public void nextBytes(byte[] bytes)</p>
<h3>Generating Seed Bytes</h3>
<p>If desired, it is possible to invoke the generateSeed method to generate a given number of seed bytes (to seed other random number generators, for example):</p>
<p>byte[] generateSeed(int numBytes)
The MessageDigest Class
The MessageDigest class is an engine class designed to provide the functionality of cryptographically secure message digests such as SHA-1 or MD5. A cryptographically secure message digest takes arbitrary-sized input (a byte array), and generates a fixed-size output, called a digest or hash.</p>
<h2>The MessageDigest Class</h2>
<p>Description of Figure The MessageDigest Class</p>
<p>For example, the MD5 algorithm produces a 16 byte digest, and SHA1&apos;s is 20 bytes.</p>
<p>A digest has two properties:</p>
<ul class="ui list">
<li>It should be computationally infeasible to find two messages that hash to the same value.</li>
<li>The digest should not reveal anything about the input that was used to generate it.</li>
</ul>
<p>Message digests are used to produce unique and reliable identifiers of data. They are sometimes called &quot;checksums&quot; or the <code>&quot;digital fingerprints&quot;</code> of the data. Changes to just one bit of the message should produce a different digest value.</p>
<p>Message digests have many uses and can determine when data has been modified, intentionally or not. Recently, there has been considerable effort to determine if there are any weaknesses in popular algorithms, with mixed results. When selecting a digest algorithm, one should always consult a recent reference to determine its status and appropriateness for the task at hand.</p>
<h3>&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x6D88;&#x606F;&#x7B7E;&#x540D;&#x5BF9;&#x8C61;</h3>
<p>The first step for computing a digest is to create a message digest instance. MessageDigest objects are obtained by using one of the <code>getInstance() static factory methods</code> in the <code>MessageDigest class</code>. The factory method returns an initialized message digest object. It thus does not need further initialization.</p>
<h3>&#x66F4;&#x65B0;&#x6D88;&#x606F;&#x7B7E;&#x540D;&#x5BF9;&#x8C61;</h3>
<p>The next step for calculating the digest of some data is to supply the data to the initialized message digest object. It can be provided all at once, or in chunks. Pieces can be fed to the message digest by calling one of the update methods:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">byte</span> input)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">byte</span>[] input)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">byte</span>[] input, <span class="keyword">int</span> offset, <span class="keyword">int</span> len)</span></span></span><br></pre></td></tr></table></figure></p>
<h3>&#x8BA1;&#x7B97;&#x7B7E;&#x540D;</h3>
<p>After the data chunks have been supplied by calls to update, the digest is computed using a call to one of the digest methods:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] digest()</span><br><span class="line"><span class="keyword">byte</span>[] digest(<span class="keyword">byte</span>[] input)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">digest</span><span class="params">(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> len)</span></span></span><br></pre></td></tr></table></figure></p>
<p>The first method return the computed digest. The second method does a final update(input) with the input byte array before calling digest(), which returns the digest byte array. The last method stores the computed digest in the provided buffer buf, starting at offset. len is the number of bytes in buf allotted for the digest, the method returns the number of bytes actually stored in buf. If there is not enough room in the buffer, the method will throw an exception.</p>
<p>Please see the Computing a MessageDigest example in the Code Examples section for more details.</p>
<h2>The Signature Class</h2>
<p>The Signature class is an engine class designed to provide the functionality of a cryptographic digital signature algorithm such as DSA or RSAwithMD5. A cryptographically secure signature algorithm takes arbitrary-sized input and a private key and generates a relatively short (often fixed-size) string of bytes, called the signature, with the following properties:</p>
<p>Only the owner of a private/public key pair is able to create a signature. It should be computationally infeasible for anyone having a public key to recover the private key.
Given the public key corresponding to the private key used to generate the signature, it should be possible to verify the authenticity and integrity of the input.
The signature and the public key do not reveal anything about the private key.
It can also be used to verify whether or not an alleged signature is in fact the authentic signature of the data associated with it.</p>
<p>The Signature Class
Description of Figure The Signature Class</p>
<p>A Signature object is initialized for signing with a Private Key and is given the data to be signed. The resulting signature bytes are typically kept with the signed data. When verification is needed, another Signature object is created and initialized for verification and given the corresponding Public Key. The data and the signature bytes are fed to the signature object, and if the data and signature match, the Signature object reports success.</p>
<p>Even though a signature seems similar to a message digest, they have very different purposes in the type of protection they provide. In fact, algorithms such as &quot;SHA1WithRSA&quot; use the message digest &quot;SHA1&quot; to initially &quot;compress&quot; the large data sets into a more manageable form, then sign the resulting 20 byte message digest with the &quot;RSA&quot; algorithm.</p>
<p>Please see the Examples section for an example of signing and verifying data.</p>
<h3>Signature Object States</h3>
<p>Signature objects are modal objects. This means that a Signature object is always in a given state, where it may only do one type of operation. States are represented as final integer constants defined in their respective classes.</p>
<p>&#x7B7E;&#x540D;&#x5BF9;&#x8C61;&#x53EF;&#x80FD;&#x5904;&#x4E8E;&#x7684;&#x4E09;&#x79CD;&#x72B6;&#x6001;:</p>
<ul class="ui list">
<li>&#x672A;&#x521D;&#x59CB;&#x5316;(UNINITIALIZED)</li>
<li>&#x7B7E;&#x540D;(SIGN)</li>
<li>&#x9A8C;&#x8BC1;(VERIFY)</li>
</ul>
<p>When it is first created, a Signature object is in the UNINITIALIZED state. The Signature class defines two initialization methods, initSign and initVerify, which change the state to SIGN and VERIFY, respectively.
Creating a Signature Object</p>
<p>The first step for signing or verifying a signature is to create a Signature instance. Signature objects are obtained by using one of the Signature getInstance() static factory methods.</p>
<h3>Initializing a Signature Object</h3>
<p>A Signature object must be initialized before it is used. The initialization method depends on whether the object is going to be used for signing or for verification.</p>
<p>If it is going to be used for signing, the object must first be initialized with the private key of the entity whose signature is going to be generated. This initialization is done by calling the method:</p>
<p>final void initSign(PrivateKey privateKey)
This method puts the Signature object in the SIGN state.
If instead the Signature object is going to be used for verification, it must first be initialized with the public key of the entity whose signature is going to be verified. This initialization is done by calling either of these methods:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initVerify</span><span class="params">(PublicKey publicKey)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initVerify</span><span class="params">(Certificate certificate)</span></span></span><br></pre></td></tr></table></figure></p>
<p>This method puts the Signature object in the VERIFY state.</p>
<h3>Signing</h3>
<p>If the Signature object has been initialized for signing (if it is in the SIGN state), the data to be signed can then be supplied to the object. This is done by making one or more calls to one of the update methods:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">byte</span> b)</span></span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span></span><br></pre></td></tr></table></figure></p>
<p>Calls to the update method(s) should be made until all the data to be signed has been supplied to the Signature object.</p>
<p>To generate the signature, simply call one of the sign methods:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] sign()</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">sign</span><span class="params">(<span class="keyword">byte</span>[] outbuf, <span class="keyword">int</span> offset, <span class="keyword">int</span> len)</span></span></span><br></pre></td></tr></table></figure></p>
<p>The first method returns the signature result in a byte array. The second stores the signature result in the provided buffer outbuf, starting at offset. len is the number of bytes in outbuf allotted for the signature. The method returns the number of bytes actually stored.</p>
<p>Signature encoding is algorithm specific. See the Standard Names document for more information about the use of ASN.1 encoding in the Java Cryptography Architecture.</p>
<p>A call to a sign method resets the signature object to the state it was in when previously initialized for signing via a call to initSign. That is, the object is reset and available to generate another signature with the same private key, if desired, via new calls to update and sign.</p>
<p>Alternatively, a new call can be made to initSign specifying a different private key, or to initVerify (to initialize the Signature object to verify a signature).</p>
<h3>Verifying</h3>
<p>If the Signature object has been initialized for verification (if it is in the VERIFY state), it can then verify if an alleged signature is in fact the authentic signature of the data associated with it. To start the process, the data to be verified (as opposed to the signature itself) is supplied to the object. The data is passed to the object by calling one of the update methods:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">byte</span> b)</span></span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span></span><br></pre></td></tr></table></figure></p>
<p>Calls to the update method(s) should be made until all the data to be verified has been supplied to the Signature object. The signature can now be verified by calling one of the verify methods:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(<span class="keyword">byte</span>[] signature)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(<span class="keyword">byte</span>[] signature, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure></p>
<p>The argument must be a byte array containing the signature. This byte array would hold the signature bytes which were returned by a previous call to one of the sign methods.</p>
<p>The verify method returns a boolean indicating whether or not the encoded signature is the authentic signature of the data supplied to the update method(s).</p>
<p>A call to the verify method resets the signature object to its state when it was initialized for verification via a call to initVerify. That is, the object is reset and available to verify another signature from the identity whose public key was specified in the call to initVerify.</p>
<p>Alternatively, a new call can be made to initVerify specifying a different public key (to initialize the Signature object for verifying a signature from a different entity), or to initSign (to initialize the Signature object for generating a signature).</p>
<h2>The Cipher Class</h2>
<p>The Cipher class provides the functionality of a cryptographic cipher used for encryption and decryption. Encryption is the process of taking data (called cleartext) and a key, and producing data (ciphertext) meaningless to a third-party who does not know the key. Decryption is the inverse process: that of taking ciphertext and a key and producing cleartext.</p>
<p>The Cipher Class
Description of Figure The Cipher Class</p>
<h3>Symmetric vs. Asymmetric Cryptography</h3>
<p>There are two major types of encryption: symmetric (also known as secret key), and asymmetric (or public key cryptography). In symmetric cryptography, the same secret key to both encrypt and decrypt the data. Keeping the key private is critical to keeping the data confidential. On the other hand, asymmetric cryptography uses a public/private key pair to encrypt data. Data encrypted with one key is decrypted with the other. A user first generates a public/private key pair, and then publishes the public key in a trusted database that anyone can access. A user who wishes to communicate securely with that user encrypts the data using the retrieved public key. Only the holder of the private key will be able to decrypt. Keeping the private key confidential is critical to this scheme.</p>
<p>Asymmetric algorithms (such as RSA) are generally much slower than symmetric ones. These algorithms are not designed for efficiently protecting large amounts of data. In practice, asymmetric algorithms are used to exchange smaller secret keys which are used to initialize symmetric algorithms.</p>
<h3>Stream vs. Block Ciphers</h3>
<p>There are two major types of ciphers: block and stream. Block ciphers process entire blocks at a time, usually many bytes in length. If there is not enough data to make a complete input block, the data must be padded: that is, before encryption, dummy bytes must be added to make a multiple of the cipher&apos;s block size. These bytes are then stripped off during the decryption phase. The padding can either be done by the application, or by initializing a cipher to use a padding type such as <code>&quot;PKCS5PADDING&quot;</code>. In contrast, stream ciphers process incoming data one small unit (typically a byte or even a bit) at a time. This allows for ciphers to process an arbitrary amount of data without padding.</p>
<h3>&#x5DE5;&#x4F5C;&#x6A21;&#x5F0F;</h3>
<p>When encrypting using a simple block cipher, two identical blocks of plaintext will always produce an identical block of cipher text. Cryptanalysts trying to break the ciphertext will have an easier job if they note blocks of repeating text. In order to add more complexity to the text, feedback modes use the previous block of output to alter the input blocks before applying the encryption algorithm. The first block will need an initial value, and this value is called the initialization vector (IV). Since the IV simply alters the data before any encryption, the IV should be random but does not necessarily need to be kept secret. There are a variety of modes, such as <code>CBC (Cipher Block Chaining)</code>, <code>CFB (Cipher Feedback Mode)</code>, and <code>OFB (Output Feedback Mode)</code>. <code>ECB (Electronic Cookbook Mode)</code> is a mode with no feedback.</p>
<p>Some algorithms such as <code>AES</code> and <code>RSA</code> allow for keys of different lengths, but others are fixed, such as <code>DES</code> and <code>3DES</code>. Encryption using a longer key generally implies a stronger resistance to message recovery. As usual, there is a trade off between security and time, so choose the key length appropriately.</p>
<p>Most algorithms use binary keys. Most humans do not have the ability to remember long sequences of binary numbers, even when represented in hexadecimal. Character passwords are much easier to recall. Because character passwords are generally chosen from a small number of characters (for example, [a-zA-Z0-9]), protocols such as <code>&quot;Password-Based Encryption&quot; (PBE)</code> have been defined which take character passwords and generate strong binary keys. In order to make the task of getting from password to key very time-consuming for an attacker (via so-called &quot;dictionary attacks&quot; where common dictionary word-&gt;value mappings are precomputed), most PBE implementations will mix in a random number, known as a salt, to increase the key randomness.</p>
<p>Newer cipher modes such as Authenticated Encryption with Associated Data (AEAD) (for example, Galois/Counter Mode (GCM)) encrypt data and authenticate the resulting message simultaneously. Additional Associated Data (AAD) can be used during the calculation of the resulting AEAD tag (Mac), but this AAD data is not output as ciphertext. (For example, some data might not need to be kept confidential, but should figure into the tag calculation to detect modifications.) The <code>Cipher.updateAAD()</code> methods can be used to include AAD in the tag calculations.</p>
<h3>Using an AES Cipher with GCM Mode</h3>
<p>AES Cipher with GCM is an AEAD Cipher which has different usage patterns than the non-AEAD ciphers. Apart from the regular data, it also takes AAD which is optional for encryption/decryption but AAD must be supplied before data for encryption/decryption. In addition, in order to use GCM securely, callers should not re-use key and IV combinations for encryption. This means that the cipher object should be explicitly re-initialized with a different set of parameters every time for each encryption operation.
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SecretKey myKey = ...</span><br><span class="line"><span class="keyword">byte</span>[] myAAD = ...</span><br><span class="line"><span class="keyword">byte</span>[] plainText = ...</span><br><span class="line">   <span class="keyword">int</span> myTLen = ... </span><br><span class="line">   <span class="keyword">byte</span>[] myIv = ...</span><br><span class="line"></span><br><span class="line">GCMParameterSpec myParams = <span class="keyword">new</span> GCMParameterSpec(myTLen, myIv);</span><br><span class="line">Cipher c = Cipher.getInstance(<span class="string">&quot;AES/GCM/NoPadding&quot;</span>);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, myKey, myParams);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AAD is optional, if present, it must be supplied before any update/doFinal calls.</span></span><br><span class="line">c.updateAAD(myAAD);  <span class="comment">// if AAD is non-null</span></span><br><span class="line"><span class="keyword">byte</span>[] cipherText = <span class="keyword">new</span> <span class="keyword">byte</span>[c.getOutputSize(plainText.length)];</span><br><span class="line">c.doFinal(plainText, <span class="number">0</span>, plainText.length, cipherText);    <span class="comment">// conclusion of encryption operation</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// To decrypt, same AAD and GCM parameters must be supplied</span></span><br><span class="line">c.init(Cipher.DECRYPT_MODE, myKey, myParams);</span><br><span class="line">c.updateAAD(myAAD);</span><br><span class="line"><span class="keyword">byte</span>[] recoveredText = c.doFinal(cipherText);</span><br><span class="line"></span><br><span class="line"><span class="comment">// MUST CHANGE IV VALUE if the same key were to be used again for encryption</span></span><br><span class="line">   <span class="keyword">byte</span>[] newIv = ...;</span><br><span class="line">myParams = <span class="keyword">new</span> GCMParameterSpec(myTLen, newIv);</span><br></pre></td></tr></table></figure></p>
<h3>Creating a Cipher Object</h3>
<p>Cipher objects are obtained by using one of the Cipher <code>getInstance()</code> static factory methods. Here, the algorithm name is slightly different than with other engine classes, in that it specifies not just an algorithm name, but a &quot;transformation&quot;. A transformation is a string that describes the operation (or set of operations) to be performed on the given input to produce some output. A transformation always includes the name of a cryptographic algorithm (e.g., DES), and may be followed by a mode and padding scheme.</p>
<p>A transformation is of the form:</p>
<ul class="ui list">
<li>&quot;algorithm/mode/padding&quot; or</li>
<li>&quot;algorithm&quot;</li>
</ul>
<p>For example, the following are valid transformations:</p>
<ul class="ui list">
<li>&quot;DES/CBC/PKCS5Padding&quot;</li>
<li>&quot;DES&quot;</li>
</ul>
<p>If just a transformation name is specified, the system will determine if there is an implementation of the requested transformation available in the environment, and if there is more than one, returns there is a preferred one.</p>
<p>If both a transformation name and a package provider are specified, the system will determine if there is an implementation of the requested transformation in the package requested, and throw an exception if there is not.</p>
<p>It is recommended to use a transformation that fully specifies the algorithm, mode, and padding. By not doing so, the provider will use a default. For example, the <code>SunJCE</code> and <code>SunPKCS11</code> providers use <code>ECB</code> as the default mode, and <code>PKCS5Padding</code> as the default padding for many symmetric ciphers.</p>
<p>This means that in the case of the SunJCE provider:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cipher c1 = Cipher.getInstance(<span class="string">&quot;DES/ECB/PKCS5Padding&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>and
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cipher c1 = Cipher.getInstance(<span class="string">&quot;DES&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>are equivalent statements.</p>
<blockquote>
<p>Note: <code>ECB</code> mode is the easiest block cipher mode to use and is the default in the JDK/JRE. ECB works well for single blocks of data, but absolutely should not be used for multiple data blocks.</p>
</blockquote>
<p>Using modes such as <code>CFB</code> and <code>OFB</code>, block ciphers can encrypt data in units smaller than the cipher&apos;s actual block size. When requesting such a mode, you may optionally specify the number of bits to be processed at a time by appending this number to the mode name as shown in the <code>&quot;DES/CFB8/NoPadding&quot;</code> and <code>&quot;DES/OFB32/PKCS5Padding&quot;</code> transformations. If no such number is specified, a provider-specific default is used. (For example, the SunJCE provider uses a default of 64 bits for DES.) Thus, block ciphers can be turned into byte-oriented stream ciphers by using an 8 bit mode such as CFB8 or OFB8.</p>
<p>Appendix A of this document contains a list of standard names that can be used to specify the algorithm name, mode, and padding scheme components of a transformation.</p>
<p>The objects returned by factory methods are uninitialized, and must be initialized before they become usable.</p>
<h3>Initializing a Cipher Object</h3>
<p>A Cipher object obtained via getInstance must be initialized for one of four modes, which are defined as final integer constants in the Cipher class. The modes can be referenced by their symbolic names, which are shown below along with a description of the purpose of each mode:</p>
<ul class="ui list">
<li><code>ENCRYPT_MODE</code> Encryption of data.</li>
<li><code>DECRYPT_MODE</code> Decryption of data.</li>
<li><code>WRAP_MODE</code> Wrapping a java.security.Key into bytes so that the key can be securely transported.</li>
<li><code>UNWRAP_MODE</code> Unwrapping of a previously wrapped key into a java.security.Key object.</li>
</ul>
<p>Each of the Cipher initialization methods takes an operational mode parameter (opmode), and initializes the Cipher object for that mode. Other parameters include the key (key) or certificate containing the key (certificate), algorithm parameters (params), and a source of randomness (random).</p>
<p>To initialize a Cipher object, call one of the following init methods:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode, Key key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode, Certificate certificate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode, Key key, SecureRandom random)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode, Certificate certificate, SecureRandom random)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode, Key key, AlgorithmParameterSpec params)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode, Key key, AlgorithmParameterSpec params, SecureRandom random)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode, Key key, AlgorithmParameters params)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode, Key key, AlgorithmParameters params, SecureRandom random)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>If a Cipher object that requires parameters (e.g., an initialization vector) is initialized for encryption, and no parameters are supplied to the init method, the underlying cipher implementation is supposed to supply the required parameters itself, either by generating random parameters or by using a default, provider-specific set of parameters.</p>
<p>However, if a Cipher object that requires parameters is initialized for decryption, and no parameters are supplied to the init method, an InvalidKeyException or InvalidAlgorithmParameterException exception will be raised, depending on the init method that has been used.</p>
<p>See the section about Managing Algorithm Parameters for more details.</p>
<p>The same parameters that were used for encryption must be used for decryption.</p>
<p>Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher, and initializing it. For example, if a Cipher is first initialized for decryption with a given key, and then initialized for encryption, it will lose any state acquired while in decryption mode.</p>
<h3>&#x52A0;&#x5BC6;&#x548C;&#x89E3;&#x5BC6;&#x6570;&#x636E;</h3>
<p>Data can be encrypted or decrypted in one step (single-part operation) or in multiple steps (multiple-part operation). A multiple-part operation is useful if you do not know in advance how long the data is going to be, or if the data is too long to be stored in memory all at once.</p>
<p>To encrypt or decrypt data in a single step, call one of the doFinal methods:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] doFinal(<span class="keyword">byte</span>[] input);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] doFinal(<span class="keyword">byte</span>[] input, <span class="keyword">int</span> inputOffset, <span class="keyword">int</span> inputLen);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doFinal</span><span class="params">(<span class="keyword">byte</span>[] input, <span class="keyword">int</span> inputOffset, <span class="keyword">int</span> inputLen, <span class="keyword">byte</span>[] output)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doFinal</span><span class="params">(<span class="keyword">byte</span>[] input, <span class="keyword">int</span> inputOffset, <span class="keyword">int</span> inputLen, <span class="keyword">byte</span>[] output, <span class="keyword">int</span> outputOffset)</span></span></span><br></pre></td></tr></table></figure></p>
<p>To encrypt or decrypt data in multiple steps, call one of the update methods:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] update(<span class="keyword">byte</span>[] input);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] update(<span class="keyword">byte</span>[] input, <span class="keyword">int</span> inputOffset, <span class="keyword">int</span> inputLen);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">byte</span>[] input, <span class="keyword">int</span> inputOffset, <span class="keyword">int</span> inputLen, <span class="keyword">byte</span>[] output)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">byte</span>[] input, <span class="keyword">int</span> inputOffset, <span class="keyword">int</span> inputLen, <span class="keyword">byte</span>[] output, <span class="keyword">int</span> outputOffset)</span></span></span><br></pre></td></tr></table></figure></p>
<p>A multiple-part operation must be terminated by one of the above doFinal methods (if there is still some input data left for the last step), or by one of the following doFinal methods (if there is no input data left for the last step):
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] doFinal();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doFinal</span><span class="params">(<span class="keyword">byte</span>[] output, <span class="keyword">int</span> outputOffset)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>All the doFinal methods take care of any necessary padding (or unpadding), if padding (or unpadding) has been requested as part of the specified transformation.</p>
<p>A call to doFinal resets the Cipher object to the state it was in when initialized via a call to init. That is, the Cipher object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to init) more data.</p>
<h3>&#x5305;&#x88C5;&#x548C;&#x89E3;&#x5305;&#x5BC6;&#x94A5;</h3>
<p>Wrapping a key enables secure transfer of the key from one place to another.</p>
<p>The wrap/unwrap API makes it more convenient to write code since it works with key objects directly. These methods also enable the possibility of secure transfer of hardware-based keys.</p>
<p>To wrap a Key, first initialize the Cipher object for <code>WRAP_MODE</code>, and then call the following:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] wrap(Key key);</span><br></pre></td></tr></table></figure></p>
<p>If you are supplying the wrapped key bytes (the result of calling wrap) to someone else who will unwrap them, be sure to also send additional information the recipient will need in order to do the unwrap:</p>
<p>the name of the key algorithm, and
the type of the wrapped key (one of <code>Cipher.SECRET_KEY</code>, <code>Cipher.PRIVATE_KEY</code>, or <code>Cipher.PUBLIC_KEY</code>).
The key algorithm name can be determined by calling the getAlgorithm method from the Key interface:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAlgorithm</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>To unwrap the bytes returned by a previous call to wrap, first initialize a Cipher object for <code>UNWRAP_MODE</code>, then call the following:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Key <span class="title">unwrap</span><span class="params">(<span class="keyword">byte</span>[] wrappedKey, String wrappedKeyAlgorithm, <span class="keyword">int</span> wrappedKeyType)</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>Here, wrappedKey is the bytes returned from the previous call to wrap, wrappedKeyAlgorithm is the algorithm associated with the wrapped key, and wrappedKeyType is the type of the wrapped key. This must be one of Cipher.SECRET_KEY, Cipher.PRIVATE_KEY, or Cipher.PUBLIC_KEY.</p>
<h3>&#x7BA1;&#x7406;&#x7B97;&#x6CD5;&#x53C2;&#x6570;</h3>
<p>The parameters being used by the underlying Cipher implementation, which were either explicitly passed to the init method by the application or generated by the underlying implementation itself, can be retrieved from the Cipher object by calling its getParameters method, which returns the parameters as a java.security.AlgorithmParameters object (or null if no parameters are being used). If the parameter is an <code>initialization vector (IV)</code>, it can also be retrieved by calling the <code>getIV</code> method.</p>
<p>In the following example, a Cipher object implementing password-based encryption (PBE) is initialized with just a key and no parameters. However, the selected algorithm for password-based encryption requires two parameters - a salt and an iteration count. Those will be generated by the underlying algorithm implementation itself. The application can retrieve the generated parameters from the Cipher object as follows:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"><span class="keyword">import</span> java.security.AlgorithmParameters;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get cipher object for password-based encryption</span></span><br><span class="line">Cipher c = Cipher.getInstance(<span class="string">&quot;PBEWithHmacSHA256AndAES_256&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize cipher for encryption, without supplying</span></span><br><span class="line"><span class="comment">// any parameters. Here, &quot;myKey&quot; is assumed to refer</span></span><br><span class="line"><span class="comment">// to an already-generated key.</span></span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, myKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">// encrypt some data and store away ciphertext</span></span><br><span class="line"><span class="comment">// for later decryption</span></span><br><span class="line"><span class="keyword">byte</span>[] cipherText = c.doFinal(<span class="string">&quot;This is just an example&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// retrieve parameters generated by underlying cipher</span></span><br><span class="line"><span class="comment">// implementation</span></span><br><span class="line">AlgorithmParameters algParams = c.getParameters();</span><br><span class="line"></span><br><span class="line"><span class="comment">// get parameter encoding and store it away</span></span><br><span class="line"><span class="keyword">byte</span>[] encodedAlgParams = algParams.getEncoded();</span><br></pre></td></tr></table></figure></p>
<p>The same parameters that were used for encryption must be used for decryption. They can be instantiated from their encoding and used to initialize the corresponding Cipher object for decryption, as follows:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"><span class="keyword">import</span> java.security.AlgorithmParameters;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get parameter object for password-based encryption</span></span><br><span class="line">AlgorithmParameters algParams;</span><br><span class="line">algParams = AlgorithmParameters.getInstance(<span class="string">&quot;PBEWithHmacSHA256AndAES_256&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize with parameter encoding from above</span></span><br><span class="line">algParams.init(encodedAlgParams);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get cipher object for password-based encryption</span></span><br><span class="line">Cipher c = Cipher.getInstance(<span class="string">&quot;PBEWithHmacSHA256AndAES_256&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize cipher for decryption, using one of the</span></span><br><span class="line"><span class="comment">// init() methods that takes an AlgorithmParameters</span></span><br><span class="line"><span class="comment">// object, and pass it the algParams object from above</span></span><br><span class="line">c.init(Cipher.DECRYPT_MODE, myKey, algParams);</span><br></pre></td></tr></table></figure></p>
<p>If you did not specify any parameters when you initialized a Cipher object, and you are not sure whether or not the underlying implementation uses any parameters, you can find out by simply calling the getParameters method of your Cipher object and checking the value returned. A return value of null indicates that no parameters were used.</p>
<p>The following cipher algorithms implemented by the SunJCE provider use parameters:</p>
<p><code>DES, DES-EDE, and Blowfish</code>, when used in feedback (i.e., <code>CBC, CFB, OFB, or PCBC</code>) mode, use an <code>initialization vector (IV)</code>. The <code>javax.crypto.spec.IvParameterSpec</code> class can be used to initialize a Cipher object with a given IV.
PBE Cipher algorithms use a set of parameters, comprising of a salt and an iteration count. The javax.crypto.spec.PBEParameterSpec class can be used to initialize a Cipher object implementing a PBE algorithm (for example: PBEWithHmacSHA256AndAES_256) with a given salt and iteration count.
Note that you do not have to worry about storing or transferring any algorithm parameters for use by the decryption operation if you use the SealedObject class. This class attaches the parameters used for sealing (encryption) to the encrypted object contents, and uses the same parameters for unsealing (decryption).</p>
<h3>Cipher Output Considerations</h3>
<p>Some of the update and doFinal methods of Cipher allow the caller to specify the output buffer into which to encrypt or decrypt the data. In these cases, it is important to pass a buffer that is large enough to hold the result of the encryption or decryption operation.</p>
<p>The following method in Cipher can be used to determine how big the output buffer should be:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOutputSize</span><span class="params">(<span class="keyword">int</span> inputLen)</span></span></span><br></pre></td></tr></table></figure></p>
<h3>Other Cipher-based Classes</h3>
<p>There are some helper classes which internally use Ciphers to provide easy access to common cipher uses.</p>
<h4>The Cipher Stream Classes</h4>
<p>The CipherInputStream Class
This class is a FilterInputStream that encrypts or decrypts the data passing through it. It is composed of an InputStream, or one of its subclasses, and a Cipher. CipherInputStream represents a secure input stream into which a Cipher object has been interposed. The read methods of CipherInputStream return data that are read from the underlying InputStream but have additionally been processed by the embedded Cipher object. The Cipher object must be fully initialized before being used by a CipherInputStream.</p>
<p>For example, if the embedded Cipher has been initialized for decryption, the CipherInputStream will attempt to decrypt the data it reads from the underlying InputStream before returning them to the application.</p>
<p>This class adheres strictly to the semantics, especially the failure semantics, of its ancestor classes java.io.FilterInputStream and java.io.InputStream. This class has exactly those methods specified in its ancestor classes, and overrides them all, so that the data are additionally processed by the embedded cipher. Moreover, this class catches all exceptions that are not thrown by its ancestor classes. In particular, the skip(long) method skips only data that has been processed by the Cipher.</p>
<p>It is crucial for a programmer using this class not to use methods that are not defined or overridden in this class (such as a new method or constructor that is later added to one of the super classes), because the design and implementation of those methods are unlikely to have considered security impact with regard to CipherInputStream.</p>
<p>As an example of its usage, suppose cipher1 has been initialized for encryption. The code below demonstrates how to use a CipherInputStream containing that cipher and a FileInputStream in order to encrypt input stream data:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis;</span><br><span class="line">FileOutputStream fos;</span><br><span class="line">CipherInputStream cis;</span><br><span class="line"></span><br><span class="line">fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/tmp/a.txt&quot;</span>);</span><br><span class="line">cis = <span class="keyword">new</span> CipherInputStream(fis, cipher1);</span><br><span class="line">fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/tmp/b.txt&quot;</span>);</span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> i = cis.read(b);</span><br><span class="line"><span class="keyword">while</span> (i != -<span class="number">1</span>) {</span><br><span class="line">    fos.write(b, <span class="number">0</span>, i);</span><br><span class="line">    i = cis.read(b);</span><br><span class="line">}</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure></p>
<p>The above program reads and encrypts the content from the file /tmp/a.txt and then stores the result (the encrypted bytes) in /tmp/b.txt.</p>
<p>The following example demonstrates how to easily connect several instances of CipherInputStream and FileInputStream. In this example, assume that cipher1 and cipher2 have been initialized for encryption and decryption (with corresponding keys), respectively.
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis;</span><br><span class="line">FileOutputStream fos;</span><br><span class="line">CipherInputStream cis1, cis2;</span><br><span class="line"></span><br><span class="line">fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/tmp/a.txt&quot;</span>);</span><br><span class="line">cis1 = <span class="keyword">new</span> CipherInputStream(fis, cipher1);</span><br><span class="line">cis2 = <span class="keyword">new</span> CipherInputStream(cis1, cipher2);</span><br><span class="line">fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/tmp/b.txt&quot;</span>);</span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> i = cis2.read(b);</span><br><span class="line"><span class="keyword">while</span> (i != -<span class="number">1</span>) {</span><br><span class="line">    fos.write(b, <span class="number">0</span>, i);</span><br><span class="line">    i = cis2.read(b);</span><br><span class="line">}</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure></p>
<p>The above program copies the content from file /tmp/a.txt to /tmp/b.txt, except that the content is first encrypted and then decrypted back when it is read from /tmp/a.txt. Of course since this program simply encrypts text and decrypts it back right away, it&apos;s actually not very useful except as a simple way of illustrating chaining of CipherInputStreams.</p>
<p>Note that the read methods of the CipherInputStream will block until data is returned from the underlying cipher. If a block cipher is used, a full block of cipher text will have to be obtained from the underlying InputStream.</p>
<h3>The CipherOutputStream Class</h3>
<p>This class is a FilterOutputStream that encrypts or decrypts the data passing through it. It is composed of an OutputStream, or one of its subclasses, and a Cipher. CipherOutputStream represents a secure output stream into which a Cipher object has been interposed. The write methods of CipherOutputStream first process the data with the embedded Cipher object before writing them out to the underlying OutputStream. The Cipher object must be fully initialized before being used by a CipherOutputStream.</p>
<p>For example, if the embedded Cipher has been initialized for encryption, the CipherOutputStream will encrypt its data, before writing them out to the underlying output stream.</p>
<p>This class adheres strictly to the semantics, especially the failure semantics, of its ancestor classes java.io.OutputStream and java.io.FilterOutputStream. This class has exactly those methods specified in its ancestor classes, and overrides them all, so that all data are additionally processed by the embedded cipher. Moreover, this class catches all exceptions that are not thrown by its ancestor classes.</p>
<p>It is crucial for a programmer using this class not to use methods that are not defined or overridden in this class (such as a new method or constructor that is later added to one of the super classes), because the design and implementation of those methods are unlikely to have considered security impact with regard to CipherOutputStream.</p>
<p>As an example of its usage, suppose cipher1 has been initialized for encryption. The code below demonstrates how to use a CipherOutputStream containing that cipher and a FileOutputStream in order to encrypt data to be written to an output stream:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis;</span><br><span class="line">FileOutputStream fos;</span><br><span class="line">CipherOutputStream cos;</span><br><span class="line"></span><br><span class="line">fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/tmp/a.txt&quot;</span>);</span><br><span class="line">fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/tmp/b.txt&quot;</span>);</span><br><span class="line">cos = <span class="keyword">new</span> CipherOutputStream(fos, cipher1);</span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> i = fis.read(b);</span><br><span class="line"><span class="keyword">while</span> (i != -<span class="number">1</span>) {</span><br><span class="line">    cos.write(b, <span class="number">0</span>, i);</span><br><span class="line">    i = fis.read(b);</span><br><span class="line">}</span><br><span class="line">cos.flush();</span><br></pre></td></tr></table></figure></p>
<p>The above program reads the content from the file /tmp/a.txt, then encrypts and stores the result (the encrypted bytes) in /tmp/b.txt.</p>
<p>The following example demonstrates how to easily connect several instances of CipherOutputStream and FileOutputStream. In this example, assume that cipher1 and cipher2 have been initialized for decryption and encryption (with corresponding keys), respectively:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis;</span><br><span class="line">FileOutputStream fos;</span><br><span class="line">CipherOutputStream cos1, cos2;</span><br><span class="line"></span><br><span class="line">fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/tmp/a.txt&quot;</span>);</span><br><span class="line">fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/tmp/b.txt&quot;</span>);</span><br><span class="line">cos1 = <span class="keyword">new</span> CipherOutputStream(fos, cipher1);</span><br><span class="line">cos2 = <span class="keyword">new</span> CipherOutputStream(cos1, cipher2);</span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> i = fis.read(b);</span><br><span class="line"><span class="keyword">while</span> (i != -<span class="number">1</span>) {</span><br><span class="line">    cos2.write(b, <span class="number">0</span>, i);</span><br><span class="line">    i = fis.read(b);</span><br><span class="line">}</span><br><span class="line">cos2.flush();</span><br></pre></td></tr></table></figure></p>
<p>The above program copies the content from file /tmp/a.txt to /tmp/b.txt, except that the content is first encrypted and then decrypted back before it is written to /tmp/b.txt.</p>
<p>One thing to keep in mind when using block cipher algorithms is that a full block of plaintext data must be given to the CipherOutputStream before the data will be encrypted and sent to the underlying output stream.</p>
<p>There is one other important difference between the flush and close methods of this class, which becomes even more relevant if the encapsulated Cipher object implements a block cipher algorithm with padding turned on:</p>
<ul class="ui list">
<li>flush flushes the underlying OutputStream by forcing any buffered output bytes that have already been processed by the encapsulated Cipher object to be written out. Any bytes buffered by the encapsulated Cipher object and waiting to be processed by it will not be written out.</li>
<li>close closes the underlying OutputStream and releases any system resources associated with it. It invokes the doFinal method of the encapsulated Cipher object, causing any bytes buffered by it to be processed and written out to the underlying stream by calling its flush method.</li>
</ul>
<h2>The SealedObject Class</h2>
<p>This class enables a programmer to create an object and protect its confidentiality with a cryptographic algorithm.</p>
<p>Given any object that implements the java.io.Serializable interface, one can create a SealedObject that encapsulates the original object, in serialized format (i.e., a &quot;deep copy&quot;), and seals (encrypts) its serialized contents, using a cryptographic algorithm such as DES, to protect its confidentiality. The encrypted content can later be decrypted (with the corresponding algorithm using the correct decryption key) and de-serialized, yielding the original object.</p>
<p>A typical usage is illustrated in the following code segment: In order to seal an object, you create a SealedObject from the object to be sealed and a fully initialized Cipher object that will encrypt the serialized object contents. In this example, the String &quot;This is a secret&quot; is sealed using the DES algorithm. Note that any algorithm parameters that may be used in the sealing operation are stored inside of SealedObject:
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create Cipher object</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> sKey is assumed to refer to an already-generated</span></span><br><span class="line"><span class="comment">// secret DES key.</span></span><br><span class="line">Cipher c = Cipher.getInstance(<span class="string">&quot;DES&quot;</span>);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, sKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">// do the sealing</span></span><br><span class="line">SealedObject so = <span class="keyword">new</span> SealedObject(<span class="string">&quot;This is a secret&quot;</span>, c);</span><br></pre></td></tr></table></figure></p>
<p>The original object that was sealed can be recovered in two different ways:</p>
<p>by using a Cipher object that has been initialized with the exact same algorithm, key, padding scheme, etc., that were used to seal the object:
c.init(Cipher.DECRYPT_MODE, sKey);
try {
String s = (String)so.getObject(c);
} catch (Exception e) {
// do something
};
This approach has the advantage that the party who unseals the sealed object does not require knowledge of the decryption key. For example, after one party has initialized the cipher object with the required decryption key, it could hand over the cipher object to another party who then unseals the sealed object.</p>
<p>by using the appropriate decryption key (since DES is a symmetric encryption algorithm, we use the same key for sealing and unsealing):
try {
String s = (String)so.getObject(sKey);
} catch (Exception e) {
// do something
};
In this approach, the getObject method creates a cipher object for the appropriate decryption algorithm and initializes it with the given decryption key and the algorithm parameters (if any) that were stored in the sealed object. This approach has the advantage that the party who unseals the object does not need to keep track of the parameters (e.g., the IV) that were used to seal the object.</p>
<p>The Mac Class
Similar to a MessageDigest, a Message Authentication Code (MAC) provides a way to check the integrity of information transmitted over or stored in an unreliable medium, but includes a secret key in the calculation. Only someone with the proper key will be able to verify the received message. Typically, message authentication codes are used between two parties that share a secret key in order to validate information transmitted between these parties.</p>
<p>The Mac Class
Description of Figure 8: The Mac Class</p>
<p>A MAC mechanism that is based on cryptographic hash functions is referred to as HMAC. HMAC can be used with any cryptographic hash function, e.g., MD5 or SHA-1, in combination with a secret shared key.</p>
<p>The Mac class provides the functionality of a Message Authentication Code (MAC). Please refer to the code example.</p>
<p>Creating a Mac Object</p>
<p>Mac objects are obtained by using one of the Mac getInstance() static factory methods.</p>
<p>Initializing a Mac Object</p>
<p>A Mac object is always initialized with a (secret) key and may optionally be initialized with a set of parameters, depending on the underlying MAC algorithm.</p>
<p>To initialize a Mac object, call one of its init methods:</p>
<pre><code>public void init(Key key);

public void init(Key key, AlgorithmParameterSpec params);
</code></pre>
<p>You can initialize your Mac object with any (secret-)key object that implements the javax.crypto.SecretKey interface. This could be an object returned by javax.crypto.KeyGenerator.generateKey(), or one that is the result of a key agreement protocol, as returned by javax.crypto.KeyAgreement.generateSecret(), or an instance of javax.crypto.spec.SecretKeySpec.</p>
<p>With some MAC algorithms, the (secret-)key algorithm associated with the (secret-)key object used to initialize the Mac object does not matter (this is the case with the HMAC-MD5 and HMAC-SHA1 implementations of the SunJCE provider). With others, however, the (secret-)key algorithm does matter, and an InvalidKeyException is thrown if a (secret-)key object with an inappropriate (secret-)key algorithm is used.</p>
<p>Computing a MAC</p>
<p>A MAC can be computed in one step (single-part operation) or in multiple steps (multiple-part operation). A multiple-part operation is useful if you do not know in advance how long the data is going to be, or if the data is too long to be stored in memory all at once.</p>
<p>To compute the MAC of some data in a single step, call the following doFinal method:</p>
<pre><code>public byte[] doFinal(byte[] input);
</code></pre>
<p>To compute the MAC of some data in multiple steps, call one of the update methods:</p>
<pre><code>public void update(byte input);

public void update(byte[] input);

public void update(byte[] input, int inputOffset, int inputLen);
</code></pre>
<p>A multiple-part operation must be terminated by the above doFinal method (if there is still some input data left for the last step), or by one of the following doFinal methods (if there is no input data left for the last step):</p>
<pre><code>public byte[] doFinal();

public void doFinal(byte[] output, int outOffset);
</code></pre>
<p>Key Interfaces
To this point, we have focused the high-level uses of the JCA without getting lost in the details of what keys are and how they are generated/represented. It is now time to turn our attention to keys.</p>
<p>The java.security.Key interface is the top-level interface for all opaque keys. It defines the functionality shared by all opaque key objects.</p>
<p>An opaque key representation is one in which you have no direct access to the key material that constitutes a key. In other words: &quot;opaque&quot; gives you limited access to the key--just the three methods defined by the Key interface (see below): getAlgorithm, getFormat, and getEncoded.</p>
<p>This is in contrast to a transparent representation, in which you can access each key material value individually, through one of the get methods defined in the corresponding specification class.</p>
<p>All opaque keys have three characteristics:</p>
<p>An Algorithm
The key algorithm for that key. The key algorithm is usually an encryption or asymmetric operation algorithm (such as AES, DSA or RSA), which will work with those algorithms and with related algorithms (such as MD5withRSA, SHA1withRSA, etc.) The name of the algorithm of a key is obtained using this method:
String getAlgorithm()
An Encoded Form
The external encoded form for the key used when a standard representation of the key is needed outside the Java Virtual Machine, as when transmitting the key to some other party. The key is encoded according to a standard format (such as X.509 or PKCS8), and is returned using the method:
byte[] getEncoded()
A Format
The name of the format of the encoded key. It is returned by the method:
String getFormat()
Keys are generally obtained through key generators such as KeyGenerator and KeyPairGenerator, certificates, key specifications (using a KeyFactory), or a KeyStore implementation accessing a keystore database used to manage keys. It is possible to parse encoded keys, in an algorithm-dependent manner, using a KeyFactory.
It is also possible to parse certificates, using a CertificateFactory.</p>
<p>Here is a list of interfaces which extend the Key interface in the java.security.interfaces and javax.crypto.interfaces packages:</p>
<p>SecretKey
PBEKey
PrivateKey
DHPrivateKey
DSAPrivateKey
ECPrivateKey
RSAMultiPrimePrivateCrtKey
RSAPrivateCrtKey
RSAPrivateKey
PublicKey
DHPublicKey
DSAPublicKey
ECPublicKey
RSAPublicKey
The PublicKey and PrivateKey Interfaces</p>
<p>The PublicKey and PrivateKey interfaces (which both extend the Key interface) are methodless interfaces, used for type-safety and type-identification.</p>
<p>The KeyPair Class
The KeyPair class is a simple holder for a key pair (a public key and a private key). It has two public methods, one for returning the private key, and the other for returning the public key:</p>
<p>PrivateKey getPrivate()
PublicKey getPublic()
Key Specification Interfaces and Classes
Key objects and key specifications (KeySpecs) are two different representations of key data. Ciphers use Key objects to initialize their encryption algorithms, but keys may need to be converted into a more portable format for transmission or storage.</p>
<p>A transparent representation of keys means that you can access each key material value individually, through one of the get methods defined in the corresponding specification class. For example, DSAPrivateKeySpec defines getX, getP, getQ, and getG methods, to access the private key x, and the DSA algorithm parameters used to calculate the key: the prime p, the sub-prime q, and the base g. If the key is stored on a hardware device, its specification may contain information that helps identify the key on the device.</p>
<p>This representation is contrasted with an opaque representation, as defined by the Key interface, in which you have no direct access to the key material fields. In other words, an &quot;opaque&quot; representation gives you limited access to the key--just the three methods defined by the Key interface: getAlgorithm, getFormat, and getEncoded.</p>
<p>A key may be specified in an algorithm-specific way, or in an algorithm-independent encoding format (such as ASN.1). For example, a DSA private key may be specified by its components x, p, q, and g (see DSAPrivateKeySpec), or it may be specified using its DER encoding (see PKCS8EncodedKeySpec).</p>
<p>The KeyFactory and SecretKeyFactory classes can be used to convert between opaque and transparent key representations (that is, between Keys and KeySpecs, assuming that the operation is possible. (For example, private keys on smart cards might not be able leave the card. Such Keys are not convertible.)</p>
<p>In the following sections, we discuss the key specification interfaces and classes in the java.security.spec package.</p>
<p>The KeySpec Interface</p>
<p>This interface contains no methods or constants. Its only purpose is to group and provide type safety for all key specifications. All key specifications must implement this interface.</p>
<p>The KeySpec Subinterfaces</p>
<p>Like the Key interface, there are a similar set of KeySpec interfaces.</p>
<p>SecretKeySpec
EncodedKeySpec
PKCS8EncodedKeySpec
X509EncodedKeySpec
DESKeySpec
DESedeKeySpec
PBEKeySpec
DHPrivateKeySpec
DSAPrivateKeySpec
ECPrivateKeySpec
RSAPrivateKeySpec
RSAMultiPrimePrivateCrtKeySpec
RSAPrivateCrtKeySpec
DHPublicKeySpec
DSAPublicKeySpec
ECPublicKeySpec
RSAPublicKeySpec
The EncodedKeySpec Class</p>
<p>This abstract class (which implements the KeySpec interface) represents a public or private key in encoded format. Its getEncoded method returns the encoded key:</p>
<p>abstract byte[] getEncoded();
and its getFormat method returns the name of the encoding format:
abstract String getFormat();
See the next sections for the concrete implementations PKCS8EncodedKeySpec and X509EncodedKeySpec.</p>
<p>The PKCS8EncodedKeySpec Class
This class, which is a subclass of EncodedKeySpec, represents the DER encoding of a private key, according to the format specified in the PKCS8 standard. Its getEncoded method returns the key bytes, encoded according to the PKCS8 standard. Its getFormat method returns the string &quot;PKCS#8&quot;.</p>
<p>The X509EncodedKeySpec Class
This class, which is a subclass of EncodedKeySpec, represents the DER encoding of a public key, according to the format specified in the X.509 standard. Its getEncoded method returns the key bytes, encoded according to the X.509 standard. Its getFormat method returns the string &quot;X.509&quot;.</p>
<p>Of Generators and Factories
Newcomers to Java and the JCA APIs in particular sometimes do not grasp the distinction between generators and factories.</p>
<p>Differences Between Generators and Factories
Description of Figure Differences Between Generators and Factories</p>
<p>Generators are used to generate brand new objects. Generators can be initialized in either an algorithm-dependent or algorithm-independent way. For example, to create a Diffie-Hellman (DH) keypair, an application could specify the necessary P and G values, or the generator could simply be initialized with the appropriate key length, and the generator will select appropriate P and G values. In both cases, the generator will produce brand new keys based on the parameters.</p>
<p>On the other hand, factories are used to convert data from one existing object type to another. For example, an application might have available the components of a DH private key and can package them as a KeySpec, but needs to convert them into a PrivateKey object that can be used by a KeyAgreement object, or vice-versa. Or they might have the byte array of a certificate, but need to use a CertificateFactory to convert it into a X509Certificate object. Applications use factory objects to do the conversion.</p>
<p>The KeyFactory Class
The KeyFactory class is an engine class designed to perform conversions between opaque cryptographic Keys and key specifications (transparent representations of the underlying key material).</p>
<p>The KeyFactory Class&lt;
Description of Figure The KeyFactory Class</p>
<p>Key factories are bi-directional. They allow you to build an opaque key object from a given key specification (key material), or to retrieve the underlying key material of a key object in a suitable format.</p>
<p>Multiple compatible key specifications can exist for the same key. For example, a DSA public key may be specified by its components y, p, q, and g (see java.security.spec.DSAPublicKeySpec), or it may be specified using its DER encoding according to the X.509 standard (see X509EncodedKeySpec).</p>
<p>A key factory can be used to translate between compatible key specifications. Key parsing can be achieved through translation between compatible key specifications, e.g., when you translate from X509EncodedKeySpec to DSAPublicKeySpec, you basically parse the encoded key into its components. For an example, see the end of the Generating/Verifying Signatures Using Key Specifications and KeyFactory section.</p>
<p>Creating a KeyFactory Object</p>
<p>KeyFactory objects are obtained by using one of the KeyFactory getInstance() static factory methods.</p>
<p>Converting Between a Key Specification and a Key Object</p>
<p>If you have a key specification for a public key, you can obtain an opaque PublicKey object from the specification by using the generatePublic method:</p>
<p>PublicKey generatePublic(KeySpec keySpec)
Similarly, if you have a key specification for a private key, you can obtain an opaque PrivateKey object from the specification by using the generatePrivate method:</p>
<p>PrivateKey generatePrivate(KeySpec keySpec)
Converting Between a Key Object and a Key Specification</p>
<p>If you have a Key object, you can get a corresponding key specification object by calling the getKeySpec method:</p>
<p>KeySpec getKeySpec(Key key, Class keySpec)
keySpec identifies the specification class in which the key material should be returned. It could, for example, be DSAPublicKeySpec.class, to indicate that the key material should be returned in an instance of the DSAPublicKeySpec class.
Please see the Examples section for more details.</p>
<p>The SecretKeyFactory Class
This class represents a factory for secret keys. Unlike KeyFactory, a javax.crypto.SecretKeyFactory object operates only on secret (symmetric) keys, whereas a java.security.KeyFactory object processes the public and private key components of a key pair.</p>
<p>The SecretKeyFactory Class
Description of The SecretKeyFactory Class</p>
<p>Key factories are used to convert Keys (opaque cryptographic keys of type java.security.Key) into key specifications (transparent representations of the underlying key material in a suitable format), and vice versa.</p>
<p>Objects of type java.security.Key, of which java.security.PublicKey, java.security.PrivateKey, and javax.crypto.SecretKey are subclasses, are opaque key objects, because you cannot tell how they are implemented. The underlying implementation is provider-dependent, and may be software or hardware based. Key factories allow providers to supply their own implementations of cryptographic keys.</p>
<p>For example, if you have a key specification for a Diffie Hellman public key, consisting of the public value y, the prime modulus p, and the base g, and you feed the same specification to Diffie-Hellman key factories from different providers, the resulting PublicKey objects will most likely have different underlying implementations.</p>
<p>A provider should document the key specifications supported by its secret key factory. For example, the SecretKeyFactory for DES keys supplied by the SunJCE provider supports DESKeySpec as a transparent representation of DES keys, the SecretKeyFactory for DES-EDE keys supports DESedeKeySpec as a transparent representation of DES-EDE keys, and the SecretKeyFactory for PBE supports PBEKeySpec as a transparent representation of the underlying password.</p>
<p>The following is an example of how to use a SecretKeyFactory to convert secret key data into a SecretKey object, which can be used for a subsequent Cipher operation:</p>
<pre><code>// Note the following bytes are not realistic secret key data
// bytes but are simply supplied as an illustration of using data
// bytes (key material) you already have to build a DESKeySpec.
byte[] desKeyData = { (byte)0x01, (byte)0x02, (byte)0x03,
(byte)0x04, (byte)0x05, (byte)0x06, (byte)0x07, (byte)0x08 };
DESKeySpec desKeySpec = new DESKeySpec(desKeyData);
SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;);
SecretKey secretKey = keyFactory.generateSecret(desKeySpec);
</code></pre>
<p>In this case, the underlying implementation of SecretKey is based on the provider of KeyFactory.</p>
<p>An alternative, provider-independent way of creating a functionally equivalent SecretKey object from the same key material is to use the javax.crypto.spec.SecretKeySpec class, which implements the javax.crypto.SecretKey interface:</p>
<pre><code>byte[] desKeyData = { (byte)0x01, (byte)0x02, ...};
SecretKeySpec secretKey = new SecretKeySpec(desKeyData, &quot;DES&quot;);
</code></pre>
<p>Creating a SecretKeyFactory Object</p>
<p>SecretKeyFactory objects are obtained by using one of the SecretKeyFactory getInstance() static factory methods.</p>
<p>Converting Between a Key Specification and a Secret Key Object</p>
<p>If you have a key specification for a secret key, you can obtain an opaque SecretKey object from the specification by using the generateSecret method:</p>
<p>SecretKey generateSecret(KeySpec keySpec)
Converting Between a Secret Key Object and a Key Specification</p>
<p>If you have a Secret Key object, you can get a corresponding key specification object by calling the getKeySpec method:</p>
<p>KeySpec getKeySpec(Key key, Class keySpec)
keySpec identifies the specification class in which the key material should be returned. It could, for example, be DESKeySpec.class, to indicate that the key material should be returned in an instance of the DESKeySpec class.
The KeyPairGenerator Class
The KeyPairGenerator class is an engine class used to generate pairs of public and private keys.</p>
<p>The KeyPairGenerator Class
Description of The KeyPairGenerator Class</p>
<p>There are two ways to generate a key pair: in an algorithm-independent manner, and in an algorithm-specific manner. The only difference between the two is the initialization of the object.</p>
<p>Please see the Examples section for examples of calls to the methods documented below.</p>
<p>Creating a KeyPairGenerator</p>
<p>All key pair generation starts with a KeyPairGenerator. KeyPairGenerator objects are obtained by using one of the KeyPairGenerator getInstance() static factory methods.</p>
<p>Initializing a KeyPairGenerator</p>
<p>A key pair generator for a particular algorithm creates a public/private key pair that can be used with this algorithm. It also associates algorithm-specific parameters with each of the generated keys.</p>
<p>A key pair generator needs to be initialized before it can generate keys. In most cases, algorithm-independent initialization is sufficient. But in other cases, algorithm-specific initialization can be used.</p>
<p>Algorithm-Independent Initialization
All key pair generators share the concepts of a keysize and a source of randomness. The keysize is interpreted differently for different algorithms. For example, in the case of the DSA algorithm, the keysize corresponds to the length of the modulus. (See the Standard Names document for information about the keysizes for specific algorithms.)</p>
<p>An initialize method takes two universally shared types of arguments:</p>
<p>void initialize(int keysize, SecureRandom random)
Another initialize method takes only a keysize argument; it uses a system-provided source of randomness:
void initialize(int keysize)
Since no other parameters are specified when you call the above algorithm-independent initialize methods, it is up to the provider what to do about the algorithm-specific parameters (if any) to be associated with each of the keys.</p>
<p>If the algorithm is a &quot;DSA&quot; algorithm, and the modulus size (keysize) is 512, 768, or 1024, then the SUN provider uses a set of precomputed values for the p, q, and g parameters. If the modulus size is not one of the above values, the SUN provider creates a new set of parameters. Other providers might have precomputed parameter sets for more than just the three modulus sizes mentioned above. Still others might not have a list of precomputed parameters at all and instead always create new parameter sets.</p>
<p>Algorithm-Specific Initialization
For situations where a set of algorithm-specific parameters already exists (such as &quot;community parameters&quot; in DSA), there are two initialize methods that have an AlgorithmParameterSpec argument. One also has a SecureRandom argument, while the source of randomness is system-provided for the other:</p>
<p>void initialize(AlgorithmParameterSpec params,
SecureRandom random)</p>
<p>void initialize(AlgorithmParameterSpec params)
See the Examples section for more details.
Generating a Key Pair</p>
<p>The procedure for generating a key pair is always the same, regardless of initialization (and of the algorithm). You always call the following method from KeyPairGenerator:</p>
<p>KeyPair generateKeyPair()
Multiple calls to generateKeyPair will yield different key pairs.
The KeyGenerator Class
A key generator is used to generate secret keys for symmetric algorithms.</p>
<p>The KeyGenerator Class
Description of Figure The KeyGenerator Class</p>
<p>Creating a KeyGenerator</p>
<p>KeyGenerator objects are obtained by using one of the KeyGenerator getInstance() static factory methods.
Initializing a KeyGenerator Object</p>
<p>A key generator for a particular symmetric-key algorithm creates a symmetric key that can be used with that algorithm. It also associates algorithm-specific parameters (if any) with the generated key.</p>
<p>There are two ways to generate a key: in an algorithm-independent manner, and in an algorithm-specific manner. The only difference between the two is the initialization of the object:</p>
<p>Algorithm-Independent Initialization
All key generators share the concepts of a keysize and a source of randomness. There is an init method that takes these two universally shared types of arguments. There is also one that takes just a keysize argument, and uses a system-provided source of randomness, and one that takes just a source of randomness:</p>
<pre><code>public void init(SecureRandom random);

public void init(int keysize);

public void init(int keysize, SecureRandom random);
</code></pre>
<p>Since no other parameters are specified when you call the above algorithm-independent init methods, it is up to the provider what to do about the algorithm-specific parameters (if any) to be associated with the generated key.</p>
<p>Algorithm-Specific Initialization
For situations where a set of algorithm-specific parameters already exists, there are two init methods that have an AlgorithmParameterSpec argument. One also has a SecureRandom argument, while the source of randomness is system-provided for the other:</p>
<pre><code>public void init(AlgorithmParameterSpec params);

public void init(AlgorithmParameterSpec params, SecureRandom random);
</code></pre>
<p>In case the client does not explicitly initialize the KeyGenerator (via a call to an init method), each provider must supply (and document) a default initialization.</p>
<p>Creating a Key</p>
<p>The following method generates a secret key:</p>
<pre><code>public SecretKey generateKey();
</code></pre>
<p>The KeyAgreement Class
Key agreement is a protocol by which 2 or more parties can establish the same cryptographic keys, without having to exchange any secret information.</p>
<p>The KeyAgreement Class
Description of Figure The KeyAgreement Class</p>
<p>Each party initializes their key agreement object with their private key, and then enters the public keys for each party that will participate in the communication. In most cases, there are just two parties, but algorithms such as Diffie-Hellman allow for multiple parties (3 or more) to participate. When all the public keys have been entered, each KeyAgreement object will generate (agree upon) the same key.</p>
<p>The KeyAgreement class provides the functionality of a key agreement protocol. The keys involved in establishing a shared secret are created by one of the key generators (KeyPairGenerator or KeyGenerator), a KeyFactory, or as a result from an intermediate phase of the key agreement protocol.</p>
<p>Creating a KeyAgreement Object</p>
<p>Each party involved in the key agreement has to create a KeyAgreement object. KeyAgreement objects are obtained by using one of the KeyAgreement getInstance() static factory methods.</p>
<p>Initializing a KeyAgreement Object</p>
<p>You initialize a KeyAgreement object with your private information. In the case of Diffie-Hellman, you initialize it with your Diffie-Hellman private key. Additional initialization information may contain a source of randomness and/or a set of algorithm parameters. Note that if the requested key agreement algorithm requires the specification of algorithm parameters, and only a key, but no parameters are provided to initialize the KeyAgreement object, the key must contain the required algorithm parameters. (For example, the Diffie-Hellman algorithm uses a prime modulus p and a base generator g as its parameters.)</p>
<p>To initialize a KeyAgreement object, call one of its init methods:</p>
<pre><code>public void init(Key key);

public void init(Key key, SecureRandom random);

public void init(Key key, AlgorithmParameterSpec params);

public void init(Key key, AlgorithmParameterSpec params,
                 SecureRandom random);
</code></pre>
<p>Executing a KeyAgreement Phase</p>
<p>Every key agreement protocol consists of a number of phases that need to be executed by each party involved in the key agreement.</p>
<p>To execute the next phase in the key agreement, call the doPhase method:</p>
<pre><code>public Key doPhase(Key key, boolean lastPhase);
</code></pre>
<p>The key parameter contains the key to be processed by that phase. In most cases, this is the public key of one of the other parties involved in the key agreement, or an intermediate key that was generated by a previous phase. doPhase may return an intermediate key that you may have to send to the other parties of this key agreement, so they can process it in a subsequent phase.</p>
<p>The lastPhase parameter specifies whether or not the phase to be executed is the last one in the key agreement: A value of FALSE indicates that this is not the last phase of the key agreement (there are more phases to follow), and a value of TRUE indicates that this is the last phase of the key agreement and the key agreement is completed, i.e., generateSecret can be called next.</p>
<p>In the example of Diffie-Hellman between two parties , you call doPhase once, with lastPhase set to TRUE. In the example of Diffie-Hellman between three parties, you call doPhase twice: the first time with lastPhase set to FALSE, the 2nd time with lastPhase set to TRUE.</p>
<p>Generating the Shared Secret</p>
<p>After each party has executed all the required key agreement phases, it can compute the shared secret by calling one of the generateSecret methods:</p>
<pre><code>public byte[] generateSecret();

public int generateSecret(byte[] sharedSecret, int offset);

public SecretKey generateSecret(String algorithm);
</code></pre>
<p>Key Management
A database called a &quot;keystore&quot; can be used to manage a repository of keys and certificates. (A certificate is a digitally signed statement from one entity, saying that the public key of some other entity has a particular value.)</p>
<p>Keystore Location</p>
<p>The user keystore is by default stored in a file named .keystore in the user&apos;s home directory, as determined by the &quot;user.home&quot; system property. On Solaris systems &quot;user.home&quot; defaults to the user&apos;s home directory. On Win32 systems, given user name uName, &quot;user.home&quot; defaults to:</p>
<p>C:\Winnt\Profiles\uName on multi-user Windows NT systems
C:\Windows\Profiles\uName on multi-user Windows 95/98/2000 systems
C:\Windows on single-user Windows 95/98/2000 systems
Of course, keystore files can be located as desired. In some environments, it may make sense for multiple keystores to exist. For example, in JSSE (SSL/TLS), one keystore might hold a user&apos;s private keys, and another might hold certificates used to establish trust relationships.</p>
<p>In addition to the user&apos;s keystore, the JDK also maintains a system-wide keystore which is used to store trusted certificates from a variety of Certificate Authorities (CA&apos;s). These CA certificates can be used to help make trust decisions. For example, in SSL/TLS when the SunJSSE provider is presented with certificates from a remote peer, the default trustmanager will consult the:</p>
<p>Solaris, Linux, or Mac OS X: &lt;java-home&gt;/lib/ext/cacerts
Windows: &lt;java-home&gt;\lib\ext\cacerts
file to determine if the connection is to be trusted. Instead of using the system-wide cacerts keystore, applications can set up and use their own keystores, or even use the user keystore described above.</p>
<p>Keystore Implementation</p>
<p>The KeyStore class supplies well-defined interfaces to access and modify the information in a keystore. It is possible for there to be multiple different concrete implementations, where each implementation is that for a particular type of keystore.</p>
<p>Currently, there are two command-line tools that make use of KeyStore: keytool and jarsigner, and also a GUI-based tool named policytool. It is also used by the Policy reference implementation when it processes policy files specifying the permissions (allowed accesses to system resources) to be granted to code from various sources. Since KeyStore is publicly available, JDK users can write additional security applications that use it.</p>
<p>Applications can choose different types of keystore implementations from different providers, using the getInstance factory method in the KeyStore class. A keystore type defines the storage and data format of the keystore information, and the algorithms used to protect private keys in the keystore and the integrity of the keystore itself. Keystore implementations of different types are not compatible.</p>
<p>There is a built-in default keystore implementation type known as &quot;jks&quot; that is provided by Sun Microsystems. It implements the keystore as a file, utilizing a proprietary keystore type (format). It protects each private key with its own individual password, and also protects the integrity of the entire keystore with a (possibly different) password. The default is specified by the following line in the security properties file:</p>
<pre><code>keystore.type=jks
</code></pre>
<p>To have tools and other applications use a different default keystore implementation, you can change that line to specify a default type. If you have a provider package that supplies a keystore implementation for a keystore type called &quot;jceks&quot;, change the line to:</p>
<pre><code>keystore.type=jceks
</code></pre>
<p>Some applications, such as keytool, also let you override the default keystore type (via the -storetype command-line parameter).</p>
<p>NOTE: Keystore type designations are case-insensitive. For example, &quot;jks&quot; would be considered the same as &quot;JKS&quot;.
There are three other types of keystores that come with the JDK implementation.</p>
<p>&quot;jceks&quot; is an alternate proprietary keystore format to &quot;jks&quot; that uses much stronger encryption in the form of Password-Based Encryption with Triple-DES.
The Sun &quot;jceks&quot; implementation can parse and convert a &quot;jks&quot; keystore file to the &quot;jceks&quot; format. You may upgrade your keystore of type &quot;jks&quot; to a keystore of type &quot;jceks&quot; by changing the password of a private-key entry in your keystore and specifying &quot;-storetype jceks&quot; as the keystore type. To apply the cryptographically strong(er) key protection supplied to a private key named &quot;signkey&quot; in your default keystore, use the following command, which will prompt you for the old and new key passwords:</p>
<pre><code>keytool -keypasswd -alias signkey -storetype jceks
</code></pre>
<p>See Security Tools for more information about keytool and about keystores and how they are managed.
NOTE: Keystore type designations are case-insensitive. For example, &quot;jceks&quot; would be considered the same as &quot;JCEKS&quot;.
&quot;pkcs12&quot; is another option. This is a cross platform keystore based on the RSA PKCS12 Personal Information Exchange Syntax Standard. This standard is primarily meant for storing or transporting a user&apos;s private keys, certificates, and miscellaneous secrets. As of JDK 8, arbitrary attributes can be associated with individual entries in a PKCS12 keystore.
&quot;dks&quot; is a domain keystore. It is a collection of keystores presented as a single logical keystore. The keystores that comprise a given domain are specified by configuration data whose syntax is described in DomainLoadStoreParameter.
Keystore implementations are provider-based. Developers interested in writing their own KeyStore implementations should consult How to Implement a Provider for the Java Cryptography Architecture for more information on this topic.</p>
<p>The KeyStore Class</p>
<p>The KeyStore class is an engine class that supplies well-defined interfaces to access and modify the information in a keystore.</p>
<p>The KeyStore Class
Description of Figure The KeyStore Class</p>
<p>This class represents an in-memory collection of keys and certificates. KeyStore manages two types of entries:</p>
<p>Key Entry
This type of keystore entry holds very sensitive cryptographic key information, which is stored in a protected format to prevent unauthorized access. Typically, a key stored in this type of entry is a secret key, or a private key accompanied by the certificate chain authenticating the corresponding public key.</p>
<p>Private keys and certificate chains are used by a given entity for self-authentication using digital signatures. For example, software distribution organizations digitally sign JAR files as part of releasing and/or licensing software.</p>
<p>Trusted Certificate Entry
This type of entry contains a single public key certificate belonging to another party. It is called a trusted certificate because the keystore owner trusts that the public key in the certificate indeed belongs to the identity identified by the subject (owner) of the certificate.</p>
<p>This type of entry can be used to authenticate other parties.</p>
<p>Each entry in a keystore is identified by an &quot;alias&quot; string. In the case of private keys and their associated certificate chains, these strings distinguish among the different ways in which the entity may authenticate itself. For example, the entity may authenticate itself using different certificate authorities, or using different public key algorithms.</p>
<p>Whether keystores are persistent, and the mechanisms used by the keystore if it is persistent, are not specified here. This convention allows use of a variety of techniques for protecting sensitive (e.g., private or secret) keys. Smart cards or other integrated cryptographic engines (SafeKeyper) are one option, and simpler mechanisms such as files may also be used (in a variety of formats).</p>
<p>The main KeyStore methods are described below.</p>
<p>Creating a KeyStore Object</p>
<p>KeyStore objects are obtained by using one of the KeyStore getInstance() static factory methods.</p>
<p>Loading a Particular Keystore into Memory</p>
<p>Before a KeyStore object can be used, the actual keystore data must be loaded into memory via the load method:</p>
<p>final void load(InputStream stream, char[] password)
The optional password is used to check the integrity of the keystore data. If no password is supplied, no integrity check is performed.</p>
<p>To create an empty keystore, you pass null as the InputStream argument to the load method.</p>
<p>A DKS keystore is loaded by passing a DomainLoadStoreParameter to the alternative load method:</p>
<p>final void load(KeyStore.LoadStoreParameter param)
Getting a List of the Keystore Aliases</p>
<p>All keystore entries are accessed via unique aliases. The aliases method returns an enumeration of the alias names in the keystore:</p>
<p>final Enumeration aliases()
Determining Keystore Entry Types</p>
<p>As stated in The KeyStore Class, there are two different types of entries in a keystore. The following methods determine whether the entry specified by the given alias is a key/certificate or a trusted certificate entry, respectively:</p>
<p>final boolean isKeyEntry(String alias)
final boolean isCertificateEntry(String alias)
Adding/Setting/Deleting Keystore Entries</p>
<p>The setCertificateEntry method assigns a certificate to a specified alias:</p>
<p>final void setCertificateEntry(String alias, Certificate cert)
If alias doesn&apos;t exist, a trusted certificate entry with that alias is created. If alias exists and identifies a trusted certificate entry, the certificate associated with it is replaced by cert.</p>
<p>The setKeyEntry methods add (if alias doesn&apos;t yet exist) or set key entries:</p>
<p>final void setKeyEntry(String alias,
Key key,
char[] password,
Certificate[] chain)</p>
<p>final void setKeyEntry(String alias,
byte[] key,
Certificate[] chain)
In the method with key as a byte array, it is the bytes for a key in protected format. For example, in the keystore implementation supplied by the SUN provider, the key byte array is expected to contain a protected private key, encoded as an EncryptedPrivateKeyInfo as defined in the PKCS8 standard. In the other method, the password is the password used to protect the key.</p>
<p>The deleteEntry method deletes an entry:</p>
<p>final void deleteEntry(String alias)
PKCS #12 keystores support entries containing arbitrary attributes. Use the java.security.PKCS12Attribute class to create the attributes. When creating the new keystore entry use a constructor method that accepts attributes. Finally, use the following method to add the entry to the keystore:</p>
<p>final void setEntry(String alias, Entry entry,
ProtectionParameter protParam)
Getting Information from the Keystore</p>
<p>The getKey method returns the key associated with the given alias. The key is recovered using the given password:</p>
<p>final Key getKey(String alias, char[] password)
The following methods return the certificate, or certificate chain, respectively, associated with the given alias:</p>
<p>final Certificate getCertificate(String alias)
final Certificate[] getCertificateChain(String alias)
You can determine the name (alias) of the first entry whose certificate matches a given certificate via the following:</p>
<p>final String getCertificateAlias(Certificate cert)
PKCS #12 keystores support entries containing arbitrary attributes. Use the following method to retrieve an entry that may contain attributes:</p>
<p>final Entry getEntry(String alias, ProtectionParameter protParam)
and then use the KeyStore.Entry.getAttributes method to extract such attributes and use the methods of the KeyStore.Entry.Attribute interface to examine them.</p>
<p>Saving the KeyStore</p>
<p>The in-memory keystore can be saved via the store method:</p>
<p>final void store(OutputStream stream, char[] password)
The password is used to calculate an integrity checksum of the keystore data, which is appended to the keystore data.</p>
<p>A DKS keystore is stored by passing a DomainLoadStoreParameter to the alternative store method:</p>
<p>final void store(KeyStore.LoadStoreParameter param)
Algorithm Parameters Classes
Like Keys and Keyspecs, an algorithm&apos;s initialization parameters are represented by either AlgorithmParameters or AlgorithmParameterSpecs. Depending on the use situation, algorithms can use the parameters directly, or the parameters might need to be converted into a more portable format for transmission or storage.</p>
<p>A transparent representation of a set of parameters (via AlgorithmParameterSpec) means that you can access each parameter value in the set individually. You can access these values through one of the get methods defined in the corresponding specification class (e.g., DSAParameterSpec defines getP, getQ, and getG methods, to access p, q, and g, respectively).</p>
<p>In contrast, the AlgorithmParameters class supplies an opaque representation, in which you have no direct access to the parameter fields. You can only get the name of the algorithm associated with the parameter set (via getAlgorithm) and some kind of encoding for the parameter set (via getEncoded).</p>
<p>The AlgorithmParameterSpec Interface</p>
<p>AlgorithmParameterSpec is an interface to a transparent specification of cryptographic parameters. This interface contains no methods or constants. Its only purpose is to group (and provide type safety for) all parameter specifications. All parameter specifications must implement this interface.</p>
<p>The algorithm parameter specification interfaces and classes in the java.security.spec and javax.crypto.spec packages are described in the JDK javadocs:</p>
<p>DHParameterSpec
DHGenParameterSpec
DSAParameterSpec
ECGenParameterSpec
ECParameterSpec
GCMParameterSpec
IvParameterSpec
MGF1ParameterSpec
OAEPParameterSpec
PBEParameterSpec
PSSParameterSpec
RC2ParameterSpec
RC5ParameterSpec
RSAKeyGenParameterSpec
The following algorithm parameter specs are used specifically for digital signatures, as part of JSR 105.</p>
<p>C14NMethodParameterSpec
DigestMethodParameterSpec
SignatureMethodParameterSpec
TransformParameterSpec
ExcC14NParameterSpec
HMACParameterSpec
XPathFilter2ParameterSpec
XPathFilterParameterSpec
XSLTTransformParameterSpec
The AlgorithmParameters Class</p>
<p>The AlgorithmParameters class is an engine class that provides an opaque representation of cryptographic parameters. You can initialize the AlgorithmParameters class using a specific AlgorithmParameterSpec object, or by encoding the parameters in a recognized format. You can retrieve the resulting specification with the getParameterSpec method (see the following section).</p>
<p>Creating an AlgorithmParameters Object</p>
<p>AlgorithmParameters objects are obtained by using one of the AlgorithmParameters getInstance() static factory methods.</p>
<p>Initializing an AlgorithmParameters Object</p>
<p>Once an AlgorithmParameters object is instantiated, it must be initialized via a call to init, using an appropriate parameter specification or parameter encoding:</p>
<p>void init(AlgorithmParameterSpec paramSpec)
void init(byte[] params)
void init(byte[] params, String format)
In these init methods, params is an array containing the encoded parameters, and format is the name of the decoding format. In the init method with a params argument but no format argument, the primary decoding format for parameters is used. The primary decoding format is ASN.1, if an ASN.1 specification for the parameters exists.</p>
<p>NOTE: AlgorithmParameters objects can be initialized only once. They are not reusable.
Obtaining the Encoded Parameters</p>
<p>A byte encoding of the parameters represented in an AlgorithmParameters object may be obtained via a call to getEncoded:</p>
<p>byte[] getEncoded()
This method returns the parameters in their primary encoding format. The primary encoding format for parameters is ASN.1, if an ASN.1 specification for this type of parameters exists.</p>
<p>If you want the parameters returned in a specified encoding format, use</p>
<p>byte[] getEncoded(String format)
If format is null, the primary encoding format for parameters is used, as in the other getEncoded method.
NOTE: In the default AlgorithmParameters implementation, supplied by the SUN provider, the format argument is currently ignored.
Converting an AlgorithmParameters Object to a Transparent Specification</p>
<p>A transparent parameter specification for the algorithm parameters may be obtained from an AlgorithmParameters object via a call to getParameterSpec:</p>
<p>AlgorithmParameterSpec getParameterSpec(Class paramSpec)
paramSpec identifies the specification class in which the parameters should be returned. The specification class could be, for example, DSAParameterSpec.class to indicate that the parameters should be returned in an instance of the DSAParameterSpec class. (This class is in the java.security.spec package.)</p>
<p>The AlgorithmParameterGenerator Class</p>
<p>The AlgorithmParameterGenerator class is an engine class used to generate a set of brand-new parameters suitable for a certain algorithm (the algorithm is specified when an AlgorithmParameterGenerator instance is created). This object is used when you do not have an existing set of algorithm parameters, and want to generate one from scratch.</p>
<p>Creating an AlgorithmParameterGenerator Object</p>
<p>AlgorithmParameterGenerator objects are obtained by using one of the AlgorithmParameterGenerator getInstance() static factory methods.</p>
<p>Initializing an AlgorithmParameterGenerator Object</p>
<p>The AlgorithmParameterGenerator object can be initialized in two different ways: an algorithm-independent manner or an algorithm-specific manner.</p>
<p>The algorithm-independent approach uses the fact that all parameter generators share the concept of a &quot;size&quot; and a source of randomness. The measure of size is universally shared by all algorithm parameters, though it is interpreted differently for different algorithms. For example, in the case of parameters for the DSA algorithm, &quot;size&quot; corresponds to the size of the prime modulus, in bits. (See the Standard Names document for information about the sizes for specific algorithms.) When using this approach, algorithm-specific parameter generation values--if any--default to some standard values. One init method that takes these two universally shared types of arguments:</p>
<p>void init(int size, SecureRandom random);
Another init method takes only a size argument and uses a system-provided source of randomness:</p>
<p>void init(int size)
A third approach initializes a parameter generator object using algorithm-specific semantics, which are represented by a set of algorithm-specific parameter generation values supplied in an AlgorithmParameterSpec object:</p>
<p>void init(AlgorithmParameterSpec genParamSpec,
SecureRandom random)</p>
<p>void init(AlgorithmParameterSpec genParamSpec)
To generate Diffie-Hellman system parameters, for example, the parameter generation values usually consist of the size of the prime modulus and the size of the random exponent, both specified in number of bits.</p>
<p>Generating Algorithm Parameters</p>
<p>Once you have created and initialized an AlgorithmParameterGenerator object, you can use the generateParameters method to generate the algorithm parameters:</p>
<p>AlgorithmParameters generateParameters()
The CertificateFactory Class
The CertificateFactory class is an engine class that defines the functionality of a certificate factory, which is used to generate certificate and certificate revocation list (CRL) objects from their encodings.</p>
<p>A certificate factory for X.509 must return certificates that are an instance of java.security.cert.X509Certificate, and CRLs that are an instance of java.security.cert.X509CRL.</p>
<p>Creating a CertificateFactory Object</p>
<p>CertificateFactory objects are obtained by using one of the getInstance() static factory methods.</p>
<p>Generating Certificate Objects</p>
<p>To generate a certificate object and initialize it with the data read from an input stream, use the generateCertificate method:</p>
<p>final Certificate generateCertificate(InputStream inStream)
To return a (possibly empty) collection view of the certificates read from a given input stream, use the generateCertificates method:</p>
<p>final Collection generateCertificates(InputStream inStream)
Generating CRL Objects</p>
<p>To generate a certificate revocation list (CRL) object and initialize it with the data read from an input stream, use the generateCRL method:</p>
<p>final CRL generateCRL(InputStream inStream)
To return a (possibly empty) collection view of the CRLs read from a given input stream, use the generateCRLs method:
final Collection generateCRLs(InputStream inStream)
Generating CertPath Objects</p>
<p>The certificate path builder and validator for PKIX is defined by the Internet X.509 Public Key Infrastructure Certificate and CRL Profile, RFC 3280.</p>
<p>A certificate store implementation for retrieving certificates and CRLs from Collection and LDAP directories, using the PKIX LDAP V2 Schema is also available from the IETF as RFC 2587.</p>
<p>To generate a CertPath object and initialize it with data read from an input stream, use one of the following generateCertPath methods (with or without specifying the encoding to be used for the data):</p>
<p>final CertPath generateCertPath(InputStream inStream)</p>
<p>final CertPath generateCertPath(InputStream inStream,
String encoding)
To generate a CertPath object and initialize it with a list of certificates, use the following method:</p>
<p>final CertPath generateCertPath(List certificates)
To retrieve a list of the CertPath encodings supported by this certificate factory, you can call the getCertPathEncodings method:</p>
<p>final Iterator getCertPathEncodings()
The default encoding will be listed first.
How the JCA Might Be Used in a SSL/TLS Implementation
With an understanding of the JCA classes, consider how these classes might be combined to implement an advanced network protocol like SSL/TLS. The SSL/TLS Overview section in the JSSE Reference Guide describes at a high level how the protocols work. As asymmetric (public key) cipher operations are much slower than symmetric operations (secret key), public key cryptography is used to establish secret keys which are then used to protect the actual application data. Vastly simplified, the SSL/TLS handshake involves exchanging initialization data, performing some public key operations to arrive at a secret key, and then using that key to encrypt further traffic.</p>
<p>NOTE: The details presented here simply show how some of the above classes might be employed. This section will not present sufficient information for building a SSL/TLS implementation. For more details, please see the JSSE Reference Guide and RFC 2246: The TLS Protocol.
Assume that this SSL/TLS implementation will be made available as a JSSE provider. A concrete implementation of the Provider class is first written that will eventually be registered in the Security class&apos; list of providers. This provider mainly provides a mapping from algorithm names to actual implementation classes. (that is: &quot;SSLContext.TLS&quot;-&gt;&quot;com.foo.TLSImpl&quot;) When an application requests an &quot;TLS&quot; instance (via SSLContext.getInstance(&quot;TLS&quot;), the provider&apos;s list is consulted for the requested algorithm, and an appropriate instance is created.</p>
<p>Before discussing details of the actual handshake, a quick review of some of the JSSE&apos;s architecture is needed. The heart of the JSSE architecture is the SSLContext. The context eventually creates end objects (SSLSocket and SSLEngine) which actually implement the SSL/TLS protocol. SSLContexts are initialized with two callback classes, KeyManager and TrustManager, which allow applications to first select authentication material to send and second to verify credentials sent by a peer.</p>
<p>A JSSE KeyManager is responsible for choosing which credentials to present to a peer. Many algorithms are possible, but a common strategy is to maintain a RSA or DSA public/private key pair along with a X509Certificate in a KeyStore backed by a disk file. When a KeyStore object is initialized and loaded from the file, the file&apos;s raw bytes are converted into PublicKey and PrivateKey objects using a KeyFactory, and a certificate chain&apos;s bytes are converted using a CertificateFactory. When a credential is needed, the KeyManager simply consults this KeyStore object and determines which credentials to present.</p>
<p>A KeyStore&apos;s contents might have originally been created using a utility such as keytool. keytool creates a RSA or DSA KeyPairGenerator and initializes it with an appropriate keysize. This generator is then used to create a KeyPair which keytool would store along with the newly-created certificate in the KeyStore, which is eventually written to disk.</p>
<p>A JSSE TrustManager is responsible for verifying the credentials received from a peer. There are many ways to verify credentials: one of them is to create a CertPath object, and let the JDK&apos;s built-in Public Key Infrastructure (PKI) framework handle the validation. Internally, the CertPath implementation might create a Signature object, and use that to verify that the each of the signatures in the certificate chain.</p>
<p>With this basic understanding of the architecture, we can look at some of the steps in the SSL/TLS handshake. The client begins by sending a ClientHello message to the server. The server selects a ciphersuite to use, and sends that back in a ServerHello message, and begins creating JCA objects based on the suite selection. We&apos;ll use server-only authentication in the following examples.</p>
<p>SSL Messages
Description of Figure SSL Messages</p>
<p>In the first example, the server tries to use a RSA-based ciphersuite such as TLS_RSA_WITH_AES_128_CBC_SHA. The server&apos;s KeyManager is queried, and returns an appropriate RSA entry. The server&apos;s credentials (that is: certificate/public key) are sent in the server&apos;s Certificate message. The client&apos;s TrustManager verifies the server&apos;s certificate, and if accepted, the client generates some random bytes using a SecureRandom object. This is then encrypted using an encrypting asymmetric RSA Cipher object that has been initialized with the PublicKey found in the server&apos;s certificate. This encrypted data is sent in a Client Key Exchange message. The server would use its corresponding PrivateKey to recover the bytes using a similar Cipher in decrypt mode. These bytes are then used to establish the actual encryption keys.</p>
<p>In a different example, an ephemeral Diffie-Hellman key agreement algorithm along with the DSA signature algorithm is chosen, such as TLS_DHE_DSS_WITH_AES_128_CBC_SHA. The two sides must each establish a new temporary DH public/private keypair using a KeyPairGenerator. Each generator creates DH keys which can then be further converted into pieces using the KeyFactory and DHPublicKeySpec classes. Each side then creates a KeyAgreement object and initializes it with their respective DH PrivateKeys. The server sends its public key pieces in a ServerKeyExchange message (protected by the DSA signature algorithm, and the client sends its public key in a ClientKeyExchange message. When the public keys are reassembled using another KeyFactory, they are fed into the agreement objects. The KeyAgreement objects then generate agreed-upon bytes that are then used to establish the actual encryption keys.</p>
<p>Once the actual encryption keys have been established, the secret key is used to initialize a symmetric Cipher object, and this cipher is used to protect all data in transit. To help determine if the data has been modified, a MessageDigest is created and receives a copy of the data destined for the network. When the packet is complete, the digest (hash) is appended to data, and the entire packet is encrypted by the Cipher. If a block cipher such as AES is used, the data must be padded to make a complete block. On the remote side, the steps are simply reversed.</p>
<p>Again, this is vastly simplified, but gives one an idea of how these classes might be combined to create a higher level protocol.</p>
<p>How to Make Applications &quot;Exempt&quot; from Cryptographic Restrictions
Note 1: This section should be ignored by most application developers. It is only for people whose applications may be exported to those few countries whose governments mandate cryptographic restrictions, if it is desired that such applications have fewer cryptographic restrictions than those mandated. Note 2: Throughout this section, the term &quot;application&quot; is meant to encompass both applications and applets.]
The JCA framework includes an ability to enforce restrictions regarding the cryptographic algorithms and maximum cryptographic strengths available to applets/applications in different jurisdiction contexts (locations). Any such restrictions are specified in &quot;jurisdiction policy files&quot;.</p>
<p>Due to import control restrictions by the governments of a few countries, the jurisdiction policy files shipped with the Java SE Development Kit 6 specify that &quot;strong&quot; but limited cryptography may be used. An &quot;unlimited strength&quot; version of these files indicating no restrictions on cryptographic strengths is available for those living in eligible countries (which is most countries). But only the &quot;strong&quot; version can be imported into those countries whose governments mandate restrictions. The JCA framework will enforce the restrictions specified in the installed jurisdiction policy files.</p>
<p>It is possible that the governments of some or all such countries may allow certain applications to become exempt from some or all cryptographic restrictions. For example, they may consider certain types of applications as &quot;special&quot; and thus exempt. Or they may exempt any application that utilizes an &quot;exemption mechanism,&quot; such as key recovery. Applications deemed to be exempt could get access to stronger cryptography than that allowed for non-exempt applications in such countries.</p>
<p>In order for an application to be recognized as &quot;exempt&quot; at runtime, it must meet the following conditions:</p>
<p>It must have a permission policy file bundled with it in a JAR file. The permission policy file specifies what cryptography-related permissions the application has, and under what conditions (if any).
The JAR file containing the application and the permission policy file must have been signed using a code-signing certificate issued after the application was accepted as exempt.
Below are sample steps required in order to make an application exempt from some or all cryptographic restrictions. This is a basic outline that includes information about what is required by JCA in order to recognize and treat applications as being exempt. You will need to know the exemption requirements of the particular country or countries in which you would like your application to be able to be run but whose governments require cryptographic restrictions. You will also need to know the requirements of a JCA framework vendor that has a process in place for handling exempt applications. Consult such a vendor for further information. (NOTE: The SunJCE provider does not supply an implementation of the ExemptionMechanismSpi class.)</p>
<p>Step 1: Write and Compile Your Application Code
Step 2: Create a Permission Policy File Granting Appropriate Cryptographic Permissions
Step 3: Prepare for Testing
Step 3a: Apply for Government Approval From the Government Mandating Restrictions.
Step 3b: Get a Code-Signing Certificate
Step 3c: Bundle the Application and Permission Policy File into a JAR file
Step 3d: Sign the JAR file
Step 3e: Set Up Your Environment Like That of a User in a Restricted Country
Step 3f: (only for applications using exemption mechanisms) Install a Provider Implementing the Exemption Mechanism Specified by the entry in the Permission Policy File
Step 4: Test Your Application
Step 5: Apply for U.S. Government Export Approval If Required
Step 6: Deploy Your Application</p>
<p>Special Code Requirements for Applications that Use Exemption Mechanisms
When an application has a permission policy file associated with it (in the same JAR file) and that permission policy file specifies an exemption mechanism, then when the Cipher getInstance method is called to instantiate a Cipher, the JCA code searches the installed providers for one that implements the specified exemption mechanism. If it finds such a provider, JCA instantiates an ExemptionMechanism API object associated with the provider&apos;s implementation, and then associates the ExemptionMechanism object with the Cipher returned by getInstance.</p>
<p>After instantiating a Cipher, and prior to initializing it (via a call to the Cipher init method), your code must call the following Cipher method:</p>
<pre><code>public ExemptionMechanism getExemptionMechanism()
</code></pre>
<p>This call returns the ExemptionMechanism object associated with the Cipher. You must then initialize the exemption mechanism implementation by calling the following method on the returned ExemptionMechanism:</p>
<pre><code>public final void init(Key key)
</code></pre>
<p>The argument you supply should be the same as the argument of the same types that you will subsequently supply to a Cipher init method.</p>
<p>Once you have initialized the ExemptionMechanism, you can proceed as usual to initialize and use the Cipher.</p>
<p>Permission Policy Files
In order for an application to be recognized at runtime as being &quot;exempt&quot; from some or all cryptographic restrictions, it must have a permission policy file bundled with it in a JAR file. The permission policy file specifies what cryptography-related permissions the application has, and under what conditions (if any).</p>
<p>NOTE: The permission policy file bundled with an application must be named cryptoPerms.
The format of a permission entry in a permission policy file that accompanies an exempt application is the same as the format for a jurisdiction policy file downloaded with the JDK, which is:</p>
<pre><code>permission &lt;crypto permission class name&gt;[ &lt;alg_name&gt;
    [[, &lt;exemption mechanism name&gt;][, &lt;maxKeySize&gt;
    [, &lt;AlgorithmParameterSpec class name&gt;,
    &lt;parameters for constructing an AlgorithmParameterSpec object&gt;
    ]]]];
</code></pre>
<p>See Appendix B for more information about the jurisdiction policy file format.</p>
<p>Permission Policy Files for Exempt Applications</p>
<p>Some applications may be allowed to be completely unrestricted. Thus, the permission policy file that accompanies such an application usually just needs to contain the following:</p>
<pre><code>grant {
    // There are no restrictions to any algorithms.
    permission javax.crypto.CryptoAllPermission;
};
</code></pre>
<p>If an application just uses a single algorithm (or several specific algorithms), then the permission policy file could simply mention that algorithm (or algorithms) explicitly, rather than granting CryptoAllPermission. For example, if an application just uses the Blowfish algorithm, the permission policy file doesn&apos;t have to grant CryptoAllPermission to all algorithms. It could just specify that there is no cryptographic restriction if the Blowfish algorithm is used. In order to do this, the permission policy file would look like the following:</p>
<pre><code>grant {
    permission javax.crypto.CryptoPermission &quot;Blowfish&quot;;
};
</code></pre>
<p>Permission Policy Files for Applications Exempt Due to Exemption Mechanisms</p>
<p>If an application is considered &quot;exempt&quot; if an exemption mechanism is enforced, then the permission policy file that accompanies the application must specify one or more exemption mechanisms. At runtime, the application will be considered exempt if any of those exemption mechanisms is enforced. Each exemption mechanism must be specified in a permission entry that looks like the following:</p>
<pre><code>// No algorithm restrictions if specified
// exemption mechanism is enforced.
permission javax.crypto.CryptoPermission *,
    &quot;&lt;ExemptionMechanismName&gt;&quot;;
</code></pre>
<p>where &lt;ExemptionMechanismName&gt; specifies the name of an exemption mechanism. The list of possible exemption mechanism names includes:</p>
<p>KeyRecovery
KeyEscrow
KeyWeakening
As an example, suppose your application is exempt if either key recovery or key escrow is enforced. Then your permission policy file should contain the following:
grant {
// No algorithm restrictions if KeyRecovery is enforced.
permission javax.crypto.CryptoPermission *,
&quot;KeyRecovery&quot;;
// No algorithm restrictions if KeyEscrow is enforced.
permission javax.crypto.CryptoPermission *,
&quot;KeyEscrow&quot;;
};
NOTE: Permission entries that specify exemption mechanisms should not also specify maximum key sizes. The allowed key sizes are actually determined from the installed exempt jurisdiction policy files, as described in the next section.</p>
<p>How Bundled Permission Policy Files Affect Cryptographic Permissions</p>
<p>At runtime, when an application instantiates a Cipher (via a call to its getInstance method) and that application has an associated permission policy file, JCA checks to see whether the permission policy file has an entry that applies to the algorithm specified in the getInstance call. If it does, and the entry grants CryptoAllPermission or does not specify that an exemption mechanism must be enforced, it means there is no cryptographic restriction for this particular algorithm.</p>
<p>If the permission policy file has an entry that applies to the algorithm specified in the getInstance call and the entry does specify that an exemption mechanism must be enforced, then the exempt jurisdiction policy file(s) are examined. If the exempt permissions include an entry for the relevant algorithm and exemption mechanism, and that entry is implied by the permissions in the permission policy file bundled with the application, and if there is an implementation of the specified exemption mechanism available from one of the registered providers, then the maximum key size and algorithm parameter values for the Cipher are determined from the exempt permission entry.</p>
<p>If there is no exempt permission entry implied by the relevant entry in the permission policy file bundled with the application, or if there is no implementation of the specified exemption mechanism available from any of the registered providers, then the application is only allowed the standard default cryptographic permissions.</p>
<p>Code Examples
Here are some short examples which illustrate use of several of the JCA mechanisms. In addition, complete working examples can be found in Appendix D.</p>
<p>Computing a MessageDigest Object
First create the message digest object, as in the following example:</p>
<p>MessageDigest sha = MessageDigest.getInstance(&quot;SHA-1&quot;);
This call assigns a properly initialized message digest object to the sha variable. The implementation implements the Secure Hash Algorithm (SHA-1), as defined in the National Institute for Standards and Technology&apos;s (NIST) FIPS 180-2 document. See Appendix A for a complete discussion of standard names and algorithms.
Next, suppose we have three byte arrays, i1, i2 and i3, which form the total input whose message digest we want to compute. This digest (or &quot;hash&quot;) could be calculated via the following calls:</p>
<p>sha.update(i1);
sha.update(i2);
sha.update(i3);
byte[] hash = sha.digest();
An equivalent alternative series of calls would be:</p>
<p>sha.update(i1);
sha.update(i2);
byte[] hash = sha.digest(i3);
After the message digest has been calculated, the message digest object is automatically reset and ready to receive new data and calculate its digest. All former state (i.e., the data supplied to update calls) is lost.
Some hash implementations may support intermediate hashes through cloning. Suppose we want to calculate separate hashes for:</p>
<p>i1
i1 and i2
i1, i2, and i3
A way to do it is:</p>
<p>/* compute the hash for i1 */
sha.update(i1);
byte[] i1Hash = sha.clone().digest();</p>
<p>/* compute the hash for i1 and i2 */
sha.update(i2);
byte[] i12Hash = sha.clone().digest();</p>
<p>/* compute the hash for i1, i2 and i3 <em>/
sha.update(i3);
byte[] i123hash = sha.digest();
This code works only if the SHA-1 implementation is cloneable. While some implementations of message digests are cloneable, others are not. To determine whether or not cloning is possible, attempt to clone the MessageDigest object and catch the potential exception as follows:
try {
// try and clone it
/</em> compute the hash for i1 */
sha.update(i1);
byte[] i1Hash = sha.clone().digest();
// ...
byte[] i123hash = sha.digest();
} catch (CloneNotSupportedException cnse) {
// do something else, such as the code shown below
}
If a message digest is not cloneable, the other, less elegant way to compute intermediate digests is to create several digests. In this case, the number of intermediate digests to be computed must be known in advance:
MessageDigest sha1 = MessageDigest.getInstance(&quot;SHA-1&quot;);
MessageDigest sha12 = MessageDigest.getInstance(&quot;SHA-1&quot;);
MessageDigest sha123 = MessageDigest.getInstance(&quot;SHA-1&quot;);</p>
<p>byte[] i1Hash = sha1.digest(i1);</p>
<p>sha12.update(i1);
byte[] i12Hash = sha12.digest(i2);</p>
<p>sha123.update(i1);
sha123.update(i2);
byte[] i123Hash = sha123.digest(i3);
Generating a Pair of Keys
In this example we will generate a public-private key pair for the algorithm named &quot;DSA&quot; (Digital Signature Algorithm), and use this keypair in future examples. We will generate keys with a 1024-bit modulus. We don&apos;t care which provider supplies the algorithm implementation.</p>
<p>Creating the Key Pair Generator</p>
<p>The first step is to get a key pair generator object for generating keys for the DSA algorithm:</p>
<p>KeyPairGenerator keyGen = KeyPairGenerator.getInstance(&quot;DSA&quot;);
Initializing the Key Pair Generator</p>
<p>The next step is to initialize the key pair generator. In most cases, algorithm-independent initialization is sufficient, but in some cases, algorithm-specific initialization is used.</p>
<p>Algorithm-Independent Initialization
All key pair generators share the concepts of a keysize and a source of randomness. The KeyPairGenerator class initialization methods at a minimum needs a keysize. If the source of randomness is not explicitly provided, a SecureRandom implementation of the highest-priority installed provider will be used. Thus to generate keys with a keysize of 1024, simply call:</p>
<p>SecureRandom random = SecureRandom.getInstance(&quot;SHA1PRNG&quot;, &quot;SUN&quot;);
keyGen.initialize(1024, random);
The following code illustrates how to use a specific, additionally seeded SecureRandom object:
SecureRandom random = SecureRandom.getInstance(&quot;SHA1PRNG&quot;, &quot;SUN&quot;);
random.setSeed(userSeed);
keyGen.initialize(1024, random);
Since no other parameters are specified when you call the above algorithm-independent initialize method, it is up to the provider what to do about the algorithm-specific parameters (if any) to be associated with each of the keys. The provider may use precomputed parameter values or may generate new values.
Algorithm-Specific Initialization
For situations where a set of algorithm-specific parameters already exists (such as &quot;community parameters&quot; in DSA), there are two initialize methods that have an AlgorithmParameterSpec argument. Suppose your key pair generator is for the &quot;DSA&quot; algorithm, and you have a set of DSA-specific parameters, p, q, and g, that you would like to use to generate your key pair. You could execute the following code to initialize your key pair generator (recall that DSAParameterSpec is an AlgorithmParameterSpec):</p>
<p>DSAParameterSpec dsaSpec = new DSAParameterSpec(p, q, g);
SecureRandom random = SecureRandom.getInstance(&quot;SHA1PRNG&quot;, &quot;SUN&quot;);
random.setSeed(userSeed);
keyGen.initialize(dsaSpec, random);
NOTE: The parameter named p is a prime number whose length is the modulus length (&quot;size&quot;). Therefore, you don&apos;t need to call any other method to specify the modulus length.
Generating the Pair of Keys</p>
<p>The final step is actually generating the key pair. No matter which type of initialization was used (algorithm-independent or algorithm-specific), the same code is used to generate the key pair:</p>
<p>KeyPair pair = keyGen.generateKeyPair();
Generating and Verifying a Signature Using Generated Keys</p>
<p>The following signature generation and verification examples use the KeyPair generated in the key pair example above.</p>
<p>Generating a Signature
We first create a signature object:</p>
<p>Signature dsa = Signature.getInstance(&quot;SHA1withDSA&quot;);
Next, using the key pair generated in the key pair example, we initialize the object with the private key, then sign a byte array called data.</p>
<p>/* Initializing the object with a private key */
PrivateKey priv = pair.getPrivate();
dsa.initSign(priv);</p>
<p>/* Update and sign the data */
dsa.update(data);
byte[] sig = dsa.sign();
Verifying a Signature
Verifying the signature is straightforward. (Note that here we also use the key pair generated in the key pair example.)</p>
<p>/* Initializing the object with the public key */
PublicKey pub = pair.getPublic();
dsa.initVerify(pub);</p>
<p>/* Update and verify the data */
dsa.update(data);
boolean verifies = dsa.verify(sig);
System.out.println(&quot;signature verifies: &quot; + verifies);
Generating/Verifying Signatures Using Key Specifications and KeyFactory</p>
<p>Suppose that, rather than having a public/private key pair (as, for example, was generated in the key pair example above), you simply have the components of your DSA private key: x (the private key), p (the prime), q (the sub-prime), and g (the base).</p>
<p>Further suppose you want to use your private key to digitally sign some data, which is in a byte array named someData. You would do the following steps, which also illustrate creating a key specification and using a key factory to obtain a PrivateKey from the key specification (initSign requires a PrivateKey):</p>
<p>DSAPrivateKeySpec dsaPrivKeySpec = new DSAPrivateKeySpec(x, p, q, g);</p>
<p>KeyFactory keyFactory = KeyFactory.getInstance(&quot;DSA&quot;);
PrivateKey privKey = keyFactory.generatePrivate(dsaPrivKeySpec);</p>
<p>Signature sig = Signature.getInstance(&quot;SHA1withDSA&quot;);
sig.initSign(privKey);
sig.update(someData);
byte[] signature = sig.sign();
Suppose Alice wants to use the data you signed. In order for her to do so, and to verify your signature, you need to send her three things:</p>
<p>the data,
the signature, and
the public key corresponding to the private key you used to sign the data.
You can store the someData bytes in one file, and the signature bytes in another, and send those to Alice.</p>
<p>For the public key, assume, as in the signing example above, you have the components of the DSA public key corresponding to the DSA private key used to sign the data. Then you can create a DSAPublicKeySpec from those components:</p>
<p>DSAPublicKeySpec dsaPubKeySpec = new DSAPublicKeySpec(y, p, q, g);
You still need to extract the key bytes so that you can put them in a file. To do so, you can first call the generatePublic method on the DSA key factory already created in the example above:</p>
<p>PublicKey pubKey = keyFactory.generatePublic(dsaPubKeySpec);
Then you can extract the (encoded) key bytes via the following:
byte[] encKey = pubKey.getEncoded();
You can now store these bytes in a file, and send it to Alice along with the files containing the data and the signature.</p>
<p>Now, assume Alice has received these files, and she copied the data bytes from the data file to a byte array named data, the signature bytes from the signature file to a byte array named signature, and the encoded public key bytes from the public key file to a byte array named encodedPubKey.</p>
<p>Alice can now execute the following code to verify the signature. The code also illustrates how to use a key factory in order to instantiate a DSA public key from its encoding (initVerify requires a PublicKey).</p>
<pre><code>X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(encodedPubKey);

KeyFactory keyFactory = KeyFactory.getInstance(&quot;DSA&quot;);
PublicKey pubKey = keyFactory.generatePublic(pubKeySpec);

Signature sig = Signature.getInstance(&quot;SHA1withDSA&quot;);
sig.initVerify(pubKey);
sig.update(data);
sig.verify(signature);
</code></pre>
<p>NOTE: In the above, Alice needed to generate a PublicKey from the encoded key bits, since initVerify requires a PublicKey. Once she has a PublicKey, she could also use the KeyFactory getKeySpec method to convert it to a DSAPublicKeySpec so that she can access the components, if desired, as in:
DSAPublicKeySpec dsaPubKeySpec =
(DSAPublicKeySpec)keyFactory.getKeySpec(pubKey,
DSAPublicKeySpec.class)
Now she can access the DSA public key components y, p, q, and g through the corresponding &quot;get&quot; methods on the DSAPublicKeySpec class (getY, getP, getQ, and getG).</p>
<p>Determining If Two Keys Are Equal</p>
<p>In many cases you would like to know if two keys are equal; however, the default method java.lang.Object.equals may not give the desired result. The most provider-independent approach is to compare the encoded keys. If this comparison isn&apos;t appropriate (for example, when comparing an RSAPrivateKey and an RSAPrivateCrtKey), you should compare each component. The following code demonstrates this idea:</p>
<p>static boolean keysEqual(Key key1, Key key2) {
if (key1.equals(key2)) {
return true;
}</p>
<pre><code>if (Arrays.equals(key1.getEncoded(), key2.getEncoded())) {
    return true;
}

// More code for different types of keys here.
// For example, the following code can check if
// an RSAPrivateKey and an RSAPrivateCrtKey are equal:
// if ((key1 instanceof RSAPrivateKey) &amp;&amp;
//     (key2 instanceof RSAPrivateKey)) {
//     if ((key1.getModulus().equals(key2.getModulus())) &amp;&amp;
//         (key1.getPrivateExponent().equals(
//                                      key2.getPrivateExponent()))) {
//         return true;
//     }
// }

return false;
</code></pre>
<p>}
Reading Base64-Encoded Certificates</p>
<p>The following example reads a file with Base64-encoded certificates, which are each bounded at the beginning by</p>
<p>-----BEGIN CERTIFICATE-----
and at the end by
-----END CERTIFICATE-----
We convert the FileInputStream (which does not support mark and reset) to a ByteArrayInputStream (which supports those methods), so that each call to generateCertificate consumes only one certificate, and the read position of the input stream is positioned to the next certificate in the file:
FileInputStream fis = new FileInputStream(filename);
BufferedInputStream bis = new BufferedInputStream(fis);</p>
<p>CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);</p>
<p>while (bis.available() &gt; 0) {
Certificate cert = cf.generateCertificate(bis);
System.out.println(cert.toString());
}
Parsing a Certificate Reply</p>
<p>The following example parses a PKCS7-formatted certificate reply stored in a file and extracts all the certificates from it:</p>
<p>FileInputStream fis = new FileInputStream(filename);
CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);
Collection c = cf.generateCertificates(fis);
Iterator i = c.iterator();
while (i.hasNext()) {
Certificate cert = (Certificate)i.next();
System.out.println(cert);
}
Using Encryption</p>
<p>This section takes the user through the process of generating a key, creating and initializing a cipher object, encrypting a file, and then decrypting it. Throughout this example, we use the Advanced Encryption Standard (AES).</p>
<p>Generating a Key
To create an AES key, we have to instantiate a KeyGenerator for AES. We do not specify a provider, because we do not care about a particular AES key generation implementation. Since we do not initialize the KeyGenerator, a system-provided source of randomness and a default keysize will be used to create the AES key:</p>
<pre><code>KeyGenerator keygen = KeyGenerator.getInstance(&quot;AES&quot;);
SecretKey aesKey = keygen.generateKey();
</code></pre>
<p>After the key has been generated, the same KeyGenerator object can be re-used to create further keys.</p>
<p>Creating a Cipher
The next step is to create a Cipher instance. To do this, we use one of the getInstance factory methods of the Cipher class. We must specify the name of the requested transformation, which includes the following components, separated by slashes (/):</p>
<p>the algorithm name
the mode (optional)
the padding scheme (optional)
In this example, we create an AES cipher in Electronic Codebook mode, with PKCS5-style padding. We do not specify a provider, because we do not care about a particular implementation of the requested transformation.</p>
<p>The standard algorithm name for AES is &quot;AES&quot;, the standard name for the Electronic Codebook mode is &quot;ECB&quot;, and the standard name for PKCS5-style padding is &quot;PKCS5Padding&quot;:</p>
<pre><code>Cipher aesCipher;

// Create the cipher
aesCipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);
</code></pre>
<p>We use the generated aesKey from above to initialize the Cipher object for encryption:</p>
<pre><code>// Initialize the cipher for encryption
aesCipher.init(Cipher.ENCRYPT_MODE, aesKey);

// Our cleartext
byte[] cleartext = &quot;This is just an example&quot;.getBytes();

// Encrypt the cleartext
byte[] ciphertext = aesCipher.doFinal(cleartext);

// Initialize the same cipher for decryption
aesCipher.init(Cipher.DECRYPT_MODE, aesKey);

// Decrypt the ciphertext
byte[] cleartext1 = aesCipher.doFinal(ciphertext);
</code></pre>
<p>cleartext and cleartext1 are identical.</p>
<p>Using Password-Based Encryption</p>
<p>In this example, we prompt the user for a password from which we derive an encryption key.</p>
<p>It would seem logical to collect and store the password in an object of type java.lang.String. However, here&apos;s the caveat: Objects of type String are immutable, i.e., there are no methods defined that allow you to change (overwrite) or zero out the contents of a String after usage. This feature makes String objects unsuitable for storing security sensitive information such as user passwords. You should always collect and store security sensitive information in a char array instead.</p>
<p>For that reason, the javax.crypto.spec.PBEKeySpec class takes (and returns) a password as a char array. See the ReadPassword class in the sample code in Appendix D for one possible way of reading character array passwords from an input stream.</p>
<p>In order to use Password-Based Encryption (PBE) as defined in PKCS5, we have to specify a salt and an iteration count. The same salt and iteration count that are used for encryption must be used for decryption. Newer PBE algorithms use an iteration count of atleast 1000.
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">PBEKeySpec pbeKeySpec;</span><br><span class="line">PBEParameterSpec pbeParamSpec;</span><br><span class="line">SecretKeyFactory keyFac;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Salt</span></span><br><span class="line"><span class="keyword">byte</span>[] salt = {</span><br><span class="line">    (<span class="keyword">byte</span>)<span class="number">0xc7</span>, (<span class="keyword">byte</span>)<span class="number">0x73</span>, (<span class="keyword">byte</span>)<span class="number">0x21</span>, (<span class="keyword">byte</span>)<span class="number">0x8c</span>,</span><br><span class="line">    (<span class="keyword">byte</span>)<span class="number">0x7e</span>, (<span class="keyword">byte</span>)<span class="number">0xc8</span>, (<span class="keyword">byte</span>)<span class="number">0xee</span>, (<span class="keyword">byte</span>)<span class="number">0x99</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iteration count</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create PBE parameter set</span></span><br><span class="line">pbeParamSpec = <span class="keyword">new</span> PBEParameterSpec(salt, count);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prompt user for encryption password.</span></span><br><span class="line"><span class="comment">// Collect user password as char array (using the</span></span><br><span class="line"><span class="comment">// &quot;readPassword&quot; method from above), and convert</span></span><br><span class="line"><span class="comment">// it into a SecretKey object, using a PBE key</span></span><br><span class="line"><span class="comment">// factory.</span></span><br><span class="line">System.out.print(<span class="string">&quot;Enter encryption password:  &quot;</span>);</span><br><span class="line">System.out.flush();</span><br><span class="line">pbeKeySpec = <span class="keyword">new</span> PBEKeySpec(readPassword(System.in));</span><br><span class="line">keyFac = SecretKeyFactory.getInstance(<span class="string">&quot;PBEWithHmacSHA256AndAES_256&quot;</span>);</span><br><span class="line">SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create PBE Cipher</span></span><br><span class="line">Cipher pbeCipher = Cipher.getInstance(<span class="string">&quot;PBEWithHmacSHA256AndAES_256&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize PBE Cipher with key and parameters</span></span><br><span class="line">pbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Our cleartext</span></span><br><span class="line"><span class="keyword">byte</span>[] cleartext = <span class="string">&quot;This is another example&quot;</span>.getBytes();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Encrypt the cleartext</span></span><br><span class="line"><span class="keyword">byte</span>[] ciphertext = pbeCipher.doFinal(cleartext);</span><br></pre></td></tr></table></figure></p>
<p>Using Key Agreement</p>
<p>Please refer to Appendix D for sample programs exercising the Diffie-Hellman key exchange between 2 and 3 parties.</p>
<p>Appendix A: Standard Names
The JDK Security API requires and uses a set of standard names for algorithms, certificate and keystore types. The specification names previously found here in Appendix A and in the other security specifications (JSSE/CertPath/etc.) have been combined in the Standard Names document. This document also contains more information about the algorithm specifications. Specific provider information can be found in the Sun Provider Documentation.</p>
<p>Cryptographic implementations in the JDK are distributed through several different providers primarily for historical reasons (Sun, SunJSSE, SunJCE, SunRsaSign). Note these providers may not be available on all JDK implementations, and therefore, truly portable applications should call getInstance() without specifying specific providers. Applications specifying a particular provider may not be able to take advantage of native providers tuned for an underlying operating environment (such as PKCS or Microsoft&apos;s CAPI).</p>
<p>The SunPKCS11 provider itself does not contain any cryptographic algorithms, but instead, directs requests into an underlying PKCS11 implementation. The PKCS11 Reference Guide and the underlying PKCS11 implementation should be consulted to determine if a desired algorithm will be available through the PKCS11 provider. Likewise, on Windows systems, the SunMSCAPI provider does not provide any cryptographic functionality, but instead routes requests to the underlying Operating System for handling.</p>
<p>Appendix B: Jurisdiction Policy File Format
JCA represents its jurisdiction policy files as Java style policy files with corresponding permission statements. As described in Default Policy Implementation and Policy File Syntax, a Java policy file specifies what permissions are allowed for code from specified code sources. A permission represents access to a system resource. In the case of JCA, the &quot;resources&quot; are cryptography algorithms, and code sources do not need to be specified, because the cryptographic restrictions apply to all code.</p>
<p>A jurisdiction policy file consists of a very basic &quot;grant entry&quot; containing one or more &quot;permission entries.&quot;</p>
<p>grant {
&lt;permission entries&gt;;
};</p>
<p>The format of a permission entry in a jurisdiction policy file is:</p>
<p>permission &lt;crypto permission class name&gt;[ &lt;alg_name&gt;
[[, &lt;exemption mechanism name&gt;][, &lt;maxKeySize&gt;
[, &lt;AlgorithmParameterSpec class name&gt;,
&lt;parameters for constructing an
AlgorithmParameterSpec object&gt;]]]];
A sample jurisdiction policy file that includes restricting the &quot;Blowfish&quot; algorithm to maximum key sizes of 64 bits is:</p>
<pre><code>grant {
    permission javax.crypto.CryptoPermission &quot;Blowfish&quot;, 64;
    // ...
};
</code></pre>
<p>A permission entry must begin with the word permission. The &lt;crypto permission class name&gt; in the template above would actually be a specific permission class name, such as javax.crypto.CryptoPermission. A crypto permission class reflects the ability of an application/applet to use certain algorithms with certain key sizes in certain environments. There are two crypto permission classes: CryptoPermission and CryptoAllPermission. The special CryptoAllPermission class implies all cryptography-related permissions, that is, it specifies that there are no cryptography-related restrictions.</p>
<p>The &lt;alg_name&gt;, when utilized, is a quoted string specifying the standard name (see Appendix A) of a cryptography algorithm, such as &quot;DES&quot; or &quot;RSA&quot;.</p>
<p>The &lt;exemption mechanism name&gt;, when specified, is a quoted string indicating an exemption mechanism which, if enforced, enables a reduction in cryptographic restrictions. Exemption mechanism names that can be used include &quot;KeyRecovery&quot; &quot;KeyEscrow&quot;, and &quot;KeyWeakening&quot;.</p>
<p>&lt;maxKeySize&gt; is an integer specifying the maximum key size (in bits) allowed for the specified algorithm.</p>
<p>For some algorithms it may not be sufficient to specify the algorithm strength in terms of just a key size. For example, in the case of the &quot;RC5&quot; algorithm, the number of rounds must also be considered. For algorithms whose strength needs to be expressed as more than a key size, the permission entry should also specify an AlgorithmParameterSpec class name (such as javax.crypto.spec.RC5ParameterSpec) and a list of parameters for constructing the specified AlgorithmParameterSpec object.</p>
<p>Items that appear in a permission entry must appear in the specified order. An entry is terminated with a semicolon.</p>
<p>Case is unimportant for the identifiers (grant, permission) but is significant for the &lt;crypto permission class name&gt; or for any string that is passed in as a value.</p>
<p>NOTE: An &quot;<em>&quot; can be used as a wildcard for any permission entry option. For example, an &quot;</em>&quot; (without the quotes) for an &lt;alg_name&gt; option means &quot;all algorithms.&quot;</p>
<p>Appendix C: Maximum Key Sizes Allowed by &quot;Strong&quot; Jurisdiction Policy Files
Due to import control restrictions, the jurisdiction policy files shipped with the Java SE Development Kit allow &quot;strong&quot; but limited cryptography to be used. For more info, please see Import Limits on Cryptographic Algorithms.</p>
<p>Appendix D: Sample Programs
Diffie-Hellman Key Exchange between 2 Parties</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 1997, 2001, Oracle and/or its affiliates. All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Redistribution and use in source and binary forms, with or without</span></span><br><span class="line"><span class="comment"> * modification, are permitted provided that the following conditions</span></span><br><span class="line"><span class="comment"> * are met:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   - Redistributions of source code must retain the above copyright</span></span><br><span class="line"><span class="comment"> *     notice, this list of conditions and the following disclaimer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   - Redistributions in binary form must reproduce the above copyright</span></span><br><span class="line"><span class="comment"> *     notice, this list of conditions and the following disclaimer in the</span></span><br><span class="line"><span class="comment"> *     documentation and/or other materials provided with the distribution.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   - Neither the name of Oracle nor the names of its</span></span><br><span class="line"><span class="comment"> *     contributors may be used to endorse or promote products derived</span></span><br><span class="line"><span class="comment"> *     from this software without specific prior written permission.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS</span></span><br><span class="line"><span class="comment"> * IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,</span></span><br><span class="line"><span class="comment"> * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</span></span><br><span class="line"><span class="comment"> * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR</span></span><br><span class="line"><span class="comment"> * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span></span><br><span class="line"><span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,</span></span><br><span class="line"><span class="comment"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</span></span><br><span class="line"><span class="comment"> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span></span><br><span class="line"><span class="comment"> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span></span><br><span class="line"><span class="comment"> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span></span><br><span class="line"><span class="comment"> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.*;</span><br><span class="line"><span class="keyword">import</span> java.security.interfaces.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.interfaces.*;</span><br><span class="line"><span class="keyword">import</span> com.sun.crypto.provider.SunJCE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program executes the Diffie-Hellman key agreement protocol</span></span><br><span class="line"><span class="comment"> * between 2 parties: Alice and Bob.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * By default, preconfigured parameters (1024-bit prime modulus and base</span></span><br><span class="line"><span class="comment"> * generator used by SKIP) are used.</span></span><br><span class="line"><span class="comment"> * If this program is called with the &quot;-gen&quot; option, a new set of</span></span><br><span class="line"><span class="comment"> * parameters is created.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DHKeyAgreement2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DHKeyAgreement2</span><span class="params">()</span> </span>{}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            String mode = <span class="string">&quot;USE_SKIP_DH_PARAMS&quot;</span>;</span><br><span class="line"></span><br><span class="line">            DHKeyAgreement2 keyAgree = <span class="keyword">new</span> DHKeyAgreement2();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (argv.length &gt; <span class="number">1</span>) {</span><br><span class="line">                keyAgree.usage();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Wrong number of command options&quot;</span>);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (argv.length == <span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">if</span> (!(argv[<span class="number">0</span>].equals(<span class="string">&quot;-gen&quot;</span>))) {</span><br><span class="line">                    keyAgree.usage();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Unrecognized flag: &quot;</span> + argv[<span class="number">0</span>]);</span><br><span class="line">                }</span><br><span class="line">                mode = <span class="string">&quot;GENERATE_DH_PARAMS&quot;</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            keyAgree.run(mode);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            System.err.println(<span class="string">&quot;Error: &quot;</span> + e);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String mode)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        DHParameterSpec dhSkipParamSpec;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mode.equals(<span class="string">&quot;GENERATE_DH_PARAMS&quot;</span>)) {</span><br><span class="line">            <span class="comment">// Some central authority creates new DH parameters</span></span><br><span class="line">            System.out.println</span><br><span class="line">                (<span class="string">&quot;Creating Diffie-Hellman parameters (takes VERY long) ...&quot;</span>);</span><br><span class="line">            AlgorithmParameterGenerator paramGen</span><br><span class="line">                = AlgorithmParameterGenerator.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">            paramGen.init(<span class="number">512</span>);</span><br><span class="line">            AlgorithmParameters params = paramGen.generateParameters();</span><br><span class="line">            dhSkipParamSpec = (DHParameterSpec)params.getParameterSpec</span><br><span class="line">                (DHParameterSpec.class);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// use some pre-generated, default DH parameters</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Using SKIP Diffie-Hellman parameters&quot;</span>);</span><br><span class="line">            dhSkipParamSpec = <span class="keyword">new</span> DHParameterSpec(skip1024Modulus,</span><br><span class="line">                                                  skip1024Base);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Alice creates her own DH key pair, using the DH parameters from</span></span><br><span class="line"><span class="comment">         * above</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ALICE: Generate DH keypair ...&quot;</span>);</span><br><span class="line">        KeyPairGenerator aliceKpairGen = KeyPairGenerator.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">        aliceKpairGen.initialize(dhSkipParamSpec);</span><br><span class="line">        KeyPair aliceKpair = aliceKpairGen.generateKeyPair();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Alice creates and initializes her DH KeyAgreement object</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ALICE: Initialization ...&quot;</span>);</span><br><span class="line">        KeyAgreement aliceKeyAgree = KeyAgreement.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">        aliceKeyAgree.init(aliceKpair.getPrivate());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Alice encodes her public key, and sends it over to Bob.</span></span><br><span class="line">        <span class="keyword">byte</span>[] alicePubKeyEnc = aliceKpair.getPublic().getEncoded();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Let&apos;s turn over to Bob. Bob has received Alice&apos;s public key</span></span><br><span class="line"><span class="comment">         * in encoded format.</span></span><br><span class="line"><span class="comment">         * He instantiates a DH public key from the encoded key material.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        KeyFactory bobKeyFac = KeyFactory.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">        X509EncodedKeySpec x509KeySpec = <span class="keyword">new</span> X509EncodedKeySpec</span><br><span class="line">            (alicePubKeyEnc);</span><br><span class="line">        PublicKey alicePubKey = bobKeyFac.generatePublic(x509KeySpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Bob gets the DH parameters associated with Alice&apos;s public key.</span></span><br><span class="line"><span class="comment">         * He must use the same parameters when he generates his own key</span></span><br><span class="line"><span class="comment">         * pair.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        DHParameterSpec dhParamSpec = ((DHPublicKey)alicePubKey).getParams();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Bob creates his own DH key pair</span></span><br><span class="line">        System.out.println(<span class="string">&quot;BOB: Generate DH keypair ...&quot;</span>);</span><br><span class="line">        KeyPairGenerator bobKpairGen = KeyPairGenerator.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">        bobKpairGen.initialize(dhParamSpec);</span><br><span class="line">        KeyPair bobKpair = bobKpairGen.generateKeyPair();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Bob creates and initializes his DH KeyAgreement object</span></span><br><span class="line">        System.out.println(<span class="string">&quot;BOB: Initialization ...&quot;</span>);</span><br><span class="line">        KeyAgreement bobKeyAgree = KeyAgreement.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">        bobKeyAgree.init(bobKpair.getPrivate());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Bob encodes his public key, and sends it over to Alice.</span></span><br><span class="line">        <span class="keyword">byte</span>[] bobPubKeyEnc = bobKpair.getPublic().getEncoded();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Alice uses Bob&apos;s public key for the first (and only) phase</span></span><br><span class="line"><span class="comment">         * of her version of the DH</span></span><br><span class="line"><span class="comment">         * protocol.</span></span><br><span class="line"><span class="comment">         * Before she can do so, she has to instantiate a DH public key</span></span><br><span class="line"><span class="comment">         * from Bob&apos;s encoded key material.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        KeyFactory aliceKeyFac = KeyFactory.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">        x509KeySpec = <span class="keyword">new</span> X509EncodedKeySpec(bobPubKeyEnc);</span><br><span class="line">        PublicKey bobPubKey = aliceKeyFac.generatePublic(x509KeySpec);</span><br><span class="line">        System.out.println(<span class="string">&quot;ALICE: Execute PHASE1 ...&quot;</span>);</span><br><span class="line">        aliceKeyAgree.doPhase(bobPubKey, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Bob uses Alice&apos;s public key for the first (and only) phase</span></span><br><span class="line"><span class="comment">         * of his version of the DH</span></span><br><span class="line"><span class="comment">         * protocol.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;BOB: Execute PHASE1 ...&quot;</span>);</span><br><span class="line">        bobKeyAgree.doPhase(alicePubKey, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * At this stage, both Alice and Bob have completed the DH key</span></span><br><span class="line"><span class="comment">         * agreement protocol.</span></span><br><span class="line"><span class="comment">         * Both generate the (same) shared secret.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">byte</span>[] aliceSharedSecret = aliceKeyAgree.generateSecret();</span><br><span class="line">        <span class="keyword">int</span> aliceLen = aliceSharedSecret.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bobSharedSecret = <span class="keyword">new</span> <span class="keyword">byte</span>[aliceLen];</span><br><span class="line">        <span class="keyword">int</span> bobLen;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// show example of what happens if you</span></span><br><span class="line">            <span class="comment">// provide an output buffer that is too short</span></span><br><span class="line">            bobLen = bobKeyAgree.generateSecret(bobSharedSecret, <span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (ShortBufferException e) {</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// provide output buffer of required size</span></span><br><span class="line">        bobLen = bobKeyAgree.generateSecret(bobSharedSecret, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Alice secret: &quot;</span> +</span><br><span class="line">          toHexString(aliceSharedSecret));</span><br><span class="line">        System.out.println(<span class="string">&quot;Bob secret: &quot;</span> +</span><br><span class="line">          toHexString(bobSharedSecret));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!java.util.Arrays.equals(aliceSharedSecret, bobSharedSecret))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Shared secrets differ&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Shared secrets are the same&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Now let&apos;s return the shared secret as a SecretKey object</span></span><br><span class="line"><span class="comment">         * and use it for encryption. First, we generate SecretKeys for the</span></span><br><span class="line"><span class="comment">         * &quot;DES&quot; algorithm (based on the raw shared secret data) and</span></span><br><span class="line"><span class="comment">         * then we use DES in ECB mode</span></span><br><span class="line"><span class="comment">         * as the encryption algorithm. DES in ECB mode does not require any</span></span><br><span class="line"><span class="comment">         * parameters.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Then we use DES in CBC mode, which requires an initialization</span></span><br><span class="line"><span class="comment">         * vector (IV) parameter. In CBC mode, you need to initialize the</span></span><br><span class="line"><span class="comment">         * Cipher object with an IV, which can be supplied using the</span></span><br><span class="line"><span class="comment">         * javax.crypto.spec.IvParameterSpec class. Note that you have to use</span></span><br><span class="line"><span class="comment">         * the same IV for encryption and decryption: If you use a different</span></span><br><span class="line"><span class="comment">         * IV for decryption than you used for encryption, decryption will</span></span><br><span class="line"><span class="comment">         * fail.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">NOTE:</span> If you do not specify an IV when you initialize the</span></span><br><span class="line"><span class="comment">         * Cipher object for encryption, the underlying implementation</span></span><br><span class="line"><span class="comment">         * will generate a random one, which you have to retrieve using the</span></span><br><span class="line"><span class="comment">         * javax.crypto.Cipher.getParameters() method, which returns an</span></span><br><span class="line"><span class="comment">         * instance of java.security.AlgorithmParameters. You need to transfer</span></span><br><span class="line"><span class="comment">         * the contents of that object (e.g., in encoded format, obtained via</span></span><br><span class="line"><span class="comment">         * the AlgorithmParameters.getEncoded() method) to the party who will</span></span><br><span class="line"><span class="comment">         * do the decryption. When initializing the Cipher for decryption,</span></span><br><span class="line"><span class="comment">         * the (reinstantiated) AlgorithmParameters object must be passed to</span></span><br><span class="line"><span class="comment">         * the Cipher.init() method.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Return shared secret as SecretKey object ...&quot;</span>);</span><br><span class="line">        <span class="comment">// Bob</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> The call to bobKeyAgree.generateSecret above reset the key</span></span><br><span class="line">        <span class="comment">// agreement object, so we call doPhase again prior to another</span></span><br><span class="line">        <span class="comment">// generateSecret call</span></span><br><span class="line">        bobKeyAgree.doPhase(alicePubKey, <span class="keyword">true</span>);</span><br><span class="line">        SecretKey bobDesKey = bobKeyAgree.generateSecret(<span class="string">&quot;DES&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Alice</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> The call to aliceKeyAgree.generateSecret above reset the key</span></span><br><span class="line">        <span class="comment">// agreement object, so we call doPhase again prior to another</span></span><br><span class="line">        <span class="comment">// generateSecret call</span></span><br><span class="line">        aliceKeyAgree.doPhase(bobPubKey, <span class="keyword">true</span>);</span><br><span class="line">        SecretKey aliceDesKey = aliceKeyAgree.generateSecret(<span class="string">&quot;DES&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Bob encrypts, using DES in ECB mode</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Cipher bobCipher = Cipher.getInstance(<span class="string">&quot;DES/ECB/PKCS5Padding&quot;</span>);</span><br><span class="line">        bobCipher.init(Cipher.ENCRYPT_MODE, bobDesKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] cleartext = <span class="string">&quot;This is just an example&quot;</span>.getBytes();</span><br><span class="line">        <span class="keyword">byte</span>[] ciphertext = bobCipher.doFinal(cleartext);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Alice decrypts, using DES in ECB mode</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Cipher aliceCipher = Cipher.getInstance(<span class="string">&quot;DES/ECB/PKCS5Padding&quot;</span>);</span><br><span class="line">        aliceCipher.init(Cipher.DECRYPT_MODE, aliceDesKey);</span><br><span class="line">        <span class="keyword">byte</span>[] recovered = aliceCipher.doFinal(ciphertext);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!java.util.Arrays.equals(cleartext, recovered))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;DES in CBC mode recovered text is &quot;</span> +</span><br><span class="line">              <span class="string">&quot;different from cleartext&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;DES in ECB mode recovered text is &quot;</span> +</span><br><span class="line">            <span class="string">&quot;same as cleartext&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Bob encrypts, using DES in CBC mode</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        bobCipher = Cipher.getInstance(<span class="string">&quot;DES/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line">        bobCipher.init(Cipher.ENCRYPT_MODE, bobDesKey);</span><br><span class="line"></span><br><span class="line">        cleartext = <span class="string">&quot;This is just an example&quot;</span>.getBytes();</span><br><span class="line">        ciphertext = bobCipher.doFinal(cleartext);</span><br><span class="line">        <span class="comment">// Retrieve the parameter that was used, and transfer it to Alice in</span></span><br><span class="line">        <span class="comment">// encoded format</span></span><br><span class="line">        <span class="keyword">byte</span>[] encodedParams = bobCipher.getParameters().getEncoded();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Alice decrypts, using DES in CBC mode</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// Instantiate AlgorithmParameters object from parameter encoding</span></span><br><span class="line">        <span class="comment">// obtained from Bob</span></span><br><span class="line">        AlgorithmParameters params = AlgorithmParameters.getInstance(<span class="string">&quot;DES&quot;</span>);</span><br><span class="line">        params.init(encodedParams);</span><br><span class="line">        aliceCipher = Cipher.getInstance(<span class="string">&quot;DES/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line">        aliceCipher.init(Cipher.DECRYPT_MODE, aliceDesKey, params);</span><br><span class="line">        recovered = aliceCipher.doFinal(ciphertext);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!java.util.Arrays.equals(cleartext, recovered))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;DES in CBC mode recovered text is &quot;</span> +</span><br><span class="line">              <span class="string">&quot;different from cleartext&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;DES in CBC mode recovered text is &quot;</span> +</span><br><span class="line">            <span class="string">&quot;same as cleartext&quot;</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Converts a byte to hex digit and writes to the supplied buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">byte2hex</span><span class="params">(<span class="keyword">byte</span> b, StringBuffer buf)</span> </span>{</span><br><span class="line">        <span class="keyword">char</span>[] hexChars = { <span class="string">&apos;0&apos;</span>, <span class="string">&apos;1&apos;</span>, <span class="string">&apos;2&apos;</span>, <span class="string">&apos;3&apos;</span>, <span class="string">&apos;4&apos;</span>, <span class="string">&apos;5&apos;</span>, <span class="string">&apos;6&apos;</span>, <span class="string">&apos;7&apos;</span>, <span class="string">&apos;8&apos;</span>,</span><br><span class="line">                            <span class="string">&apos;9&apos;</span>, <span class="string">&apos;A&apos;</span>, <span class="string">&apos;B&apos;</span>, <span class="string">&apos;C&apos;</span>, <span class="string">&apos;D&apos;</span>, <span class="string">&apos;E&apos;</span>, <span class="string">&apos;F&apos;</span> };</span><br><span class="line">        <span class="keyword">int</span> high = ((b &amp; <span class="number">0xf0</span>) &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">int</span> low = (b &amp; <span class="number">0x0f</span>);</span><br><span class="line">        buf.append(hexChars[high]);</span><br><span class="line">        buf.append(hexChars[low]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Converts a byte array to hex string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">toHexString</span><span class="params">(<span class="keyword">byte</span>[] block)</span> </span>{</span><br><span class="line">        StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = block.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">             byte2hex(block[i], buf);</span><br><span class="line">             <span class="keyword">if</span> (i &lt; len-<span class="number">1</span>) {</span><br><span class="line">                 buf.append(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">             }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> buf.toString();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Prints the usage of this test.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">usage</span><span class="params">()</span> </span>{</span><br><span class="line">        System.err.print(<span class="string">&quot;DHKeyAgreement usage: &quot;</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;[-gen]&quot;</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The 1024 bit Diffie-Hellman modulus values used by SKIP</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> skip1024ModulusBytes[] = {</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xF4</span>, (<span class="keyword">byte</span>)<span class="number">0x88</span>, (<span class="keyword">byte</span>)<span class="number">0xFD</span>, (<span class="keyword">byte</span>)<span class="number">0x58</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x4E</span>, (<span class="keyword">byte</span>)<span class="number">0x49</span>, (<span class="keyword">byte</span>)<span class="number">0xDB</span>, (<span class="keyword">byte</span>)<span class="number">0xCD</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x20</span>, (<span class="keyword">byte</span>)<span class="number">0xB4</span>, (<span class="keyword">byte</span>)<span class="number">0x9D</span>, (<span class="keyword">byte</span>)<span class="number">0xE4</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x91</span>, (<span class="keyword">byte</span>)<span class="number">0x07</span>, (<span class="keyword">byte</span>)<span class="number">0x36</span>, (<span class="keyword">byte</span>)<span class="number">0x6B</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x33</span>, (<span class="keyword">byte</span>)<span class="number">0x6C</span>, (<span class="keyword">byte</span>)<span class="number">0x38</span>, (<span class="keyword">byte</span>)<span class="number">0x0D</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x45</span>, (<span class="keyword">byte</span>)<span class="number">0x1D</span>, (<span class="keyword">byte</span>)<span class="number">0x0F</span>, (<span class="keyword">byte</span>)<span class="number">0x7C</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x88</span>, (<span class="keyword">byte</span>)<span class="number">0xB3</span>, (<span class="keyword">byte</span>)<span class="number">0x1C</span>, (<span class="keyword">byte</span>)<span class="number">0x7C</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x5B</span>, (<span class="keyword">byte</span>)<span class="number">0x2D</span>, (<span class="keyword">byte</span>)<span class="number">0x8E</span>, (<span class="keyword">byte</span>)<span class="number">0xF6</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xF3</span>, (<span class="keyword">byte</span>)<span class="number">0xC9</span>, (<span class="keyword">byte</span>)<span class="number">0x23</span>, (<span class="keyword">byte</span>)<span class="number">0xC0</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x43</span>, (<span class="keyword">byte</span>)<span class="number">0xF0</span>, (<span class="keyword">byte</span>)<span class="number">0xA5</span>, (<span class="keyword">byte</span>)<span class="number">0x5B</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x18</span>, (<span class="keyword">byte</span>)<span class="number">0x8D</span>, (<span class="keyword">byte</span>)<span class="number">0x8E</span>, (<span class="keyword">byte</span>)<span class="number">0xBB</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x55</span>, (<span class="keyword">byte</span>)<span class="number">0x8C</span>, (<span class="keyword">byte</span>)<span class="number">0xB8</span>, (<span class="keyword">byte</span>)<span class="number">0x5D</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x38</span>, (<span class="keyword">byte</span>)<span class="number">0xD3</span>, (<span class="keyword">byte</span>)<span class="number">0x34</span>, (<span class="keyword">byte</span>)<span class="number">0xFD</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x7C</span>, (<span class="keyword">byte</span>)<span class="number">0x17</span>, (<span class="keyword">byte</span>)<span class="number">0x57</span>, (<span class="keyword">byte</span>)<span class="number">0x43</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xA3</span>, (<span class="keyword">byte</span>)<span class="number">0x1D</span>, (<span class="keyword">byte</span>)<span class="number">0x18</span>, (<span class="keyword">byte</span>)<span class="number">0x6C</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xDE</span>, (<span class="keyword">byte</span>)<span class="number">0x33</span>, (<span class="keyword">byte</span>)<span class="number">0x21</span>, (<span class="keyword">byte</span>)<span class="number">0x2C</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xB5</span>, (<span class="keyword">byte</span>)<span class="number">0x2A</span>, (<span class="keyword">byte</span>)<span class="number">0xFF</span>, (<span class="keyword">byte</span>)<span class="number">0x3C</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xE1</span>, (<span class="keyword">byte</span>)<span class="number">0xB1</span>, (<span class="keyword">byte</span>)<span class="number">0x29</span>, (<span class="keyword">byte</span>)<span class="number">0x40</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x18</span>, (<span class="keyword">byte</span>)<span class="number">0x11</span>, (<span class="keyword">byte</span>)<span class="number">0x8D</span>, (<span class="keyword">byte</span>)<span class="number">0x7C</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x84</span>, (<span class="keyword">byte</span>)<span class="number">0xA7</span>, (<span class="keyword">byte</span>)<span class="number">0x0A</span>, (<span class="keyword">byte</span>)<span class="number">0x72</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xD6</span>, (<span class="keyword">byte</span>)<span class="number">0x86</span>, (<span class="keyword">byte</span>)<span class="number">0xC4</span>, (<span class="keyword">byte</span>)<span class="number">0x03</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x19</span>, (<span class="keyword">byte</span>)<span class="number">0xC8</span>, (<span class="keyword">byte</span>)<span class="number">0x07</span>, (<span class="keyword">byte</span>)<span class="number">0x29</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x7A</span>, (<span class="keyword">byte</span>)<span class="number">0xCA</span>, (<span class="keyword">byte</span>)<span class="number">0x95</span>, (<span class="keyword">byte</span>)<span class="number">0x0C</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xD9</span>, (<span class="keyword">byte</span>)<span class="number">0x96</span>, (<span class="keyword">byte</span>)<span class="number">0x9F</span>, (<span class="keyword">byte</span>)<span class="number">0xAB</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xD0</span>, (<span class="keyword">byte</span>)<span class="number">0x0A</span>, (<span class="keyword">byte</span>)<span class="number">0x50</span>, (<span class="keyword">byte</span>)<span class="number">0x9B</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x02</span>, (<span class="keyword">byte</span>)<span class="number">0x46</span>, (<span class="keyword">byte</span>)<span class="number">0xD3</span>, (<span class="keyword">byte</span>)<span class="number">0x08</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x3D</span>, (<span class="keyword">byte</span>)<span class="number">0x66</span>, (<span class="keyword">byte</span>)<span class="number">0xA4</span>, (<span class="keyword">byte</span>)<span class="number">0x5D</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x41</span>, (<span class="keyword">byte</span>)<span class="number">0x9F</span>, (<span class="keyword">byte</span>)<span class="number">0x9C</span>, (<span class="keyword">byte</span>)<span class="number">0x7C</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xBD</span>, (<span class="keyword">byte</span>)<span class="number">0x89</span>, (<span class="keyword">byte</span>)<span class="number">0x4B</span>, (<span class="keyword">byte</span>)<span class="number">0x22</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x19</span>, (<span class="keyword">byte</span>)<span class="number">0x26</span>, (<span class="keyword">byte</span>)<span class="number">0xBA</span>, (<span class="keyword">byte</span>)<span class="number">0xAB</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xA2</span>, (<span class="keyword">byte</span>)<span class="number">0x5E</span>, (<span class="keyword">byte</span>)<span class="number">0xC3</span>, (<span class="keyword">byte</span>)<span class="number">0x55</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xE9</span>, (<span class="keyword">byte</span>)<span class="number">0x2F</span>, (<span class="keyword">byte</span>)<span class="number">0x78</span>, (<span class="keyword">byte</span>)<span class="number">0xC7</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The SKIP 1024 bit modulus</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BigInteger skip1024Modulus</span><br><span class="line">    = <span class="keyword">new</span> BigInteger(<span class="number">1</span>, skip1024ModulusBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The base used with the SKIP 1024 bit modulus</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BigInteger skip1024Base = BigInteger.valueOf(<span class="number">2</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>Diffie-Hellman Key Exchange between 3 Parties
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 1997, 2001, Oracle and/or its affiliates. All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Redistribution and use in source and binary forms, with or without</span></span><br><span class="line"><span class="comment"> * modification, are permitted provided that the following conditions</span></span><br><span class="line"><span class="comment"> * are met:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   - Redistributions of source code must retain the above copyright</span></span><br><span class="line"><span class="comment"> *     notice, this list of conditions and the following disclaimer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   - Redistributions in binary form must reproduce the above copyright</span></span><br><span class="line"><span class="comment"> *     notice, this list of conditions and the following disclaimer in the</span></span><br><span class="line"><span class="comment"> *     documentation and/or other materials provided with the distribution.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   - Neither the name of Oracle nor the names of its</span></span><br><span class="line"><span class="comment"> *     contributors may be used to endorse or promote products derived</span></span><br><span class="line"><span class="comment"> *     from this software without specific prior written permission.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS</span></span><br><span class="line"><span class="comment"> * IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,</span></span><br><span class="line"><span class="comment"> * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</span></span><br><span class="line"><span class="comment"> * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR</span></span><br><span class="line"><span class="comment"> * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span></span><br><span class="line"><span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,</span></span><br><span class="line"><span class="comment"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</span></span><br><span class="line"><span class="comment"> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span></span><br><span class="line"><span class="comment"> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span></span><br><span class="line"><span class="comment"> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span></span><br><span class="line"><span class="comment"> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.*;</span><br><span class="line"><span class="keyword">import</span> java.security.interfaces.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.interfaces.*;</span><br><span class="line"><span class="keyword">import</span> com.sun.crypto.provider.SunJCE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program executes the Diffie-Hellman key agreement protocol</span></span><br><span class="line"><span class="comment"> * between 3 parties: Alice, Bob, and Carol.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We use the same 1024-bit prime modulus and base generator that are</span></span><br><span class="line"><span class="comment"> * used by SKIP.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DHKeyAgreement3</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DHKeyAgreement3</span><span class="params">()</span> </span>{}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            DHKeyAgreement3 keyAgree = <span class="keyword">new</span> DHKeyAgreement3();</span><br><span class="line">            keyAgree.run();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            System.err.println(<span class="string">&quot;Error: &quot;</span> + e);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        DHParameterSpec dhSkipParamSpec;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Using SKIP Diffie-Hellman parameters&quot;</span>);</span><br><span class="line">        dhSkipParamSpec = <span class="keyword">new</span> DHParameterSpec(skip1024Modulus, skip1024Base);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Alice creates her own DH key pair</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ALICE: Generate DH keypair ...&quot;</span>);</span><br><span class="line">        KeyPairGenerator aliceKpairGen = KeyPairGenerator.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">        aliceKpairGen.initialize(dhSkipParamSpec);</span><br><span class="line">        KeyPair aliceKpair = aliceKpairGen.generateKeyPair();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Bob creates his own DH key pair</span></span><br><span class="line">        System.out.println(<span class="string">&quot;BOB: Generate DH keypair ...&quot;</span>);</span><br><span class="line">        KeyPairGenerator bobKpairGen = KeyPairGenerator.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">        bobKpairGen.initialize(dhSkipParamSpec);</span><br><span class="line">        KeyPair bobKpair = bobKpairGen.generateKeyPair();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Carol creates her own DH key pair</span></span><br><span class="line">        System.out.println(<span class="string">&quot;CAROL: Generate DH keypair ...&quot;</span>);</span><br><span class="line">        KeyPairGenerator carolKpairGen = KeyPairGenerator.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">        carolKpairGen.initialize(dhSkipParamSpec);</span><br><span class="line">        KeyPair carolKpair = carolKpairGen.generateKeyPair();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Alice initialize</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ALICE: Initialize ...&quot;</span>);</span><br><span class="line">        KeyAgreement aliceKeyAgree = KeyAgreement.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">        aliceKeyAgree.init(aliceKpair.getPrivate());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Bob initialize</span></span><br><span class="line">        System.out.println(<span class="string">&quot;BOB: Initialize ...&quot;</span>);</span><br><span class="line">        KeyAgreement bobKeyAgree = KeyAgreement.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">        bobKeyAgree.init(bobKpair.getPrivate());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Carol initialize</span></span><br><span class="line">        System.out.println(<span class="string">&quot;CAROL: Initialize ...&quot;</span>);</span><br><span class="line">        KeyAgreement carolKeyAgree = KeyAgreement.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">        carolKeyAgree.init(carolKpair.getPrivate());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Alice uses Carol&apos;s public key</span></span><br><span class="line">        Key ac = aliceKeyAgree.doPhase(carolKpair.getPublic(), <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Bob uses Alice&apos;s public key</span></span><br><span class="line">        Key ba = bobKeyAgree.doPhase(aliceKpair.getPublic(), <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Carol uses Bob&apos;s public key</span></span><br><span class="line">        Key cb = carolKeyAgree.doPhase(bobKpair.getPublic(), <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Alice uses Carol&apos;s result from above</span></span><br><span class="line">        aliceKeyAgree.doPhase(cb, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Bob uses Alice&apos;s result from above</span></span><br><span class="line">        bobKeyAgree.doPhase(ac, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Carol uses Bob&apos;s result from above</span></span><br><span class="line">        carolKeyAgree.doPhase(ba, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Alice, Bob and Carol compute their secrets</span></span><br><span class="line">        <span class="keyword">byte</span>[] aliceSharedSecret = aliceKeyAgree.generateSecret();</span><br><span class="line">        System.out.println(<span class="string">&quot;Alice secret: &quot;</span> + toHexString(aliceSharedSecret));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bobSharedSecret = bobKeyAgree.generateSecret();</span><br><span class="line">        System.out.println(<span class="string">&quot;Bob secret: &quot;</span> + toHexString(bobSharedSecret));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] carolSharedSecret = carolKeyAgree.generateSecret();</span><br><span class="line">        System.out.println(<span class="string">&quot;Carol secret: &quot;</span> + toHexString(carolSharedSecret));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compare Alice and Bob</span></span><br><span class="line">        <span class="keyword">if</span> (!java.util.Arrays.equals(aliceSharedSecret, bobSharedSecret))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Alice and Bob differ&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Alice and Bob are the same&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compare Bob and Carol</span></span><br><span class="line">        <span class="keyword">if</span> (!java.util.Arrays.equals(bobSharedSecret, carolSharedSecret))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Bob and Carol differ&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Bob and Carol are the same&quot;</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Converts a byte to hex digit and writes to the supplied buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">byte2hex</span><span class="params">(<span class="keyword">byte</span> b, StringBuffer buf)</span> </span>{</span><br><span class="line">        <span class="keyword">char</span>[] hexChars = { <span class="string">&apos;0&apos;</span>, <span class="string">&apos;1&apos;</span>, <span class="string">&apos;2&apos;</span>, <span class="string">&apos;3&apos;</span>, <span class="string">&apos;4&apos;</span>, <span class="string">&apos;5&apos;</span>, <span class="string">&apos;6&apos;</span>, <span class="string">&apos;7&apos;</span>, <span class="string">&apos;8&apos;</span>,</span><br><span class="line">                            <span class="string">&apos;9&apos;</span>, <span class="string">&apos;A&apos;</span>, <span class="string">&apos;B&apos;</span>, <span class="string">&apos;C&apos;</span>, <span class="string">&apos;D&apos;</span>, <span class="string">&apos;E&apos;</span>, <span class="string">&apos;F&apos;</span> };</span><br><span class="line">        <span class="keyword">int</span> high = ((b &amp; <span class="number">0xf0</span>) &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">int</span> low = (b &amp; <span class="number">0x0f</span>);</span><br><span class="line">        buf.append(hexChars[high]);</span><br><span class="line">        buf.append(hexChars[low]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Converts a byte array to hex string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">toHexString</span><span class="params">(<span class="keyword">byte</span>[] block)</span> </span>{</span><br><span class="line">        StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = block.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">             byte2hex(block[i], buf);</span><br><span class="line">             <span class="keyword">if</span> (i &lt; len-<span class="number">1</span>) {</span><br><span class="line">                 buf.append(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">             }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> buf.toString();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Prints the usage of this test.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">usage</span><span class="params">()</span> </span>{</span><br><span class="line">        System.err.print(<span class="string">&quot;DHKeyAgreement usage: &quot;</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;[-gen]&quot;</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The 1024 bit Diffie-Hellman modulus values used by SKIP</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> skip1024ModulusBytes[] = {</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xF4</span>, (<span class="keyword">byte</span>)<span class="number">0x88</span>, (<span class="keyword">byte</span>)<span class="number">0xFD</span>, (<span class="keyword">byte</span>)<span class="number">0x58</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x4E</span>, (<span class="keyword">byte</span>)<span class="number">0x49</span>, (<span class="keyword">byte</span>)<span class="number">0xDB</span>, (<span class="keyword">byte</span>)<span class="number">0xCD</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x20</span>, (<span class="keyword">byte</span>)<span class="number">0xB4</span>, (<span class="keyword">byte</span>)<span class="number">0x9D</span>, (<span class="keyword">byte</span>)<span class="number">0xE4</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x91</span>, (<span class="keyword">byte</span>)<span class="number">0x07</span>, (<span class="keyword">byte</span>)<span class="number">0x36</span>, (<span class="keyword">byte</span>)<span class="number">0x6B</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x33</span>, (<span class="keyword">byte</span>)<span class="number">0x6C</span>, (<span class="keyword">byte</span>)<span class="number">0x38</span>, (<span class="keyword">byte</span>)<span class="number">0x0D</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x45</span>, (<span class="keyword">byte</span>)<span class="number">0x1D</span>, (<span class="keyword">byte</span>)<span class="number">0x0F</span>, (<span class="keyword">byte</span>)<span class="number">0x7C</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x88</span>, (<span class="keyword">byte</span>)<span class="number">0xB3</span>, (<span class="keyword">byte</span>)<span class="number">0x1C</span>, (<span class="keyword">byte</span>)<span class="number">0x7C</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x5B</span>, (<span class="keyword">byte</span>)<span class="number">0x2D</span>, (<span class="keyword">byte</span>)<span class="number">0x8E</span>, (<span class="keyword">byte</span>)<span class="number">0xF6</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xF3</span>, (<span class="keyword">byte</span>)<span class="number">0xC9</span>, (<span class="keyword">byte</span>)<span class="number">0x23</span>, (<span class="keyword">byte</span>)<span class="number">0xC0</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x43</span>, (<span class="keyword">byte</span>)<span class="number">0xF0</span>, (<span class="keyword">byte</span>)<span class="number">0xA5</span>, (<span class="keyword">byte</span>)<span class="number">0x5B</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x18</span>, (<span class="keyword">byte</span>)<span class="number">0x8D</span>, (<span class="keyword">byte</span>)<span class="number">0x8E</span>, (<span class="keyword">byte</span>)<span class="number">0xBB</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x55</span>, (<span class="keyword">byte</span>)<span class="number">0x8C</span>, (<span class="keyword">byte</span>)<span class="number">0xB8</span>, (<span class="keyword">byte</span>)<span class="number">0x5D</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x38</span>, (<span class="keyword">byte</span>)<span class="number">0xD3</span>, (<span class="keyword">byte</span>)<span class="number">0x34</span>, (<span class="keyword">byte</span>)<span class="number">0xFD</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x7C</span>, (<span class="keyword">byte</span>)<span class="number">0x17</span>, (<span class="keyword">byte</span>)<span class="number">0x57</span>, (<span class="keyword">byte</span>)<span class="number">0x43</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xA3</span>, (<span class="keyword">byte</span>)<span class="number">0x1D</span>, (<span class="keyword">byte</span>)<span class="number">0x18</span>, (<span class="keyword">byte</span>)<span class="number">0x6C</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xDE</span>, (<span class="keyword">byte</span>)<span class="number">0x33</span>, (<span class="keyword">byte</span>)<span class="number">0x21</span>, (<span class="keyword">byte</span>)<span class="number">0x2C</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xB5</span>, (<span class="keyword">byte</span>)<span class="number">0x2A</span>, (<span class="keyword">byte</span>)<span class="number">0xFF</span>, (<span class="keyword">byte</span>)<span class="number">0x3C</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xE1</span>, (<span class="keyword">byte</span>)<span class="number">0xB1</span>, (<span class="keyword">byte</span>)<span class="number">0x29</span>, (<span class="keyword">byte</span>)<span class="number">0x40</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x18</span>, (<span class="keyword">byte</span>)<span class="number">0x11</span>, (<span class="keyword">byte</span>)<span class="number">0x8D</span>, (<span class="keyword">byte</span>)<span class="number">0x7C</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x84</span>, (<span class="keyword">byte</span>)<span class="number">0xA7</span>, (<span class="keyword">byte</span>)<span class="number">0x0A</span>, (<span class="keyword">byte</span>)<span class="number">0x72</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xD6</span>, (<span class="keyword">byte</span>)<span class="number">0x86</span>, (<span class="keyword">byte</span>)<span class="number">0xC4</span>, (<span class="keyword">byte</span>)<span class="number">0x03</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x19</span>, (<span class="keyword">byte</span>)<span class="number">0xC8</span>, (<span class="keyword">byte</span>)<span class="number">0x07</span>, (<span class="keyword">byte</span>)<span class="number">0x29</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x7A</span>, (<span class="keyword">byte</span>)<span class="number">0xCA</span>, (<span class="keyword">byte</span>)<span class="number">0x95</span>, (<span class="keyword">byte</span>)<span class="number">0x0C</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xD9</span>, (<span class="keyword">byte</span>)<span class="number">0x96</span>, (<span class="keyword">byte</span>)<span class="number">0x9F</span>, (<span class="keyword">byte</span>)<span class="number">0xAB</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xD0</span>, (<span class="keyword">byte</span>)<span class="number">0x0A</span>, (<span class="keyword">byte</span>)<span class="number">0x50</span>, (<span class="keyword">byte</span>)<span class="number">0x9B</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x02</span>, (<span class="keyword">byte</span>)<span class="number">0x46</span>, (<span class="keyword">byte</span>)<span class="number">0xD3</span>, (<span class="keyword">byte</span>)<span class="number">0x08</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x3D</span>, (<span class="keyword">byte</span>)<span class="number">0x66</span>, (<span class="keyword">byte</span>)<span class="number">0xA4</span>, (<span class="keyword">byte</span>)<span class="number">0x5D</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x41</span>, (<span class="keyword">byte</span>)<span class="number">0x9F</span>, (<span class="keyword">byte</span>)<span class="number">0x9C</span>, (<span class="keyword">byte</span>)<span class="number">0x7C</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xBD</span>, (<span class="keyword">byte</span>)<span class="number">0x89</span>, (<span class="keyword">byte</span>)<span class="number">0x4B</span>, (<span class="keyword">byte</span>)<span class="number">0x22</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0x19</span>, (<span class="keyword">byte</span>)<span class="number">0x26</span>, (<span class="keyword">byte</span>)<span class="number">0xBA</span>, (<span class="keyword">byte</span>)<span class="number">0xAB</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xA2</span>, (<span class="keyword">byte</span>)<span class="number">0x5E</span>, (<span class="keyword">byte</span>)<span class="number">0xC3</span>, (<span class="keyword">byte</span>)<span class="number">0x55</span>,</span><br><span class="line">        (<span class="keyword">byte</span>)<span class="number">0xE9</span>, (<span class="keyword">byte</span>)<span class="number">0x2F</span>, (<span class="keyword">byte</span>)<span class="number">0x78</span>, (<span class="keyword">byte</span>)<span class="number">0xC7</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The SKIP 1024 bit modulus</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BigInteger skip1024Modulus</span><br><span class="line">    = <span class="keyword">new</span> BigInteger(<span class="number">1</span>, skip1024ModulusBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The base used with the SKIP 1024 bit modulus</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BigInteger skip1024Base = BigInteger.valueOf(<span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line">Blowfish Cipher Example</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 1997, 2001, Oracle and/or its affiliates. All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Redistribution and use in source and binary forms, with or without</span></span><br><span class="line"><span class="comment"> * modification, are permitted provided that the following conditions</span></span><br><span class="line"><span class="comment"> * are met:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   - Redistributions of source code must retain the above copyright</span></span><br><span class="line"><span class="comment"> *     notice, this list of conditions and the following disclaimer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   - Redistributions in binary form must reproduce the above copyright</span></span><br><span class="line"><span class="comment"> *     notice, this list of conditions and the following disclaimer in the</span></span><br><span class="line"><span class="comment"> *     documentation and/or other materials provided with the distribution.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   - Neither the name of Oracle nor the names of its</span></span><br><span class="line"><span class="comment"> *     contributors may be used to endorse or promote products derived</span></span><br><span class="line"><span class="comment"> *     from this software without specific prior written permission.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS</span></span><br><span class="line"><span class="comment"> * IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,</span></span><br><span class="line"><span class="comment"> * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</span></span><br><span class="line"><span class="comment"> * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR</span></span><br><span class="line"><span class="comment"> * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span></span><br><span class="line"><span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,</span></span><br><span class="line"><span class="comment"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</span></span><br><span class="line"><span class="comment"> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span></span><br><span class="line"><span class="comment"> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span></span><br><span class="line"><span class="comment"> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span></span><br><span class="line"><span class="comment"> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program generates a Blowfish key, retrieves its raw bytes, and</span></span><br><span class="line"><span class="comment"> * then reinstantiates a Blowfish key from the key bytes.</span></span><br><span class="line"><span class="comment"> * The reinstantiated key is used to initialize a Blowfish cipher for</span></span><br><span class="line"><span class="comment"> * encryption.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlowfishKey</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        KeyGenerator kgen = KeyGenerator.getInstance(<span class="string">&quot;Blowfish&quot;</span>);</span><br><span class="line">        SecretKey skey = kgen.generateKey();</span><br><span class="line">        <span class="keyword">byte</span>[] raw = skey.getEncoded();</span><br><span class="line">        SecretKeySpec skeySpec = <span class="keyword">new</span> SecretKeySpec(raw, <span class="string">&quot;Blowfish&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;Blowfish&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);</span><br><span class="line">        <span class="keyword">byte</span>[] encrypted =</span><br><span class="line">            cipher.doFinal(<span class="string">&quot;This is just an example&quot;</span>.getBytes());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>HMAC-MD5 Example</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 1997, 2001, Oracle and/or its affiliates. All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Redistribution and use in source and binary forms, with or without</span></span><br><span class="line"><span class="comment"> * modification, are permitted provided that the following conditions</span></span><br><span class="line"><span class="comment"> * are met:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   - Redistributions of source code must retain the above copyright</span></span><br><span class="line"><span class="comment"> *     notice, this list of conditions and the following disclaimer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   - Redistributions in binary form must reproduce the above copyright</span></span><br><span class="line"><span class="comment"> *     notice, this list of conditions and the following disclaimer in the</span></span><br><span class="line"><span class="comment"> *     documentation and/or other materials provided with the distribution.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   - Neither the name of Oracle nor the names of its</span></span><br><span class="line"><span class="comment"> *     contributors may be used to endorse or promote products derived</span></span><br><span class="line"><span class="comment"> *     from this software without specific prior written permission.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS</span></span><br><span class="line"><span class="comment"> * IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,</span></span><br><span class="line"><span class="comment"> * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</span></span><br><span class="line"><span class="comment"> * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR</span></span><br><span class="line"><span class="comment"> * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span></span><br><span class="line"><span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,</span></span><br><span class="line"><span class="comment"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</span></span><br><span class="line"><span class="comment"> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span></span><br><span class="line"><span class="comment"> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span></span><br><span class="line"><span class="comment"> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span></span><br><span class="line"><span class="comment"> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates how to generate a secret-key object for</span></span><br><span class="line"><span class="comment"> * HMAC-MD5, and initialize an HMAC-MD5 object with it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">initMac</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate secret key for HMAC-MD5</span></span><br><span class="line">        KeyGenerator kg = KeyGenerator.getInstance(<span class="string">&quot;HmacMD5&quot;</span>);</span><br><span class="line">        SecretKey sk = kg.generateKey();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get instance of Mac object implementing HMAC-MD5, and</span></span><br><span class="line">        <span class="comment">// initialize it with the above secret key</span></span><br><span class="line">        Mac mac = Mac.getInstance(<span class="string">&quot;HmacMD5&quot;</span>);</span><br><span class="line">        mac.init(sk);</span><br><span class="line">        <span class="keyword">byte</span>[] result = mac.doFinal(<span class="string">&quot;Hi There&quot;</span>.getBytes());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">Reading ASCII Passwords From an InputStream Example</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @(#)ReadPassword.java  1.1 06/06/07</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.</span></span><br><span class="line"><span class="comment"> * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadPassword</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read a password from the InputStream &quot;in&quot;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * As Strings are immutable, passwords should be stored as an array</span></span><br><span class="line"><span class="comment">     * of characters, which can be blanked out when no longer needed.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * If the provided InputStream is the System&apos;s Console, this method</span></span><br><span class="line"><span class="comment">     * uses the non-echoing readPassword() method of java.io.Console</span></span><br><span class="line"><span class="comment">     * (new to JDK 6).  If not, a fallback implementation is used.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">NOTE:</span>  For expository purposes, and because some applications do</span></span><br><span class="line"><span class="comment">     * not understand multi-byte characters, only 8-bit ASCII passwords</span></span><br><span class="line"><span class="comment">     * are handled here.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">NOTE:</span>  If a SecurityManager is used, the default standard</span></span><br><span class="line"><span class="comment">     * java.policy file found in the JDK (i.e.</span></span><br><span class="line"><span class="comment">     * &lt;java-home&gt;/lib/security/java.policy) allows reading the</span></span><br><span class="line"><span class="comment">     * line.separator property.  If your environment is different, this</span></span><br><span class="line"><span class="comment">     * code will need to be granted the appropriate privilege.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   in</span></span><br><span class="line"><span class="comment">     *          the InputStream used to obtain the password.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  A character array containing the password or passphrase,</span></span><br><span class="line"><span class="comment">     *          not including the line-termination characters,</span></span><br><span class="line"><span class="comment">     *          or null if an end of stream has been reached.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IOException</span></span><br><span class="line"><span class="comment">     *          if an I/O problem occurs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] readPassword(InputStream in)</span><br><span class="line">            <span class="keyword">throws</span> IOException {</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If available, directly use the java.io.Console class to</span></span><br><span class="line"><span class="comment">         * avoid character echoing.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (in == System.in &amp;&amp; System.console() != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// readPassword returns &quot;&quot; if you just print ENTER,</span></span><br><span class="line">            <span class="keyword">return</span> System.console().readPassword();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If a console is not available, read the InputStream</span></span><br><span class="line"><span class="comment">         * directly.  This approach may cause password echoing.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Since different operating systems have different End-Of-Line</span></span><br><span class="line"><span class="comment">         * (EOL) sequences, this algorithm should allow for</span></span><br><span class="line"><span class="comment">         * platform-independent implementations.  Typical EOL sequences</span></span><br><span class="line"><span class="comment">         * are a single line feed (&apos;\n&apos;), or a carriage return/linefeed</span></span><br><span class="line"><span class="comment">         * combination (&apos;\r\n&apos;).  However, some OS&apos;s use a single</span></span><br><span class="line"><span class="comment">         * a carriage return (&apos;\r&apos;), which complicates portability.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Since we may not have the ability to push bytes back into the</span></span><br><span class="line"><span class="comment">         * InputStream, another approach is used here.  The javadoc for</span></span><br><span class="line"><span class="comment">         * &lt;code&gt;java.lang.System.getProperties()&lt;/code&gt; specifies that</span></span><br><span class="line"><span class="comment">         * the set of system properties will contain a system-specific</span></span><br><span class="line"><span class="comment">         * value for the &quot;line.separator&quot;.  Scan for this character</span></span><br><span class="line"><span class="comment">         * sequence instead of hard-coding a particular sequence.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Enclose the getProperty in a doPrivileged block to minimize</span></span><br><span class="line"><span class="comment">         * the call stack permission required.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">char</span> [] EOL = AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;<span class="keyword">char</span>[]&gt;() {</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">char</span>[] run() {</span><br><span class="line">                    String s = System.getProperty(<span class="string">&quot;line.separator&quot;</span>);</span><br><span class="line">                    <span class="comment">// Shouldn&apos;t happen.</span></span><br><span class="line">                    <span class="keyword">if</span> (s == <span class="keyword">null</span>) {</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                            <span class="string">&quot;line.separator not defined&quot;</span>);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">return</span> s.toCharArray();</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> [] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;                <span class="comment">// len of data in buffer.</span></span><br><span class="line">            <span class="keyword">boolean</span> done = <span class="keyword">false</span>;       <span class="comment">// found the EOL sequence</span></span><br><span class="line">            <span class="keyword">int</span> b;                      <span class="comment">// byte read</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!done) {</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * realloc if necessary</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (len &gt;= buffer.length) {</span><br><span class="line">                    <span class="keyword">char</span> [] newbuffer = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">128</span>];</span><br><span class="line">                    System.arraycopy(buffer, <span class="number">0</span>, newbuffer, <span class="number">0</span>, len);</span><br><span class="line">                    Arrays.fill(buffer, <span class="string">&apos; &apos;</span>);</span><br><span class="line">                    buffer = newbuffer;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * End-of-Stream?</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> ((b = in.read()) == -<span class="number">1</span>) {</span><br><span class="line">                    <span class="comment">// Return as much as we have, null otherwise.</span></span><br><span class="line">                    <span class="keyword">if</span> (len == <span class="number">0</span>) {</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">NOTE:</span>  In the simple PBE example here,</span></span><br><span class="line"><span class="comment">                     * only 8 bit ASCII characters are handled.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    buffer[len++] = (<span class="keyword">char</span>) b;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * check for the EOL sequence.  Do we have enough bytes?</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (len &gt;= EOL.length) {</span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; EOL.length; i++) {</span><br><span class="line">                        <span class="keyword">if</span> (buffer[len - EOL.length + i] != EOL[i]) {</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    done = (i == EOL.length);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * If we found the EOL, strip the EOL chars.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">char</span> [] result = <span class="keyword">new</span> <span class="keyword">char</span>[done ? len - EOL.length : len];</span><br><span class="line">            System.arraycopy(buffer, <span class="number">0</span>, result, <span class="number">0</span>, result.length);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Zero out the buffer.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (buffer != <span class="keyword">null</span>) {</span><br><span class="line">                Arrays.fill(buffer, <span class="string">&apos; &apos;</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>

                        
                    </div>

                    
                    
                    

                    <div class="description post-description">
    <span class="post-description-item">
        <time datetime="2017-06-29T16:22:34.000Z" itemprop="datePublished">2017-06-30</time>

    </span>
    <span class="post-description-item">
        

    <span>
        <i class="tags icon"></i>
    </span>

    
    <span class="ui tiny label">
        <a href="/tags/security/">security</a>
    </span>

    
    <span class="ui tiny label">
        <a href="/tags/jca/">jca</a>
    </span>

    

    </span>
</div>

                </div>
                
                <div id="pagination" class="nav-web ui text container pagination">

    <div class="ui stackable two column divided grid container">
        <div class="row">
            <div class="column nav-left">
                

                <a href="/2017/07/06/tomcat双向认证/" class="ui tiny button">

                    <i class="angle left icon"></i>
                    
                    tomcat双向认证
                    

                </a>

                
            </div>
            <div class="column nav-right">
                

                <a href="/2017/06/29/java-安全体系/" class="ui tiny button">
                    
                    java 安全体系
                    
                    <i class="angle right icon"></i></a>
                
            </div>
        </div>
    </div>

</div>
                
            </div>

            
            <div class="three wide computer three wide tablet column">

                <div class="ui sticky article-toc" id="article-toc">
                    <!-- toc -->
                    <ol class="ui ordered list"><li><a href="#undefined"><span>介绍</span></a></li><li><a href="#undefined"><span>设计原则</span></a></li><li><a href="#undefined"><span>架构</span></a><ol><li><a href="#undefined"><span>加密服务提供者</span></a></li><li><a href="#undefined"><span>How Providers Are Actually Implemented</span></a></li><li><a href="#undefined"><span>Key Management</span></a></li></ol></li><li><a href="#undefined"><span>JCA 概念</span></a><ol><li><a href="#undefined"><span>引擎类和算法</span></a></li><li><a href="#undefined"><span>核心的类和接口</span></a></li><li><a href="#undefined"><span>提供者类</span></a></li><li><a href="#undefined"><span>How Provider Implementations Are Requested and Supplied</span></a></li><li><a href="#undefined"><span>安装 Providers</span></a><ol><li><a href="#undefined"><span>安装 Provider Classes</span></a></li><li><a href="#undefined"><span>注册 Provider</span></a></li><li><a href="#undefined"><span>Static Registration</span></a></li><li><a href="#undefined"><span>Dynamic Registration</span></a></li><li><a href="#undefined"><span>Provider Class Methods</span></a></li><li><a href="#undefined"><span>The Security Class</span></a></li></ol></li><li><a href="#undefined"><span>Managing Providers</span></a><ol><li><a href="#undefined"><span>Querying Providers</span></a></li><li><a href="#undefined"><span>Security Properties</span></a></li></ol></li><li><a href="#undefined"><span>The SecureRandom Class</span></a><ol><li><a href="#undefined"><span>创建一个安全随机数生成器对象</span></a></li><li><a href="#undefined"><span>Seeding or Re-Seeding the SecureRandom Object</span></a></li><li><a href="#undefined"><span>Using a SecureRandom Object</span></a></li><li><a href="#undefined"><span>Generating Seed Bytes</span></a></li></ol></li><li><a href="#undefined"><span>The MessageDigest Class</span></a><ol><li><a href="#undefined"><span>创建一个消息签名对象</span></a></li><li><a href="#undefined"><span>更新消息签名对象</span></a></li><li><a href="#undefined"><span>计算签名</span></a></li></ol></li><li><a href="#undefined"><span>The Signature Class</span></a><ol><li><a href="#undefined"><span>Signature Object States</span></a></li><li><a href="#undefined"><span>Initializing a Signature Object</span></a></li><li><a href="#undefined"><span>Signing</span></a></li><li><a href="#undefined"><span>Verifying</span></a></li></ol></li><li><a href="#undefined"><span>The Cipher Class</span></a><ol><li><a href="#undefined"><span>Symmetric vs. Asymmetric Cryptography</span></a></li><li><a href="#undefined"><span>Stream vs. Block Ciphers</span></a></li><li><a href="#undefined"><span>工作模式</span></a></li><li><a href="#undefined"><span>Using an AES Cipher with GCM Mode</span></a></li><li><a href="#undefined"><span>Creating a Cipher Object</span></a></li><li><a href="#undefined"><span>Initializing a Cipher Object</span></a></li><li><a href="#undefined"><span>加密和解密数据</span></a></li><li><a href="#undefined"><span>包装和解包密钥</span></a></li><li><a href="#undefined"><span>管理算法参数</span></a></li><li><a href="#undefined"><span>Cipher Output Considerations</span></a></li><li><a href="#undefined"><span>Other Cipher-based Classes</span></a><ol><li><a href="#undefined"><span>The Cipher Stream Classes</span></a></li></ol></li><li><a href="#undefined"><span>The CipherOutputStream Class</span></a></li></ol></li><li><a href="#undefined"><span>The SealedObject Class</span></a></li></ol></li></ol>
                </div>

            </div>
            

        </div>
    </div>
</div>

            </div>
            <div class="ui vertical footer segment">
    <div class="ui center aligned container">
        <div class="ui inverted section divider"></div>
        &copy; 2018 <a href="/">YFHan</a>,
        Powered by <a href="https://github.com/henryhuang/hexo-theme-aloha" target="_blank">Aloha</a> and <a
                href="http://hexo.io/" target="_blank">Hexo</a>.
    </div>
</div>

        </div>

    
        
            <script src="//cdn.bootcss.com/jquery/3.1.0/jquery.min.js"></script>
        
            <script src="//cdn.bootcss.com/semantic-ui/2.2.4/semantic.min.js"></script>
        
            <script src="/js/aloha-events.js"></script>
        
    

</body>
</html>
