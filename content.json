{"meta":{"title":"YFHan的博客","subtitle":null,"description":"JUST DO IT","author":"YFHan","url":"https://yyhan.github.io"},"pages":[{"title":"","date":"2017-06-18T12:36:14.688Z","updated":"2016-12-11T15:46:00.022Z","comments":true,"path":"404.html","permalink":"https://yyhan.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2016-12-12T04:20:37.000Z","updated":"2016-12-12T04:30:56.901Z","comments":true,"path":"about/index.html","permalink":"https://yyhan.github.io/about/index.html","excerpt":"","text":"&#x5C0F;&#x5929;&#xFF0C;&#x65E0;&#x77E5;&#x7684;&#x7801;&#x519C; &lt;p&gt;&lt;i class=&quot;fa fa-github&quot;&gt;&lt;/i&gt; Github: &lt;a href=&quot;https://github.com/yyhan&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@yyhan&lt;/a&gt;&lt;/p&gt;"}],"posts":[{"title":"npm 常用命令","slug":"npm-常用命令","date":"2017-12-03T09:23:04.000Z","updated":"2017-12-03T09:40:03.380Z","comments":true,"path":"2017/12/03/npm-常用命令/","link":"","permalink":"https://yyhan.github.io/2017/12/03/npm-常用命令/","excerpt":"","text":"&#x5168;&#x5C40;&#x6A21;&#x5757; &#x5168;&#x5C40;&#x5B89;&#x88C5;&#x6A21;&#x5757;&#xFF1A; npm install -g &lt;&#x6A21;&#x5757;&#x540D;&gt; &#x66F4;&#x65B0;&#x5168;&#x5C40;&#x5B89;&#x88C5;&#x7684;&#x6A21;&#x5757;&#xFF1A; npm update -g &lt;&#x6A21;&#x5757;&#x540D;&gt; &#x5378;&#x8F7D;&#x5168;&#x5C40;&#x5B89;&#x88C5;&#x7684;&#x6A21;&#x5757;&#xFF1A; npm uninstall -g &lt;&#x6A21;&#x5757;&#x540D;&gt; &#x5E38;&#x89C1;&#x95EE;&#x9898; &#x66F4;&#x65B0;npm&#x7248;&#x672C; &#x901A;&#x8FC7;&#x91CD;&#x65B0;&#x5B89;&#x88C5;npm&#x6765;&#x5347;&#x7EA7;npm&#x81EA;&#x8EAB;&#x7248;&#x672C; 1npm install -g npm npm&#x6307;&#x4EE4;&#x7F29;&#x5199; -v: --version -h, -?, --help, -H: --usage -s, --silent: --loglevel silent -q, --quiet: --loglevel warn -d: --loglevel info -dd, --verbose: --loglevel verbose -ddd: --loglevel silly -g: --global -C: --prefix -l: --long -m: --message -p, --porcelain: --parseable -reg: --registry -f: --force -desc: --description -S: --save -P: --save-prod -D: --save-dev -O: --save-optional -B: --save-bundle -E: --save-exact -y: --yes -n: --yes false ll and la commands: ls --long","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"https://yyhan.github.io/tags/npm/"}]},{"title":"jQuery DataTables 插件","slug":"jQuery-DataTables-插件","date":"2017-08-09T14:34:09.000Z","updated":"2017-08-12T17:24:31.550Z","comments":true,"path":"2017/08/09/jQuery-DataTables-插件/","link":"","permalink":"https://yyhan.github.io/2017/08/09/jQuery-DataTables-插件/","excerpt":"","text":"&#x7B80;&#x4ECB; Datatables&#x662F;&#x4E00;&#x6B3E;jquery&#x8868;&#x683C;&#x63D2;&#x4EF6;&#x3002;&#x5B83;&#x662F;&#x4E00;&#x4E2A;&#x9AD8;&#x5EA6;&#x7075;&#x6D3B;&#x7684;&#x5DE5;&#x5177;&#xFF0C;&#x53EF;&#x4EE5;&#x5C06;&#x4EFB;&#x4F55;HTML&#x8868;&#x683C;&#x6DFB;&#x52A0;&#x9AD8;&#x7EA7;&#x7684;&#x4EA4;&#x4E92;&#x529F;&#x80FD;&#x3002; &#x5B98;&#x7F51; Datatables&#x4E2D;&#x6587;&#x7F51; &#x7279;&#x6027;&#xFF1A; &#x5206;&#x9875;&#xFF0C;&#x5373;&#x65F6;&#x641C;&#x7D22;&#x548C;&#x6392;&#x5E8F; &#x51E0;&#x4E4E;&#x652F;&#x6301;&#x4EFB;&#x4F55;&#x6570;&#x636E;&#x6E90;&#xFF1A;DOM&#xFF0C; javascript&#xFF0C; Ajax &#x548C; &#x670D;&#x52A1;&#x5668;&#x5904;&#x7406; &#x652F;&#x6301;&#x4E0D;&#x540C;&#x4E3B;&#x9898; DataTables, jQuery UI, Bootstrap, Foundation &#x5404;&#x5F0F;&#x5404;&#x6837;&#x7684;&#x6269;&#x5C55;: Editor, TableTools, FixedColumns &#x2026;&#x2026; &#x4E30;&#x5BCC;&#x591A;&#x6837;&#x7684;option&#x548C;&#x5F3A;&#x5927;&#x7684;API &#x652F;&#x6301;&#x56FD;&#x9645;&#x5316; &#x8D85;&#x8FC7;2900+&#x4E2A;&#x5355;&#x5143;&#x6D4B;&#x8BD5; &#x514D;&#x8D39;&#x5F00;&#x6E90; &#xFF08; MIT license &#xFF09;&#xFF01; &#x5546;&#x4E1A;&#x652F;&#x6301; &#x66F4;&#x591A;&#x7279;&#x6027;&#x8BF7;&#x5230;&#x5B98;&#x7F51;&#x67E5;&#x770B; &#x914D;&#x7F6E; html &#x914D;&#x7F6E;&#x6A21;&#x677F; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;!-- Bootstrap --&gt;&lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;!-- &#x5F15;&#x5165;dataTables&#x63D2;&#x4EF6;&#x9ED8;&#x8BA4;&#x6837;&#x5F0F;&#xFF0C;&#x5982;&#x679C;&#x4F7F;&#x7528;&#x4E86;&#x4E3B;&#x9898;&#x6837;&#x5F0F;&#xFF0C;&#x5C31;&#x4E0D;&#x9700;&#x8981;&#x5F15;&#x5165;&#x9ED8;&#x8BA4;&#x6837;&#x5F0F;&#x4E86; --&gt;&lt;!-- &lt;link href=&quot;https://cdn.bootcss.com/datatables/1.10.15/css/jquery.dataTables.min.css&quot; rel=&quot;stylesheet&quot;&gt; --&gt;&lt;!-- &#x5F15;&#x5165;bootstrap&#x4E3B;&#x9898;css --&gt;&lt;link href=&quot;https://cdn.bootcss.com/datatables/1.10.15/css/dataTables.bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;!-- &#x5F15;&#x5165;jQuery&#x4F9D;&#x8D56; --&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;!-- &#x5F15;&#x5165;dataTables &#x63D2;&#x4EF6; --&gt;&lt;script src=&quot;https://cdn.bootcss.com/datatables/1.10.15/js/jquery.dataTables.min.js&quot;&gt;&lt;/script&gt;&lt;!-- &#x5F15;&#x5165;bootstrap&#x4E3B;&#x9898;js --&gt;&lt;script src=&quot;https://cdn.bootcss.com/datatables/1.10.15/js/dataTables.bootstrap.js&quot;&gt;&lt;/script&gt;&lt;!-- &#x5B9A;&#x4E49;&#x4E00;&#x4E2A;&#x666E;&#x901A;&#x7684;table&#x5143;&#x7D20; --&gt;&lt;table id=&quot;dtTable&quot; class=&quot;table table-striped&quot;&gt;&lt;/table&gt;&lt;script type=&quot;text/javascript&quot;&gt; /** * &#x6839;&#x636E;&#x4E2A;&#x4EBA;&#x7ECF;&#x9A8C;&#x603B;&#x7ED3;&#x7684;&#x5DE5;&#x4F5C;&#x4E2D;&#x5E38;&#x7528;&#x7684;&#x914D;&#x7F6E;&#xFF0C;&#x80FD;&#x591F;&#x6EE1;&#x8DB3;&#x591A;&#x6570;&#x60C5;&#x51B5;&#x3002; **/ var $dtTable = $(&quot;#dtTable&quot;).DataTable({ serverSide: true, // &#x5F00;&#x542F;&#x670D;&#x52A1;&#x7AEF;&#x5904;&#x7406; stateSave: false, // &#x5173;&#x95ED;&#x72B6;&#x6001;&#x4FDD;&#x5B58; dom: &apos;&lt;&quot;row&quot; &lt;&quot;col-md-12&quot; t&gt;&gt;&lt;&quot;row&quot; &lt;&quot;col-md-6&quot; i&gt;&lt;&quot;col-md-6&quot; p&gt;&gt;&apos;, pageLength: 10, // &#x6BCF;&#x9875;&#x5BB9;&#x91CF; ordering: true, // &#x662F;&#x5426;&#x5F00;&#x542F;&#x6392;&#x5E8F;&#xFF0C;&#x9ED8;&#x8BA4;true // &#x5EF6;&#x8FDF;&#x8BF7;&#x6C42;&#x52A0;&#x8F7D;&#x670D;&#x52A1;&#x7AEF;&#x7684;&#x6570;&#x636E;&#xFF0C;&#x76F4;&#x5230;&#x8868;&#x683C;&#x7B2C;&#x4E8C;&#x6B21;&#x7ED8;&#x5236; (http://www.datatables.club/reference/option/deferLoading.html) // &#x5982;&#x679C;&#x4E0D;&#x914D;&#x7F6E;&#x7684;&#x8BDD;&#xFF0C;datatables&#x4F1A;&#x5728;&#x521D;&#x59CB;&#x5316;&#x65F6;&#x53BB;&#x52A0;&#x8F7D;&#x6570;&#x636E;&#xFF0C;&#x6B64;&#x65F6;&#x6574;&#x4E2A;&#x9875;&#x9762;&#x53EF;&#x80FD;&#x5C1A;&#x672A;&#x5168;&#x90E8;&#x52A0;&#x8F7D;&#x5B8C;&#xFF0C;&#x67D0;&#x4E9B;&#x573A;&#x666F;&#x4E0B;&#x53EF;&#x80FD;&#x4F1A;&#x51FA;&#x73B0;&#x5F02;&#x5E38;&#x3002; deferLoading: 0, ajax: function (params, callback, obj) { var reqParams = { draw: params.draw, length: params.length, start: params.start, orderField: params.columns[params.order[0].column].name, // &#x6392;&#x5E8F;&#x5B57;&#x6BB5; orderDir: params.order[0].dir // &#x6392;&#x5E8F;&#x65B9;&#x5411; } // &#x5982;&#x679C;&#x9700;&#x8981;&#x5176;&#x5B83;&#x67E5;&#x8BE2;&#x53C2;&#x6570;&#x7684;&#xFF0C;&#x8BF7;&#x9644;&#x52A0;&#x5728;reqParams&#x4E2D;&#x3002; $.post(&quot;/example/datatables/ajax.htm&quot;, reqParams, function(res, status, xhr) { if (res.success) { callback(res); } else { callback({ data: [], draw: params.draw, recordsFiltered: 0, recordsTotal: 0 }); alert(res.message); } }, &apos;json&apos;); }, order: [ [0, &apos;desc&apos;] ], // &#x5217;&#x7ED1;&#x5B9A;&#xFF0C;&#x901A;&#x8FC7;data&#x548C;&#x6570;&#x636E;&#x91CC;&#x7684;&#x5C5E;&#x6027;&#x7ED1;&#x5B9A; columns: [ {name: &quot;id&quot;, data: &quot;id&quot;, title: &quot;id&quot;}, {name: &quot;name&quot;, data: &quot;name&quot;, title: &quot;&#x59D3;&#x540D;&quot;, orderable: false}, { name: &quot;sex&quot;, data: &quot;sex&quot;, title: &quot;&#x6027;&#x522B;&quot;, render: function(data, type, row, meta) { // &#x5982;&#x679C;&#x672A;&#x6307;&#x5B9A; &#x201C; data: &apos;sex&apos; &#x201D;&#xFF0C;&#x8FD9;&#x91CC;&#x7684;data&#x53C2;&#x6570;&#x5C06;&#x4F1A;&#x662F; undefined // row&#xFF1A;&#x670D;&#x52A1;&#x7AEF;&#x8FD4;&#x56DE;&#x7684;&#x884C;&#x6570;&#x636E; // meta&#xFF1A;{col: &quot;&#x5217;&#x53F7;&#xFF0C;&#x4ECE;0&#x5F00;&#x59CB;&quot;, row: &quot;&#x884C;&#x53F7;&#xFF0C;&#x4ECE;0&#x5F00;&#x59CB;&quot;, settings: &quot;datatables&#x914D;&#x7F6E;&quot;} if (data == &quot;MAN&quot;) { return &quot;&#x7537;&quot;; } else if (data == &quot;WOMAN&quot;) { return &quot;&#x5973;&quot;; } else { return &quot;&#x592A;&#x76D1;&quot;; } } }, { title: &quot;&#x64CD;&#x4F5C;&quot;, orderable: false, render: function(data, type, row, meta) { return &apos;&lt;button class=&quot;btn btn-sm btn-success js-update-btn&quot;&gt;&#x7F16;&#x8F91;&lt;/button&gt;&apos; + &apos; &lt;button class=&quot;btn btn-sm btn-warning js-delete-btn&quot;&gt;&#x5220;&#x9664;&lt;/button&gt;&apos;; } } ], language: { sEmptyTable: &quot;&#x6682;&#x65E0;&#x6570;&#x636E;...&quot;, sInfo: &quot;_START_ &#x5230; _END_, &#x603B;&#x5171; _TOTAL_ &#x6761;&#x8BB0;&#x5F55;&quot;, sInfoEmpty: &quot;0 &#x5230; 0 &#x603B;&#x5171; 0 &#x6761;&#x8BB0;&#x5F55;&quot;, sInfoFiltered: &quot;(&#x603B;&#x5171; _MAX_ &#x6761;&#x8BB0;&#x5F55;)&quot;, sInfoPostFix: &quot;&quot;, sInfoThousands: &quot;.&quot;, sLengthMenu: &quot;_MENU_ &#x6761; / &#x6BCF;&#x9875;&quot;, sLoadingRecords: &quot;&#x6B63;&#x5728;&#x52A0;&#x8F7D;&#x4E2D;...&quot;, sProcessing: &quot;&#x6B63;&#x5728;&#x52A0;&#x8F7D;&#x4E2D;...&quot;, sSearch: &quot;&#x641C;&#x7D22;&quot;, sZeroRecords: &quot;&#x672A;&#x627E;&#x5230;&#x4EFB;&#x4F55;&#x76F8;&#x5173;&#x8BB0;&#x5F55;.&quot;, oPaginate: { sFirst: &quot;&#x9996;&#x9875;&quot;, sPrevious: &quot;&#x4E0A;&#x4E00;&#x9875;&quot;, sNext: &quot;&#x4E0B;&#x4E00;&#x9875;&quot;, sLast: &quot;&#x6700;&#x540E;&#x4E00;&#x9875;&quot; } }, initComplete: function(settings, json) { // &#x8868;&#x683C;&#x521D;&#x59CB;&#x5316;&#x5B8C;&#x6210;&#x65F6;&#x56DE;&#x8C03; console.log( &apos;DataTables has finished its initialisation.&apos; ); }, drawCallback: function(settings){ // &#x8868;&#x683C;&#x7ED8;&#x5236;&#x5B8C;&#x6210;&#x65F6;&#x56DE;&#x8C03; console.log(&quot;draw finish&quot;); } }); $(&quot;#dtTable&quot;).on(&quot;click&quot;, &quot;.js-update-btn&quot;, function(){ var tr = $(this).parent().parent(); var row = $dtTable.row(tr); // &#x83B7;&#x53D6;&#x884C;&#x6570;&#x636E; console.log(row); }); // &#x5982;&#x679C;&#x914D;&#x7F6E;&#x4E86; deferLoading&#xFF0C;&#x8FD9;&#x91CC;&#x9700;&#x8981;&#x6839;&#x636E;&#x9700;&#x8981;&#x624B;&#x52A8;&#x52A0;&#x8F7D;&#x4E00;&#x6B21;&#x6570;&#x636E;&#x3002; $dtTable.draw();//&#x624B;&#x52A8;&#x6E32;&#x67D3;&#x6570;&#x636E;&lt;/script&gt; java &#x8BF7;&#x6C42;&#x5B9E;&#x4F53;&#xFF0C;&#x8FD9;&#x91CC;&#x53EA;&#x662F;&#x7B80;&#x5355;&#x5C01;&#x88C5;&#x4E86;&#x5206;&#x9875;&#x548C;&#x6392;&#x5E8F;&#x53C2;&#x6570;&#x3002; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * jQuery DataTables &#x63D2;&#x4EF6;&#x8BF7;&#x6C42;&#x5B9E;&#x4F53; * * @see &lt;a href=&quot;https://datatables.net/&quot;&gt;DataTables&lt;/a&gt; */public class DTRequest { /** * &#x91CD;&#x7ED8;&#x6B21;&#x6570;&#xFF08;&#x63D2;&#x4EF6;&#x6807;&#x51C6;&#x5B57;&#x6BB5;&#xFF09; */ private Integer draw; /** * &#x6570;&#x636E;&#x8D77;&#x59CB;&#x4F4D;&#x7F6E;&#xFF0C;&#x4ECE;0&#x5F00;&#x59CB;&#xFF08;&#x63D2;&#x4EF6;&#x6807;&#x51C6;&#x5B57;&#x6BB5;&#xFF09; */ private Integer start; /** * &#x9700;&#x8981;&#x7684;&#x6570;&#x636E;&#x6761;&#x6570;&#xFF0C;&#x5373;&#x6BCF;&#x9875;&#x5BB9;&#x91CF;&#xFF08;&#x63D2;&#x4EF6;&#x6807;&#x51C6;&#x5B57;&#x6BB5;&#xFF09; */ private Integer length; private String orderField; // &#x6392;&#x5E8F;&#x5B57;&#x6BB5; private String orderDir; // &#x6392;&#x5E8F;&#x65B9;&#x5411;&#xFF1A;&apos;asc&apos;&#x3001;&apos;desc&apos; public Integer getDraw() { return draw; } public void setDraw(Integer draw) { this.draw = draw; } public Integer getStart() { return start; } public void setStart(Integer start) { this.start = start; } public Integer getLength() { return length; } public void setLength(Integer length) { this.length = length; } public String getOrderField() { return orderField; } public void setOrderField(String orderField) { this.orderField = orderField; } public String getOrderDir() { return orderDir; } public void setOrderDir(String orderDir) { this.orderDir = orderDir; }} java &#x54CD;&#x5E94;&#x5B9E;&#x4F53;&#xFF0C;&#x8FD9;&#x91CC;&#x591A;&#x5C01;&#x88C5;&#x4E86;success&#x548C;message&#x5B57;&#x6BB5;&#xFF0C;&#x7528;&#x4E8E;&#x5224;&#x65AD;&#x8BF7;&#x6C42;&#x662F;&#x5426;&#x6210;&#x529F;&#xFF0C;&#x4EE5;&#x53CA;&#x9519;&#x8BEF;message&#xFF0C;&#x4EE5;&#x63D0;&#x5347;&#x7528;&#x6237;&#x4F53;&#x9A8C;&#x3002;&#x6807;&#x6CE8;&#x63D2;&#x4EF6;&#x6807;&#x51C6;&#x5B57;&#x6BB5;&#x7684;&#x662F;&#x63D2;&#x4EF6;&#x5FC5;&#x987B;&#x7684;&#x5B57;&#x6BB5;&#xFF0C;&#x4E0D;&#x80FD;&#x4E3A;&#x7A7A;&#x3002; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * jQuery DataTables &#x63D2;&#x4EF6;&#x54CD;&#x5E94;&#x5B9E;&#x4F53; * * @see &lt;a href=&quot;https://datatables.net/&quot;&gt;DataTables&lt;/a&gt; */public class DTResponse&lt;T&gt; { private boolean success; private String message; /** * &#x6570;&#x636E;&#xFF08;&#x63D2;&#x4EF6;&#x6807;&#x51C6;&#x5B57;&#x6BB5;&#xFF09;&#x3002; */ private List&lt;T&gt; data; /** * &#x91CD;&#x7ED8;&#x6B21;&#x6570;&#xFF08;&#x63D2;&#x4EF6;&#x6807;&#x51C6;&#x5B57;&#x6BB5;&#xFF09;&#x3002;&#x8BE5;&#x503C;&#x6765;&#x81EA;&#x4E8E; {@link DTRequest#draw } */ private Integer draw; /** * &#x603B;&#x8BB0;&#x5F55;&#x6570;&#xFF08;&#x63D2;&#x4EF6;&#x6807;&#x51C6;&#x5B57;&#x6BB5;&#xFF09; */ private Integer recordsTotal; /** * &#x7B5B;&#x9009;&#x5230;&#x7684;&#x8BB0;&#x5F55;&#x6570;&#xFF08;&#x63D2;&#x4EF6;&#x6807;&#x51C6;&#x5B57;&#x6BB5;&#xFF09; */ private Integer recordsFiltered; public DTResponse() { } public DTResponse(List&lt;T&gt; data, Integer draw, Integer recordsFiltered) { this.success = true; this.data = data; this.recordsFiltered = recordsFiltered; this.recordsTotal = recordsFiltered; } public DTResponse(List&lt;T&gt; data, Integer draw, Integer recordsFiltered, Integer recordsTotal) { this.success = true; this.data = data; this.recordsFiltered = recordsFiltered; this.recordsTotal = recordsTotal; } public boolean isSuccess() { return success; } public void setSuccess(boolean success) { this.success = success; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } public List&lt;T&gt; getData() { return data; } public void setData(List&lt;T&gt; data) { this.data = data; } public Integer getDraw() { return draw; } public void setDraw(Integer draw) { this.draw = draw; } public Integer getRecordsTotal() { return recordsTotal; } public void setRecordsTotal(Integer recordsTotal) { this.recordsTotal = recordsTotal; } public Integer getRecordsFiltered() { return recordsFiltered; } public void setRecordsFiltered(Integer recordsFiltered) { this.recordsFiltered = recordsFiltered; }}","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://yyhan.github.io/categories/jQuery/"}],"tags":[{"name":"DataTables","slug":"DataTables","permalink":"https://yyhan.github.io/tags/DataTables/"},{"name":"jQuery","slug":"jQuery","permalink":"https://yyhan.github.io/tags/jQuery/"}]},{"title":"log4j 使用指南","slug":"log4j-使用指南","date":"2017-07-23T08:21:26.000Z","updated":"2017-12-03T14:05:16.971Z","comments":true,"path":"2017/07/23/log4j-使用指南/","link":"","permalink":"https://yyhan.github.io/2017/07/23/log4j-使用指南/","excerpt":"","text":"&#x4F9D;&#x8D56; &#x7248;&#x672C;&#xFF1A; 2.10.0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!-- log4j &#x6838;&#x5FC3;jar&#x5305; --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- log4j &#x6838;&#x5FC3;jar&#x5305; --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- &#x5C06; common-logging &#x7684;&#x65E5;&#x5FD7;&#x6865;&#x63A5;&#x5230; log4j --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-jcl&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- &#x5C06; log4j 1.x &#x7684;&#x65E5;&#x5FD7;&#x6865;&#x63A5;&#x5230; log4j 2.x --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-1.2-api&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- &#x5C06; java.util.logging &#x7684;&#x65E5;&#x5FD7;&#x6865;&#x63A5;&#x5230; log4j 2.x --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-jul&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- &#x5C06; slf4j &#x7684;&#x65E5;&#x5FD7;&#x6865;&#x63A5;&#x5230; log4j 2.x&#x3002;&#x4E0D;&#x8981;&#x540C;&#x65F6;&#x5F15;&#x7528; log4j-to-slf4j --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- &#x5C06; log4j 2.x &#x7684;&#x65E5;&#x5FD7;&#x6865;&#x63A5;&#x5230; slf4j&#x3002;&#x4E0D;&#x8981;&#x540C;&#x65F6;&#x5F15;&#x7528; log4j-slf4j-impl --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-to-slf4j&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- &#x5728;servlet&#x6216;jsp&#x5BB9;&#x5668;&#x4E2D;&#x5F3A;&#x70C8;&#x5EFA;&#x8BAE;&#x5F15;&#x5165;&#x8BE5;&#x4F9D;&#x8D56;&#xFF0C;&#x4EE5;&#x89E3;&#x51B3;log4j&#x542F;&#x52A8;&#x548C;&#x5378;&#x8F7D;&#x65F6;&#x7684;&#x8D44;&#x6E90;&#x6E05;&#x7406;&#x95EE;&#x9898; --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-web&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt;&lt;/dependency&gt; &#x914D;&#x7F6E; &#x57FA;&#x672C;&#x914D;&#x7F6E; 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt; &lt;Properties&gt; &lt;!-- &#x81EA;&#x5B9A;&#x4E49;&#x5C5E;&#x6027; --&gt; &lt;!-- &#x8BBE;&#x7F6E; log &#x76EE;&#x5F55; --&gt; &lt;Property name=&quot;log.dir&quot;&gt;D:/logs/demo&lt;/Property&gt; &lt;!-- &#x8BBE;&#x7F6E;&#x65E5;&#x5FD7;&#x6587;&#x4EF6;&#x7F16;&#x7801; --&gt; &lt;Property name=&quot;charset.&quot;&gt;D:/logs/demo&lt;/Property&gt; &lt;/Properties&gt; &lt;Appenders&gt; &lt;!-- &#x63A7;&#x5236;&#x53F0;appender --&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout charset=&quot;${log.charset}&quot; pattern=&quot;%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger - %msg %ex %n&quot;/&gt; &lt;/Console&gt; &lt;RollingFile name=&quot;appFileLog&quot; fileName=&quot;${log.dir}/app.log&quot; filePattern=&quot;${log.dir}/%d{yyyy-MM-dd}/app.log&quot;&gt; &lt;PatternLayout pattern=&quot;%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger - %msg %ex %n&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy /&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;!-- &#x9ED8;&#x8BA4;&#x65E5;&#x5FD7;&#x7EA7;&#x522B; debug --&gt; &lt;Root level=&quot;debug&quot;&gt; &lt;!-- &#x9ED8;&#x8BA4;&#x65E5;&#x5FD7;&#x8F93;&#x51FA;&#x5230; &#x63A7;&#x5236;&#x53F0; --&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;AppenderRef ref=&quot;appFileLog&quot; /&gt; &lt;/Root&gt; &lt;!-- &#x6253;&#x5370;spring info&#x65E5;&#x5FD7; --&gt; &lt;logger name=&quot;org.springframework&quot; level=&quot;info&quot; /&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; web&#x73AF;&#x5883;&#x914D;&#x7F6E; &#x6307;&#x5B9A;log4j&#x65E5;&#x5FD7;&#x914D;&#x7F6E;&#x6587;&#x4EF6; 1234&lt;context-param&gt; &lt;param-name&gt;log4jConfiguration&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/log4j.xml&lt;/param-value&gt;&lt;/context-param&gt; servlet 3.0 &#x5728;servlet 3.0 &#x73AF;&#x5883;&#x4E2D;&#xFF0C;log4j2 &#x53EF;&#x4EE5;&#x81EA;&#x52A8;&#x6CE8;&#x518C;&#x542F;&#x52A8;&#x548C;&#x5378;&#x8F7D;&#x76D1;&#x542C;&#x5668;&#x3002;&#x5982;&#x679C;&#x4E0D;&#x9700;&#x8981;&#x81EA;&#x52A8;&#x6CE8;&#x518C;&#xFF0C;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x4EE5;&#x4E0B;&#x914D;&#x7F6E;&#x7981;&#x7528;&#x3002; 1234&lt;context-param&gt; &lt;param-name&gt;isLog4jAutoInitializationDisabled&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt;&lt;/context-param&gt; servlet 2.5 &#x5728;servlet 2.5 &#x73AF;&#x5883;&#x4E2D;&#xFF0C;&#x5FC5;&#x987B;&#x624B;&#x52A8;&#x6307;&#x5B9A; Log4jServletContextListener &#x4EE5;&#x6CE8;&#x518C; log4j &#x542F;&#x52A8;&#x548C;&#x5378;&#x8F7D;&#x76D1;&#x542C;&#x5668; 123&lt;listener&gt; &lt;listener-class&gt;org.apache.logging.log4j.web.Log4jServletContextListener&lt;/listener-class&gt;&lt;/listener&gt; &#x4F7F;&#x7528; 123456789101112import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger; public class HelloWorld { private static final Logger logger = LogManager.getLogger(&quot;HelloWorld&quot;); public static void main(String[] args) { logger.info(&quot;Hello, World!&quot;); if (logger.isDebugEnabled()) { logger.debug(&quot;args[0]={}&quot;, args[0]); } }}","categories":[{"name":"log4j","slug":"log4j","permalink":"https://yyhan.github.io/categories/log4j/"}],"tags":[{"name":"log4j2","slug":"log4j2","permalink":"https://yyhan.github.io/tags/log4j2/"},{"name":"java","slug":"java","permalink":"https://yyhan.github.io/tags/java/"},{"name":"log4j","slug":"log4j","permalink":"https://yyhan.github.io/tags/log4j/"}]},{"title":"spring mvc项目搭建","slug":"spring-mvc项目搭建","date":"2017-07-23T07:22:29.000Z","updated":"2017-07-23T07:22:29.223Z","comments":true,"path":"2017/07/23/spring-mvc项目搭建/","link":"","permalink":"https://yyhan.github.io/2017/07/23/spring-mvc项目搭建/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Idea Ant编译项目内存溢出问题","slug":"Idea-Ant编译项目内存溢出问题","date":"2017-07-23T05:22:15.000Z","updated":"2017-07-23T05:26:53.084Z","comments":true,"path":"2017/07/23/Idea-Ant编译项目内存溢出问题/","link":"","permalink":"https://yyhan.github.io/2017/07/23/Idea-Ant编译项目内存溢出问题/","excerpt":"","text":"idea&#x9ED8;&#x8BA4;&#x5728;&#x7F16;&#x8BD1;ant&#x9879;&#x76EE;&#x65F6;&#xFF0C;&#x4F7F;&#x7528;&#x7684;&#x5185;&#x5B58;&#x8F83;&#x5C0F;&#xFF0C;&#x5F53;&#x9879;&#x76EE;&#x8F83;&#x5927;&#x65F6;&#xFF0C;&#x5BB9;&#x6613;&#x51FA;&#x73B0;&#x5185;&#x5B58;&#x6EA2;&#x51FA;&#x95EE;&#x9898;&#xFF0C;&#x53EF;&#x901A;&#x8FC7;&#x4EE5;&#x4E0B;&#x65B9;&#x5F0F;&#x8BBE;&#x7F6E;ant&#x7F16;&#x8BD1;&#x65F6;&#x5185;&#x5B58;&#xFF1A; &#x8BBE;&#x7F6E;&#x5165;&#x53E3;&#xFF1A; &#x914D;&#x7F6E;&#x8BF4;&#x660E;&#xFF1A;","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://yyhan.github.io/categories/工具使用/"}],"tags":[{"name":"idea","slug":"idea","permalink":"https://yyhan.github.io/tags/idea/"},{"name":"ant","slug":"ant","permalink":"https://yyhan.github.io/tags/ant/"},{"name":"内存溢出","slug":"内存溢出","permalink":"https://yyhan.github.io/tags/内存溢出/"}]},{"title":"tomcat双向认证","slug":"tomcat双向认证","date":"2017-07-06T14:26:22.000Z","updated":"2017-07-06T15:30:59.041Z","comments":true,"path":"2017/07/06/tomcat双向认证/","link":"","permalink":"https://yyhan.github.io/2017/07/06/tomcat双向认证/","excerpt":"","text":"&#x6570;&#x5B57;&#x8BC1;&#x4E66;&#x76F8;&#x5173;&#x7684;&#x6807;&#x51C6;&#x548C;&#x534F;&#x8BAE; &#x53C2;&#x8003;&#xFF1A;https://en.wikipedia.org/wiki/PKCS &#x5173;&#x952E;&#x8BCD; &#x63CF;&#x8FF0; PEM PKIX, PKCS, and CMS &#x7ED3;&#x6784;&#x7684;&#x6587;&#x672C;&#x7F16;&#x7801;&#x683C;&#x5F0F;&#x3002;PEM&#x6700;&#x65E9;&#x662F;&#x57FA;&#x4E8E;&#x201C;&#x9690;&#x79C1;&#x589E;&#x5F3A;&#x90AE;&#x4EF6;&#x201D;&#x7684;1993&#x5E74;IETF&#x6807;&#x51C6;&#x96C6;&#x7684;&#x7528;&#x4E8E;&#x5B58;&#x50A8;&#x548C;&#x53D1;&#x9001;&#x52A0;&#x5BC6;&#x5BC6;&#x94A5;&#xFF0C;&#x8BC1;&#x4E66;&#x548C;&#x5176;&#x4ED6;&#x6570;&#x636E;&#x7684;&#x4E8B;&#x5B9E;&#x4E0A;&#x7684;&#x6587;&#x4EF6;&#x683C;&#x5F0F;&#x3002; &#x539F;&#x6807;&#x51C6;&#x672A;&#x88AB;&#x91C7;&#x7528;&#xFF0C;&#x4F46;&#x5176;&#x5B9A;&#x4E49;&#x7684;&#x6587;&#x672C;&#x7F16;&#x7801;&#x975E;&#x5E38;&#x53D7;&#x6B22;&#x8FCE;&#xFF0C;&#x6700;&#x7EC8;&#x7531;IETF&#x5728;RFC 7468&#x4E2D;&#x5F62;&#x5F0F;&#x5316;&#x3002;&#x53C2;&#x8003;&#xFF1A;https:tools.ietf.org/html/rfc7468 DER &#x53EF;&#x533A;&#x5206;&#x7F16;&#x7801;&#x89C4;&#x5219; (Distinguished Encoding Rules) &#x3002;&#x53EF;&#x5305;&#x542B;&#x6240;&#x6709;&#x79C1;&#x94A5;&#x3001;&#x516C;&#x94A5;&#x548C;&#x8BC1;&#x4E66;&#x3002;&#x5B83;&#x662F;&#x5927;&#x591A;&#x6570;&#x6D4F;&#x89C8;&#x5668;&#x7684;&#x7F3A;&#x7701;&#x683C;&#x5F0F;&#xFF0C;&#x5E76;&#x6309; ASN1 DER &#x683C;&#x5F0F;&#x5B58;&#x50A8;&#x3002;&#x5B83;&#x662F;&#x65E0;&#x62A5;&#x5934;&#x7684;(PEM &#x662F;&#x7528;&#x6587;&#x672C;&#x62A5;&#x5934;&#x5305;&#x56F4;&#x7684; DER)&#x3002;&#x4E00;&#x822C;&#x4F7F;&#x7528;&quot;.cer&quot;&#x505A;&#x6587;&#x4EF6;&#x540E;&#x7F00; JKS &#x901A;&#x5E38;&#x53EF;&#x4EE5;&#x5C06;Apache/OpenSSL&#x4F7F;&#x7528;&#x7684;&#x201C;KEY&#x6587;&#x4EF6; + CRT&#x6587;&#x4EF6;&#x201D;&#x683C;&#x5F0F;&#x201D;&#x8F6C;&#x6362;&#x4E3A;&#x6807;&#x51C6;&#x7684;Java Key Store(JKS)&#x6587;&#x4EF6;&#x3002;&#x4E00;&#x822C;&#x4EE5;&quot;.keystore&quot;&#x4F5C;&#x4E3A;&#x6587;&#x4EF6;&#x540E;&#x7F00;&#x3002; CSR &#x8BC1;&#x4E66;&#x7B7E;&#x540D;&#x8BF7;&#x6C42;(Certificate Signing Request)&#x3002;&#x53D1;&#x9001;&#x7ED9;CA&#x7B7E;&#x540D;&#x7684;&#x8BF7;&#x6C42;&#x5185;&#x5BB9;&#x6807;&#x51C6;&#xFF0C;&#x4E00;&#x822C;&#x5B58;&#x50A8;&#x5728;&#x4E00;&#x4E2A;&quot;.csr&quot;&#x540E;&#x7F00;&#x7684;&#x6587;&#x4EF6;&#x4E2D;&#x3002; CRT &#x8BC1;&#x4E66;&#x6587;&#x4EF6;&#x4E00;&#x822C;&#x4EE5;&quot;.crt&quot;&#x4F5C;&#x4E3A;&#x6587;&#x4EF6;&#x540E;&#x7F00;&#x3002; KEY PEM&#x683C;&#x5F0F;&#x7684;&#x79C1;&#x94A5;&#x6587;&#x4EF6;&#x4E00;&#x822C;&#x4EE5;&quot;.key&quot;&#x4F5C;&#x4E3A;&#x6587;&#x4EF6;&#x540E;&#x7F00;&#x3002; CRL &#x8BC1;&#x4E66;&#x540A;&#x9500;&#x5217;&#x8868; (Certification Revocation List) &#x3002; PKCS7 &#x52A0;&#x5BC6;&#x6D88;&#x606F;&#x8BED;&#x6CD5;&#x6807;&#x51C6;&#x3002;&#xFF08;&#x53C2;&#x8003;&#xFF1A;https:www.ietf.org/rfc/rfc2315.txt&#xFF09; PKCS12 &#x4E2A;&#x4EBA;&#x4FE1;&#x606F;&#x4EA4;&#x6362;&#x8BED;&#x6CD5;&#x6807;&#x51C6;&#x3002;&#x5B9A;&#x4E49;&#x4E86;&#x4E00;&#x4E2A;&#x901A;&#x7528;&#x7684;&#x6587;&#x4EF6;&#x683C;&#x5F0F;&#x6807;&#x51C6;&#xFF0C;&#x7528;&#x4E8E;&#x5B58;&#x50A8;&#x9644;&#x5E26;&#x516C;&#x94A5;&#x8BC1;&#x4E66;&#x7684;&#x79C1;&#x94A5;&#xFF0C;&#x5E76;&#x4F7F;&#x7528;&#x57FA;&#x4E8E;&#x5BC6;&#x7801;&#x7684;&#x5BF9;&#x79F0;&#x5BC6;&#x94A5;&#x52A0;&#x5BC6;&#x3002;&#x524D;&#x8EAB;&#x662F;PFX&#x3002;&#x4E00;&#x822C;&#x4EE5;&quot;.p12&quot;&#x4F5C;&#x4E3A;&#x6587;&#x4EF6;&#x540E;&#x7F00;&#x3002; X.509 &#x516C;&#x94A5;&#x8BC1;&#x4E66;&#x6807;&#x51C6; &#x751F;&#x6210;&#x8BC1;&#x4E66; &#x4F7F;&#x7528;java&#x81EA;&#x5E26;&#x7684;keytool&#x5DE5;&#x5177;&#x751F;&#x6210;&#x8BC1;&#x4E66;&#x3002;&#x5982;&#x679C;&#x6587;&#x7AE0;&#x4E2D;&#x6709;&#x54EA;&#x4E9B;&#x53C2;&#x6570;&#x4E0D;&#x660E;&#x767D;&#x7684;&#x53EF;&#x4EE5;&#x53C2;&#x8003;keytool&#x5B98;&#x65B9;&#x6587;&#x6863; &#x524D;&#x671F;&#x89C4;&#x5212; &#x6D89;&#x53CA;&#x7684;&#x540D;&#x79F0;&#x6BD4;&#x8F83;&#x591A;&#xFF0C;&#x5148;&#x89C4;&#x5212;&#x4E00;&#x4E0B;&#xFF0C;&#x540E;&#x9762;&#x4F1A;&#x4F5C;&#x8BF4;&#x660E;&#xFF08;&#x4EE5;&#x4E0B;&#x6570;&#x636E;&#x7EAF;&#x5C5E;&#x6D4B;&#x8BD5;&#xFF0C;&#x5982;&#x6709;&#x96F7;&#x540C;&#xFF0C;&#x8BF7;&#x77E5;&#x4F1A;&#xFF09;&#x3002; &#x7EC4;&#x7EC7;&#x673A;&#x6784;&#xFF08;&#x516C;&#x53F8;&#x540D;&#x79F0;&#xFF09;&#xFF1A;XTBaBa &#x7EC4;&#x7EC7;&#x673A;&#x6784;&#x90E8;&#x95E8;&#xFF1A;XTBaBa CA &#x6839;&#x8BC1;&#x4E66;&#x540D;&#x79F0;&#xFF1A;XTBaBa Root CA &#x57DF;&#x540D;&#xFF1A;a.xtbaba.com | b.xtbaba.com &#x670D;&#x52A1;&#x7AEF;&#x8BC1;&#x4E66;&#x5BC6;&#x94A5;&#x5E93;&#xFF1A;tomcat.keystore &#x670D;&#x52A1;&#x7AEF;&#x4FE1;&#x4EFB;&#x8BC1;&#x4E66;&#x5217;&#x8868;&#x5BC6;&#x94A5;&#x5E93;&#xFF1A;tomcat_trust.keystore &#x6839;&#x8BC1;&#x4E66;&#x5BC6;&#x94A5;&#x5E93;&#xFF1A;root.keystore &#x5BA2;&#x6237;&#x8BC1;&#x4E66;&#xFF1A;xiaotian.p12 &#x6839;&#x8BC1;&#x4E66;&#x5728;&#x5BC6;&#x94A5;&#x5E93;&#x4E2D;&#x7684;&#x522B;&#x540D;&#xFF1A;root &#x6240;&#x6709;&#x5BC6;&#x94A5;&#x5E93;&amp;&#x5BC6;&#x94A5;&#x7684;&#x5BC6;&#x7801;&#xFF1A;123456 &#x77E5;&#x8BC6;&#x626B;&#x76F2; keytool &#x662F;java&#x81EA;&#x5E26;&#x7684;&#x63D0;&#x4F9B;&#x751F;&#x6210;&#x8BC1;&#x4E66;&#x3001;&#x6570;&#x5B57;&#x7B7E;&#x540D;&#x7B49;&#x529F;&#x80FD;&#x7684;&#x5C0F;&#x5DE5;&#x5177; keytool &#x751F;&#x6210;&#x7684;&#x5BC6;&#x94A5;&#x5E93;&#x4E0D;&#x80FD;&#x5BFC;&#x51FA;&#x975E;&#x5BF9;&#x79F0;&#x7B97;&#x6CD5;&#x7684;&#x79C1;&#x94A5; keytool &#x5BFC;&#x5165;&#x516C;&#x94A5;&#x8BC1;&#x4E66;&#x65F6;&#xFF0C;&#x5982;&#x679C;&#x522B;&#x540D;&#xFF08;alias&#xFF09;&#x76F8;&#x540C;&#xFF0C;&#x5219;&#x8BA4;&#x4E3A;&#x5BFC;&#x5165;&#x7684;&#x662F;CA&#x7B7E;&#x540D;&#x540E;&#x7684;&#x8BC1;&#x4E66; https &#x5355;&#x5411;&#x8BA4;&#x8BC1;&#x6307;&#x5BA2;&#x6237;&#x7AEF;&#x9A8C;&#x8BC1;&#x670D;&#x52A1;&#x7AEF;&#x8EAB;&#x4EFD;&#xFF0C;&#x6211;&#x4EEC;&#x5E73;&#x5E38;&#x89C1;&#x7684;https&#x7AD9;&#x70B9;&#xFF0C;&#x90FD;&#x5C5E;&#x4E8E;&#x5355;&#x5411;&#x8BA4;&#x8BC1; &#x53CC;&#x5411;&#x8BA4;&#x8BC1;&#x65F6;&#xFF0C;&#x6D4F;&#x89C8;&#x5668;&#x4F1A;&#x8BA9;&#x7528;&#x6237;&#x9009;&#x62E9;&#x4E00;&#x4E2A;&#x8BC1;&#x4E66;&#x4F20;&#x9012;&#x7ED9;&#x670D;&#x52A1;&#x5668;&#xFF0C;&#x7531;&#x670D;&#x52A1;&#x5668;&#x6838;&#x9A8C;&#x5BA2;&#x6237;&#x7684;&#x8BC1;&#x4E66; &#x66F4;&#x591A;&#x77E5;&#x8BC6;&#xFF0C;&#x8BF7;&#x53C2;&#x8003;keytool&#x5B98;&#x65B9;&#x6587;&#x6863; &#x751F;&#x6210;&#x6839;&#x8BC1;&#x4E66; 1234# &#x751F;&#x6210;&#x6839;&#x8BC1;&#x4E66;&#x5BC6;&#x94A5;&#x5BF9;&#x5E76;&#x4FDD;&#x5B58;&#x5230;tomcat.keystore&#x5BC6;&#x94A5;&#x5E93;&#x4E2D;keytool -genkeypair -keystore root.keystore -storepass 123456 -keyalg RSA -keypass 123456 -alias root -dname &quot;CN=XTBaBa Root CA, OU=XTBaBa CA, O=XTBaBa, L=Hangzhou, S=Zhejiang, C=CN&quot;# &#x5BFC;&#x51FA;&#x6839;&#x8BC1;&#x4E66;keytool -exportcert -keystore root.keystore -storepass 123456 -file root.crt -alias root -v &#x5BA2;&#x6237;&#x9700;&#x8981;&#x5C06;root.crt&#x5BFC;&#x5165;&#x5230;&#x64CD;&#x4F5C;&#x7CFB;&#x7EDF;&#x7684;&#x53D7;&#x4FE1;&#x4EFB;&#x7684;&#x6839;&#x8BC1;&#x4E66;&#x9881;&#x53D1;&#x673A;&#x6784;&#x8BC1;&#x4E66;&#x5206;&#x7C7B;&#x4E2D;&#xFF0C;&#x5426;&#x5219; https &#x5355;&#x5411;&#x8BA4;&#x8BC1;&#x4E0D;&#x901A;&#x8FC7; &#x751F;&#x6210;&#x670D;&#x52A1;&#x7AEF;&#x8BC1;&#x4E66; 1234567891011121314151617# &#x751F;&#x6210;&#x670D;&#x52A1;&#x7AEF;&#x8BC1;&#x4E66;&#x5BC6;&#x94A5;&#x5BF9;keytool -genkeypair -keystore tomcat.keystore -storepass 123456 -keyalg RSA -keypass 123456 -alias xtbaba_site -dname &quot;CN=XTBaBa Customer Site, OU=XTBaBa RD, O=XTBaBa, L=Hangzhou, S=Zhejiang, C=CN&quot;# &#x751F;&#x6210;&#x670D;&#x52A1;&#x7AEF;&#x8BC1;&#x4E66;&#x7B7E;&#x540D;&#x8BF7;&#x6C42;keytool -certreq -keystore tomcat.keystore -storepass 123456 -alias xtbaba_site -file xtbaba_site.csr# &#x4F7F;&#x7528;&#x6839;&#x8BC1;&#x4E66;&#x5BF9;&#x670D;&#x52A1;&#x7AEF;&#x8BC1;&#x4E66;&#x7B7E;&#x540D;&#xFF0C;&#x7B7E;&#x540D;&#x65F6;&#x6307;&#x5B9A;&#x4E86;&#x4E24;&#x4E2A;&#x57DF;&#x540D;keytool -gencert -keystore tomcat.keystore -storepass 123456 -alias root -infile xtbaba_site.csr -outfile xtbaba_site.cer -ext &quot;san=dns:a.xtbaba.com,dns:b.xtbaba.com&quot; -ext eku=&quot;serverAuth,clientAuth&quot;# &#x5C06;&#x6839;&#x8BC1;&#x4E66;&#x4E34;&#x65F6;&#x5BFC;&#x5165;&#x5230;tomcat.keystore&#x5BC6;&#x94A5;&#x5E93;&#x4E2D;keytool -importkeystore -srckeystore root.keystore -srcstorepass 123456 -srcalias root -destkeystore tomcat.keystore -deststorepass 123456 -destalias root# &#x5C06;&#x7B7E;&#x540D;&#x540E;&#x7684;&#x670D;&#x52A1;&#x7AEF;&#x8BC1;&#x4E66;&#x5BFC;&#x5165;&#x5230;&#x670D;&#x52A1;&#x7AEF;&#x5BC6;&#x94A5;&#x5E93;keytool -import -keystore tomcat.keystore -storepass 123456 -file xtbaba_site.cer -alias xtbaba_site# &#x79FB;&#x9664;&#x6839;&#x8BC1;&#x4E66;&#xFF0C;&#x5207;&#x8BB0;&#x79FB;&#x9664;&#x6389;&#x554A;keytool -delete -keystore tomcat.keystore -storepass 123456 -alias root &#x751F;&#x6210;&#x5BA2;&#x6237;&#x8BC1;&#x4E66; 12345678910111213141516171819# &#x751F;&#x6210;&#x5BA2;&#x6237;&#x8BC1;&#x4E66;&#x5BC6;&#x94A5;&#x5BF9;&#xFF0C;&#x5BA2;&#x6237;&#x8BC1;&#x4E66;&#x9700;&#x8981;&#x4F7F;&#x7528;&quot;PKCS12&quot;&#x683C;&#x5F0F;keytool -genkeypair -keystore xiaotian.p12 -storepass 123456 -storetype PKCS12 -keyalg RSA -keypass 123456 -alias xiaotian -dname &quot;CN=Xiaotian, OU=XTBaBa User, O=XTBaBa, L=Hangzhou, S=Zhejiang, C=CN&quot;# &#x751F;&#x6210;&#x5BA2;&#x6237;&#x8BC1;&#x4E66;&#x7B7E;&#x540D;&#x8BF7;&#x6C42;keytool -certreq -keystore xiaotian.p12 -storepass 123456 -alias xiaotian -file xiaotian.csr# &#x4F7F;&#x7528;&#x6839;&#x8BC1;&#x4E66;&#x5BF9;&#x5BA2;&#x6237;&#x8BC1;&#x4E66;&#x7B7E;&#x540D;keytool -gencert -keystore root.keystore -storepass 123456 -alias root -infile xiaotian.csr -outfile xiaotian.cer -ext eku=&quot;serverAuth,clientAuth&quot;# &#x5BFC;&#x5165;&#x7B7E;&#x540D;&#x540E;&#x7684;&#x5BA2;&#x6237;&#x8BC1;&#x4E66;&#x5230;&#x5BC6;&#x94A5;&#x5E93;# 1. &#x9996;&#x5148;&#x5C06;&#x6839;&#x8BC1;&#x4E66;&#x5BFC;&#x5165;&#x5230;&#x5BA2;&#x6237;&#x8BC1;&#x4E66;&#x5BC6;&#x94A5;&#x5E93;&#x4E2D;keytool -importkeystore -srckeystore root.keystore -srcstorepass 123456 -srcalias root -destkeystore xiaotian.p12 -deststorepass 123456 -destalias root# 2. &#x5C06;&#x7B7E;&#x540D;&#x540E;&#x7684;&#x5BA2;&#x6237;&#x8BC1;&#x4E66;&#x5BFC;&#x5165;&#x5230;&#x5BA2;&#x6237;&#x8BC1;&#x4E66;&#x5BC6;&#x94A5;&#x5E93;&#x4E2D;&#x3002;&#x5BFC;&#x5165;&#x7B7E;&#x540D;&#x540E;&#x7684;&#x8BC1;&#x4E66;&#x65F6;&#xFF0C;keytool&#x8981;&#x4ECE;&#x5BC6;&#x94A5;&#x5E93;&#x4E2D;&#x627E;&#x5230;&#x4E00;&#x4E2A;&#x8BC1;&#x4E66;&#x6765;&#x9A8C;&#x8BC1;&#x8BE5;&#x7B7E;&#x540D;&#xFF0C;&#x6240;&#x4EE5;&#x5FC5;&#x987B;&#x5C06;&#x6839;&#x8BC1;&#x4E66;&#x4E34;&#x65F6;&#x5BFC;&#x5165;&#x5230;&#x5BA2;&#x6237;&#x8BC1;&#x4E66;&#x5BC6;&#x94A5;&#x5E93;&#x4E2D;&#x3002;keytool -import -keystore xiaotian.p12 -storepass 123456 -file xiaotian.cer -alias xiaotian# 3. &#x4ECE;&#x5BA2;&#x6237;&#x8BC1;&#x4E66;&#x5BC6;&#x94A5;&#x5E93;&#x4E2D;&#x79FB;&#x9664;&#x6839;&#x8BC1;&#x4E66;&#x3002;&#x5343;&#x4E07;&#x522B;&#x628A;&#x6839;&#x8BC1;&#x4E66;&#x53D1;&#x7ED9;&#x7528;&#x6237;&#x4E86;keytool -delete -keystore xiaotian.p12 -storepass 123456 -alias root &#x5BFC;&#x5165;&#x7B7E;&#x540D;&#x540E;&#x7684;&#x8BC1;&#x4E66;&#x65F6;&#xFF0C;keytool&#x8981;&#x4ECE;&#x5BC6;&#x94A5;&#x5E93;&#x4E2D;&#x627E;&#x5230;&#x4E00;&#x4E2A;&#x8BC1;&#x4E66;&#x6765;&#x9A8C;&#x8BC1;&#x8BE5;&#x7B7E;&#x540D;&#xFF0C;&#x6240;&#x4EE5;&#x5FC5;&#x987B;&#x5C06;&#x6839;&#x8BC1;&#x4E66;&#x4E34;&#x65F6;&#x5BFC;&#x5165;&#x5230;&#x5BA2;&#x6237;&#x8BC1;&#x4E66;&#x5BC6;&#x94A5;&#x5E93;&#x4E2D; &#x751F;&#x6210;&#x5B8C;&#x6BD5;&#x540E;&#xFF0C;&#x5C06; xiaotian.p12 &#x6587;&#x4EF6;&#x53D1;&#x9001;&#x7ED9;&#x5BA2;&#x6237;&#xFF0C;&#x5BA2;&#x6237;&#x5C06;&#x8BE5;&#x8BC1;&#x4E66;&#x5BFC;&#x5165;&#x64CD;&#x4F5C;&#x7CFB;&#x7EDF;&#x7684;&#x8BC1;&#x4E66;&#x5E93;&#x5373;&#x53EF;&#xFF08;&#x4E00;&#x822C;&#x5BFC;&#x5165;&#x5728;&#x4E2A;&#x4EBA;&#x8BC1;&#x4E66;&#x5206;&#x7C7B;&#x91CC;&#xFF09;&#x3002; &#x7ED9;&#x5BA2;&#x6237;&#x751F;&#x6210;&#x5B8C;&#x8BC1;&#x4E66;&#x540E;&#xFF0C;&#x4E00;&#x5B9A;&#x8981;&#x4ECE; xiaotian.p12 &#x4E2D;&#x5220;&#x9664;&#x6839;&#x8BC1;&#x4E66;&#xFF0C;&#x5343;&#x4E07;&#x522B;&#x628A;&#x6839;&#x8BC1;&#x4E66;&#x53D1;&#x7ED9;&#x7528;&#x6237;&#x4E86; &#x5C06;&#x5BA2;&#x6237;&#x8BC1;&#x4E66;&#x6DFB;&#x52A0;&#x5230;&#x670D;&#x52A1;&#x7AEF;&#x7684;&#x4FE1;&#x4EFB;&#x8BC1;&#x4E66;&#x5BC6;&#x94A5;&#x5E93; 12345# &#x5BFC;&#x5165;&#x6839;&#x8BC1;&#x4E66;keytool -importkeystore -srckeystore root.keystore -srcstorepass 123456 -srcalias root -destkeystore tomcat_trust.keystore -deststorepass 123456 -destalias root# &#x5BFC;&#x5165;&#x5BA2;&#x6237;&#x8BC1;&#x4E66;keytool -import -keystore tomcat_trust.keystore -storepass 123456 -file xiaotian.cer -alias xiaotian &#x5FC5;&#x987B;&#x5C06;&#x6839;&#x8BC1;&#x4E66;&#x5BFC;&#x5165;&#x5230;tomcat_trust.keystore&#x5BC6;&#x94A5;&#x5E93;&#x4E2D;&#xFF0C;tomcat&#x5C06;&#x7528;&#x6B64;&#x6839;&#x8BC1;&#x4E66;&#x6765;&#x9A8C;&#x8BC1;&#x6D4F;&#x89C8;&#x5668;&#x63D0;&#x4EA4;&#x7684;&#x6839;&#x8BC1;&#x4E66; keytool &#x5176;&#x5B83;&#x5E38;&#x7528;&#x547D;&#x4EE4; 12345# &#x67E5;&#x770B;&#x5BC6;&#x94A5;&#x5E93;&#x4E2D;&#x7684;&#x6240;&#x6709;&#x5BC6;&#x94A5;keytool -list -keystore tomcat.keystore -storepass 123456 -v# &#x67E5;&#x770B;&#x8BC1;&#x4E66;&#x5185;&#x5BB9;keytool -printcert -file xiaotian.cer &#x914D;&#x7F6E;tomcat &#x4FEE;&#x6539;server.xml 12345678910111213141516&lt;!- &#x8BBE;&#x7F6E;&#x7AEF;&#x53E3;&#x4E3A;80&#xFF0C;redirectPort &#x91CD;&#x5B9A;&#x5411;&#x5230;https&#x7AEF;&#x53E3; --&gt;&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;443&quot; /&gt;&lt;Connector port=&quot;443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; maxThreads=&quot;100&quot; scheme=&quot;https&quot; secure=&quot;true&quot; SSLEnabled=&quot;true&quot; keyAlias=&quot;xtbaba_site&quot; keystoreFile=&quot;D:/www/keys/tomcat.keystore&quot; keystorePass=&quot;123456&quot; truststoreFile=&quot;D:/www/keys/tomcat_trust.keystore&quot; truststorePass=&quot;123456&quot; clientAuth=&quot;true&quot; sslProtocol=&quot;TLS&quot; /&gt; xml&#x6587;&#x4EF6;&#x914D;&#x7F6E;&#x8BF4;&#x660E;&#xFF1A; protocol &#x5FC5;&#x987B;&#x914D;&#x7F6E;&#x4E3A;org.apache.coyote.http11.Http11NioProtocol keyAlias &#x670D;&#x52A1;&#x5668;&#x8BC1;&#x4E66;&#x522B;&#x540D; keystoreFile &#x670D;&#x52A1;&#x5668;&#x8BC1;&#x4E66;&#x5BC6;&#x94A5;&#x5E93; keystorePass &#x670D;&#x52A1;&#x5668;&#x8BC1;&#x4E66;&#x5BC6;&#x94A5;&#x5E93;&#x5BC6;&#x7801; truststoreFile &#x670D;&#x52A1;&#x5668;&#x4FE1;&#x4EFB;&#x8BC1;&#x4E66;&#x5217;&#x8868;&#x5BC6;&#x94A5;&#x5E93; truststorePass &#x670D;&#x52A1;&#x5668;&#x4FE1;&#x4EFB;&#x8BC1;&#x4E66;&#x5217;&#x8868;&#x5BC6;&#x94A5;&#x5E93;&#x5BC6;&#x7801; clientAuth &#x5BA2;&#x6237;&#x7AEF;&#x8BA4;&#x8BC1;&#xFF1A; true&#xFF1A;&#x5BA2;&#x6237;&#x7AEF;&#x5FC5;&#x987B;&#x63D0;&#x4F9B;&#x8BC1;&#x4E66;&#xFF1B; false&#xFF1A;&#x5BA2;&#x6237;&#x7AEF;&#x4E0D;&#x5FC5;&#x63D0;&#x4F9B;&#x8BC1;&#x4E66;&#xFF1B; want&#xFF1A;&#x5BA2;&#x6237;&#x7AEF;&#x63D0;&#x4E0D;&#x63D0;&#x4F9B;&#x8BC1;&#x4E66;&#x90FD;&#x53EF;&#x4EE5; sslProtocol SSL&#x534F;&#x8BAE; &#x8BFB;&#x53D6;&#x5BA2;&#x6237;&#x8BC1;&#x4E66;&#x5185;&#x5BB9; maven&#x4F9D;&#x8D56;&#x914D;&#x7F6E;&#xFF1A; 123456&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-coyote&lt;/artifactId&gt; &lt;version&gt;7.0.8&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; &#x901A;&#x8FC7;HttpServletRequest&#x63D0;&#x53D6;&#x8BC1;&#x4E66;&#x5185;&#x5BB9;&#x65F6;&#x9700;&#x8981;&#x4F9D;&#x8D56;tomcat-coyotejar&#x5305;&#xFF0C;&#x8BE5;jar&#x5305;&#x7531;tomcat&#x63D0;&#x4F9B;&#xFF0C;&#x5FC5;&#x987B;&#x6307;&#x5B9A;scope&#x4E3A;provided&#x3002;&#x5426;&#x5219;&#x8FD0;&#x884C;&#x65F6;&#x4F1A;&#x62A5;&#x9519;&#xFF08;&#x62A5;&#x9519;&#x5185;&#x5BB9;&#x4E3A;&#x627E;&#x4E0D;&#x5230;SSLSupport&#xFF09;&#x3002;java&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF1A; 1234567891011X509Certificate[] certificates = (X509Certificate[]) request.getAttribute(SSLSupport.CERTIFICATE_KEY);if(certificates != null &amp;&amp; certificates.length &gt; 0){ X509Certificate certificate = certificates[0]; logger.debug(&quot;&#x4F7F;&#x7528;&#x8005;&#x552F;&#x4E00;&#x540D;&#x79F0; = {}&quot;, certificate.getSubjectDN()); logger.debug(&quot;&#x9881;&#x5E03;&#x8005;&#x552F;&#x4E00;&#x540D;&#x79F0; = {}&quot;, certificate.getIssuerDN()); logger.debug(&quot;&#x8BC1;&#x4E66;&#x5E8F;&#x5217;&#x53F7; = {}&quot;, certificate.getSerialNumber()); logger.debug(&quot;&#x8BC1;&#x4E66;&#x7C7B;&#x578B; = {}&quot;, certificate.getType()); logger.debug(&quot;&#x8BC1;&#x4E66;&#x6709;&#x6548;&#x671F; &#xFF1A; {}&quot;, DateFormatUtils.format(certificate.getNotBefore(), &quot;yyyy-MM-dd HH:mm:ss.SSS&quot;), DateFormatUtils.format(certificate.getNotAfter(), &quot;yyyy-MM-dd HH:mm:ss.SSS&quot;)); logger.debug(&quot;&#x8BC1;&#x4E66;&#x7B7E;&#x540D; = {}&quot;, Hex.encodeHexString(certificate.getSignature()));} &#x8FD0;&#x884C;&#x7ED3;&#x679C;&#xFF1A; 1234562017-07-04 18:14:29.480 HomeController - &#x4F7F;&#x7528;&#x8005;&#x552F;&#x4E00;&#x540D;&#x79F0; = CN=Xiaotian, OU=XTBaBa User, O=XTBaBa, L=Hangzhou, ST=Zhejiang, C=CN2017-07-04 18:14:29.480 HomeController - &#x9881;&#x5E03;&#x8005;&#x552F;&#x4E00;&#x540D;&#x79F0; = CN=XTBaBa Root CA, OU=XTBaBa CA, O=XTBaBa, L=Hangzhou, ST=Zhejiang, C=CN2017-07-04 18:14:29.480 HomeController - &#x8BC1;&#x4E66;&#x5E8F;&#x5217;&#x53F7; = 13277062042017-07-04 18:14:29.480 HomeController - &#x8BC1;&#x4E66;&#x7C7B;&#x578B; = X.5092017-07-04 18:14:29.480 HomeController - &#x8BC1;&#x4E66;&#x6709;&#x6548;&#x671F; = 2017-07-04 15:46:18.0002017-07-04 18:14:29.920 HomeController - &#x8BC1;&#x4E66;&#x7B7E;&#x540D; = 9c2fc47626621378f0f47d62e2b337265d3042495a259b5230ea2336ec990e9e2073fa817f2bb3d72a64565601b5f0171c77685d3ca616df4fcc46b8d6c4aed0101c21e0eaa22fd747b311eea5a781f721d47d621b0543bc3de442830e1c34a272b7960a97766df23f7955c6bdbf13013cf76b9e4233270ad78514d3afc59d442e4298b4fb2c19ab656a38d41ace261f24f4ba63e14c9d368aa7393b808b91ca19115c6578903bfeb3feb3173d68ff","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://yyhan.github.io/categories/工具使用/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"https://yyhan.github.io/tags/tomcat/"},{"name":"keytool","slug":"keytool","permalink":"https://yyhan.github.io/tags/keytool/"},{"name":"数字证书","slug":"数字证书","permalink":"https://yyhan.github.io/tags/数字证书/"},{"name":"双向认证","slug":"双向认证","permalink":"https://yyhan.github.io/tags/双向认证/"}]},{"title":"java 加密体系架构参考指南","slug":"java-加密体系架构参考指南","date":"2017-06-29T16:22:34.000Z","updated":"2017-07-09T05:58:55.003Z","comments":true,"path":"2017/06/30/java-加密体系架构参考指南/","link":"","permalink":"https://yyhan.github.io/2017/06/30/java-加密体系架构参考指南/","excerpt":"","text":"&#x539F;&#x6587;&#x5730;&#x5740;&#xFF1A;Java Cryptography Architecture (JCA) Reference Guide &#x4ECB;&#x7ECD; The Java platform strongly emphasizes security, including language safety, cryptography, public key infrastructure, authentication, secure communication, and access control. The JCA is a major piece of the platform, and contains a &quot;provider&quot; architecture and a set of APIs for digital signatures, message digests (hashes), certificates and certificate validation, encryption (symmetric/asymmetric block/stream ciphers), key generation and management, and secure random number generation, to name a few. These APIs allow developers to easily integrate security into their application code. The architecture was designed around the following principles: Implementation independence: Applications do not need to implement security algorithms. Rather, they can request security services from the Java platform. Security services are implemented in providers (see below), which are plugged into the Java platform via a standard interface. An application may rely on multiple independent providers for security functionality. Implementation interoperability: Providers are interoperable across applications. Specifically, an application is not bound to a specific provider, and a provider is not bound to a specific application. Algorithm extensibility: The Java platform includes a number of built-in providers that implement a basic set of security services that are widely used today. However, some applications may rely on emerging standards not yet implemented, or on proprietary services. The Java platform supports the installation of custom providers that implement such services. Other cryptographic communication libraries available in the JDK use the JCA provider architecture, but are described elsewhere. The Java Secure Socket Extension (JSSE) provides access to Secure Socket Layer (SSL) and Transport Layer Security (TLS) implementations. The Java Generic Security Services (JGSS) (via Kerberos) APIs, and the Simple Authentication and Security Layer (SASL) can also be used for securely exchanging messages between communicating applications. Notes on Terminology Prior to JDK 1.4, the JCE was an unbundled product, and as such, the JCA and JCE were regularly referred to as separate, distinct components. As JCE is now bundled in the JDK, the distinction is becoming less apparent. Since the JCE uses the same architecture as the JCA, the JCE should be more properly thought of as a part of the JCA. The JCA within the JDK includes two software components: the framework that defines and supports cryptographic services for which providers supply implementations. This framework includes packages such as java.security, javax.crypto, javax.crypto.spec, and javax.crypto.interfaces. the actual providers such as Sun, SunRsaSign, SunJCE, which contain the actual cryptographic implementations. Whenever a specific JCA provider is mentioned, it will be referred to explicitly by the provider&apos;s name. WARNING: The JCA makes it easy to incorporate security features into your application. However, this document does not cover the theory of security/cryptography beyond an elementary introduction to concepts necessary to discuss the APIs. This document also does not cover the strengths/weaknesses of specific algorithms, not does it cover protocol design. Cryptography is an advanced topic and one should consult a solid, preferably recent, reference in order to make best use of these tools. You should always understand what you are doing and why: DO NOT simply copy random code and expect it to fully solve your usage scenario. Many applications have been deployed that contain significant security or performance problems because the wrong tool or algorithm was selected. &#x8BBE;&#x8BA1;&#x539F;&#x5219; The JCA was designed around these principles: implementation independence and interoperability algorithm independence and extensibility Implementation independence and algorithm independence are complementary; you can use cryptographic services, such as digital signatures and message digests, without worrying about the implementation details or even the algorithms that form the basis for these concepts. While complete algorithm-independence is not possible, the JCA provides standardized, algorithm-specific APIs. When implementation-independence is not desirable, the JCA lets developers indicate a specific implementation. Algorithm independence is achieved by defining types of cryptographic &quot;engines&quot; (services), and defining classes that provide the functionality of these cryptographic engines. These classes are called engine classes, and examples are the MessageDigest, Signature, KeyFactory, KeyPairGenerator, and Cipher classes. Implementation independence is achieved using a &quot;provider&quot;-based architecture. The term Cryptographic Service Provider (CSP) (used interchangeably with &quot;provider&quot; in this document) refers to a package or set of packages that implement one or more cryptographic services, such as digital signature algorithms, message digest algorithms, and key conversion services. A program may simply request a particular type of object (such as a Signature object) implementing a particular service (such as the DSA signature algorithm) and get an implementation from one of the installed providers. If desired, a program may instead request an implementation from a specific provider. Providers may be updated transparently to the application, for example when faster or more secure versions are available. Implementation interoperability means that various implementations can work with each other, use each other&apos;s keys, or verify each other&apos;s signatures. This would mean, for example, that for the same algorithms, a key generated by one provider would be usable by another, and a signature generated by one provider would be verifiable by another. Algorithm extensibility means that new algorithms that fit in one of the supported engine classes can be added easily. &#x67B6;&#x6784; &#x52A0;&#x5BC6;&#x670D;&#x52A1;&#x63D0;&#x4F9B;&#x8005; java.security.Provider is the base class for all security providers. Each CSP contains an instance of this class which contains the provider&apos;s name and lists all of the security services/algorithms it implements. When an instance of a particular algorithm is needed, the JCA framework consults the provider&apos;s database, and if a suitable match is found, the instance is created. Providers contain a package (or a set of packages) that supply concrete implementations for the advertised cryptographic algorithms. Each JDK installation has one or more providers installed and configured by default. Additional providers may be added statically or dynamically (see the Provider and Security classes). Clients may configure their runtime environment to specify the provider preference order. The preference order is the order in which providers are searched for requested services when no specific provider is requested. To use the JCA, an application simply requests a particular type of object (such as a MessageDigest) and a particular algorithm or service (such as the &quot;MD5&quot; algorithm), and gets an implementation from one of the installed providers. Alternatively, the program can request the objects from a specific provider. Each provider has a name used to refer to it. 12md = MessageDigest.getInstance(&quot;MD5&quot;);md = MessageDigest.getInstance(&quot;MD5&quot;, &quot;ProviderC&quot;); The following figure illustrates requesting an &quot;MD5&quot; message digest implementation. The figure show three different providers that implement various message digest algorithms (&quot;SHA-1&quot;, &quot;MD5&quot;, &quot;SHA-256&quot;, and &quot;SHA-512&quot;). The providers are ordered by preference from left to right (1-3). In the first illustration, an application requests an MD5 algorithm implementation without specifying a provider name. The providers are searched in preference order and the implementation from the first provider supplying that particular algorithm, ProviderB, is returned. In the second figure, the application requests the MD5 algorithm implementation from a specific provider, ProviderC. This time the implementation from ProviderC is returned, even though a provider with a higher preference order, ProviderB, also supplies an MD5 implementation. MD5 Message Digest Implementation Description of Figure MD5 Message Digest Implementation Cryptographic implementations in the JDK are distributed via several different providers (Sun, SunJSSE, SunJCE, SunRsaSign) primarily for historical reasons, but to a lesser extent by the type of functionality and algorithms they provide. Other Java runtime environments may not necessarily contain these Sun providers, so applications should not request an provider-specific implementation unless it is known that a particular provider will be available. The JCA offers a set of APIs that allow users to query which providers are installed and what services they support. This architecture also makes it easy for end-users to add additional providers. Many third party provider implementations are already available. See The Provider Class for more information on how providers are written, installed, and registered. How Providers Are Actually Implemented As mentioned earlier, algorithm independence is achieved by defining a generic high-level Application Programming Interface (API) that all applications use to access a service type. Implementation independence is achieved by having all provider implementations conform to well-defined interfaces. Instances of engine classes are thus &quot;backed&quot; by implementation classes which have the same method signatures. Application calls are routed through the engine class and are delivered to the underlying backing implementation. The implementation handles the request and return the proper results. The application API methods in each engine class are routed to the provider&apos;s implementations through classes that implement the corresponding Service Provider Interface (SPI). That is, for each engine class, there is a corresponding abstract SPI class which defines the methods that each cryptographic service provider&apos;s algorithm must implement. The name of each SPI class is the same as that of the corresponding engine class, followed by Spi. For example, the Signature engine class provides access to the functionality of a digital signature algorithm. The actual provider implementation is supplied in a subclass of SignatureSpi. Applications call the engine class&apos; API methods, which in turn call the SPI methods in the actual implementation. Each SPI class is abstract. To supply the implementation of a particular type of service for a specific algorithm, a provider must subclass the corresponding SPI class and provide implementations for all the abstract methods. For each engine class in the API, implementation instances are requested and instantiated by calling the getInstance() factory method in the engine class. A factory method is a static method that returns an instance of a class. The engine classes use the framework provider selection mechanism described above to obtain the actual backing implementation (SPI), and then creates the actual engine object. Each instance of the engine class encapsulates (as a private field) the instance of the corresponding SPI class, known as the SPI object. All API methods of an API object are declared final and their implementations invoke the corresponding SPI methods of the encapsulated SPI object. To make this clearer, review the following code and illustration: 1234import javax.crypto.*;Cipher c = Cipher.getInstance(&quot;AES&quot;);c.init(ENCRYPT_MODE, key); Example of How Application Retrieves AES Cipher Intstance Description of Example of How Application Retrieves &quot;AES&quot; Cipher Instance Here an application wants an &quot;AES&quot; javax.crypto.Cipher instance, and doesn&apos;t care which provider is used. The application calls the getInstance() factory methods of the Cipher engine class, which in turn asks the JCA framework to find the first provider instance that supports &quot;AES&quot;. The framework consults each installed provider, and obtains the provider&apos;s instance of the Provider class. (Recall that the Provider class is a database of available algorithms.) The framework searches each provider, finally finding a suitable entry in CSP3. This database entry points to the implementation class com.foo.AESCipher which extends CipherSpi, and is thus suitable for use by the Cipher engine class. An instance of com.foo.AESCipher is created, and is encapsulated in a newly-created instance of javax.crypto.Cipher, which is returned to the application. When the application now does the init() operation on the Cipher instance, the Cipher engine class routes the request into the corresponding engineInit() backing method in the com.foo.AESCipher class. Appendix A lists the Standard Names defined for the Java environment. Other third-party providers may define their own implementations of these services, or even additional services. Key Management A database called a &quot;keystore&quot; can be used to manage a repository of keys and certificates. Keystores are available to applications that need data for authentication, encryption, or signing purposes. Applications can access a keystore via an implementation of the KeyStore class, which is in the java.security package. A default KeyStore implementation is provided by Sun Microsystems. It implements the keystore as a file, using a proprietary keystore type (format) named &quot;jks&quot;. Other keystore formats are available, such as &quot;jceks&quot; which is an alternate proprietary keystore format with much stronger encryption than &quot;jks&quot;, and &quot;pkcs12&quot;, which is based on the RSA PKCS12 Personal Information Exchange Syntax Standard. Applications can choose different keystore implementations from different providers, using the same provider mechanism described above. See the Key Management section for more information. JCA &#x6982;&#x5FF5; &#x8FD9;&#x5757;&#x4ECB;&#x7ECD;JCA &#x91CD;&#x8981;&#x7684; API. &#x5F15;&#x64CE;&#x7C7B;&#x548C;&#x7B97;&#x6CD5; An engine class provides the interface to a specific type of cryptographic service, independent of a particular cryptographic algorithm or provider. The engines either provide: cryptographic operations (encryption, digital signatures, message digests, etc.), generators or converters of cryptographic material (keys and algorithm parameters), or objects (keystores or certificates) that encapsulate the cryptographic data and can be used at higher layers of abstraction. &#x4E0B;&#x9762;&#x7684;&#x5F15;&#x64CE;&#x7C7B;&#x90FD;&#x662F;&#x53EF;&#x7528;&#x7684;: SecureRandom: used to generate random or pseudo-random numbers. MessageDigest: used to calculate the message digest (hash) of specified data. Signature: initialized with keys, these are used to sign data and verify digital signatures. Cipher: initialized with keys, these used for encrypting/decrypting data. There are various types of algorithms: symmetric bulk + encryption (e.g. AES, DES, DESede, Blowfish, IDEA), stream encryption (e.g. RC4), asymmetric encryption (e.g. RSA), and + password-based encryption (PBE). Message Authentication Codes (MAC): like MessageDigests, these also generate hash values, but are first initialized with keys + to protect the integrity of messages. KeyFactory: used to convert existing opaque cryptographic keys of type Key into key specifications (transparent representations + of the underlying key material), and vice versa. SecretKeyFactory: used to convert existing opaque cryptographic keys of type SecretKey into key specifications (transparent + representations of the underlying key material), and vice versa. SecretKeyFactorys are specialized KeyFactorys that create + secret (symmetric) keys only. KeyPairGenerator: used to generate a new pair of public and private keys suitable for use with a specified algorithm. KeyGenerator: used to generate new secret keys for use with a specified algorithm. KeyAgreement: used by two or more parties to agree upon and establish a specific key to use for a particular cryptographic + operation. AlgorithmParameters: used to store the parameters for a particular algorithm, including parameter encoding and decoding. AlgorithmParameterGenerator : used to generate a set of AlgorithmParameters suitable for a specified algorithm. KeyStore: used to create and manage a keystore. A keystore is a database of keys. Private keys in a keystore have a certificate + chain associated with them, which authenticates the corresponding public key. A keystore also contains certificates from + trusted entities. CertificateFactory: used to create public key certificates and Certificate Revocation Lists (CRLs). CertPathBuilder: used to build certificate chains (also known as certification paths). CertPathValidator: used to validate certificate chains. CertStore: used to retrieve Certificates and CRLs from a repository. NOTE: A generator creates objects with brand-new contents, whereas a factory creates objects from existing material (for example, an encoding). &#x6838;&#x5FC3;&#x7684;&#x7C7B;&#x548C;&#x63A5;&#x53E3; &#x8FD9;&#x5757;&#x8BA8;&#x8BBA;JCA&#x63D0;&#x4F9B;&#x7684;&#x6838;&#x5FC3;&#x7C7B;&#x548C;&#x63A5;&#x53E3;. the Provider and Security classes, the SecureRandom, MessageDigest, Signature, Cipher, Mac, KeyFactory, SecretKeyFactory, KeyPairGenerator, KeyGenerator, + KeyAgreement, AlgorithmParameters, AlgorithmParameterGenerator , KeyStore, and CertificateFactory, engine classes, the Key interfaces and classes, the Algorithm Parameter Specification Interfaces and Classes and the Key Specification Interfaces and Classes, and miscellaneous support and convenience interfaces and classes. NOTE: For more information on the CertPathBuilder, CertPathValidator, and CertStore engine classes, please see the Java PKI Programmer&apos;s Guide. The guide will cover the most useful high-level classes first (Provider, Security, SecureRandom, MessageDigest, Signature, Cipher, and Mac), then delve into the various support classes. For now, it is sufficient to simply say that Keys (public, private, and secret) are generated and represented by the various JCA classes, and are used by the high-level classes as part of their operation. This section shows the signatures of the main methods in each class and interface. Examples for some of these classes (MessageDigest, Signature, KeyPairGenerator, SecureRandom, KeyFactory, and key specification classes) are supplied in the corresponding Examples sections. The complete reference documentation for the relevant Security API packages can be found in the package summaries: java.security javax.crypto java.security.cert java.security.spec javax.crypto.spec java.security.interfaces javax.crypto.interfaces &#x63D0;&#x4F9B;&#x8005;&#x7C7B; The term &quot;Cryptographic Service Provider&quot; (used interchangeably with &quot;provider&quot; in this document) refers to a package or set of packages that supply a concrete implementation of a subset of the JDK Security API cryptography features. The Provider class is the interface to such a package or set of packages. It has methods for accessing the provider name, version number, and other information. Please note that in addition to registering implementations of cryptographic services, the Provider class can also be used to register implementations of other security services that might get defined as part of the JDK Security API or one of its extensions. To supply implementations of cryptographic services, an entity (e.g., a development group) writes the implementation code and creates a subclass of the Provider class. The constructor of the Provider subclass sets the values of various properties; the JDK Security API uses these values to look up the services that the provider implements. In other words, the subclass specifies the names of the classes implementing the services. Example of Provider Subclass Description of Figure Example of Provider Subclass There are several types of services that can be implemented by provider packages; for more information, see Engine Classes and Algorithms. The different implementations may have different characteristics. Some may be software-based, while others may be hardware-based. Some may be platform-independent, while others may be platform-specific. Some provider source code may be available for review and evaluation, while some may not. The JCA lets both end-users and developers decide what their needs are. In this section we explain how end-users install the cryptography implementations that fit their needs, and how developers request the implementations that fit theirs. NOTE: For information about implementing a provider, see the guide How To Implement a Provider for the Java Cryptography Architecture. How Provider Implementations Are Requested and Supplied For each engine class in the API, a implementation instance is requested and instantiated by calling one of the getInstance methods on the engine class, specifying the name of the desired algorithm and, optionally, the name of the provider (or the Provider class) whose implementation is desired. 12345678static EngineClassName getInstance(String algorithm) throws NoSuchAlgorithmExceptionstatic EngineClassName getInstance(String algorithm, String provider) throws NoSuchAlgorithmException, NoSuchProviderExceptionstatic EngineClassName getInstance(String algorithm, Provider provider) throws NoSuchAlgorithmException where EngineClassName is the desired engine type (MessageDigest/Cipher/etc). For example: 12MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);KeyAgreement ka = KeyAgreement.getInstance(&quot;DH&quot;, &quot;SunJCE&quot;); return an instance of the &quot;MD5&quot; MessageDigest and &quot;DH&quot; KeyAgreement objects, respectively. Appendix A contains the list of names that have been standardized for use with the Java environment. Some providers may choose to also include alias names that also refer to the same algorithm. For example, the &quot;SHA-1&quot; algorithm might be referred to as &quot;SHA1&quot;. Applications should use standard names instead of an alias, as not all providers may alias algorithm names in the same way. NOTE: The algorithm name is not case-sensitive. For example, all the following calls are equivalent: 123MessageDigest.getInstance(&quot;SHA-1&quot;)MessageDigest.getInstance(&quot;sha-1&quot;)MessageDigest.getInstance(&quot;sHa-1&quot;) If no provider is specified, getInstance searches the registered providers for an implementation of the requested cryptographic service associated with the named algorithm. In any given Java Virtual Machine (JVM), providers are installed in a given preference order, the order in which the provider list is searched if a specific provider is not requested. For example, suppose there are two providers installed in a JVM, PROVIDER_1 and PROVIDER_2. Assume that: PROVIDER_1 implements SHA1withDSA, SHA-1, MD5, DES, and DES3. PROVIDER_1 has preference order 1 (the highest priority). PROVIDER_2 implements SHA1withDSA, MD5withRSA, MD2withRSA, MD2, MD5, RC4, RC5, DES, and RSA. PROVIDER_2 has preference order 2. Now let&apos;s look at three scenarios: If we are looking for an MD5 implementation. Both providers supply such an implementation. The PROVIDER_1 implementation is returned since PROVIDER_1 has the highest priority and is searched first. If we are looking for an MD5withRSA signature algorithm, PROVIDER_1 is first searched for it. No implementation is found, so PROVIDER_2 is searched. Since an implementation is found, it is returned. Suppose we are looking for a SHA1withRSA signature algorithm. Since no installed provider implements it, a NoSuchAlgorithmException is thrown. The getInstance methods that include a provider argument are for developers who want to specify which provider they want an algorithm from. A federal agency, for example, will want to use a provider implementation that has received federal certification. Let&apos;s assume that the SHA1withDSA implementation from PROVIDER_1 has not received such certification, while the DSA implementation of PROVIDER_2 has received it. A federal agency program would then have the following call, specifying PROVIDER_2 since it has the certified implementation: 1Signature dsa = Signature.getInstance(&quot;SHA1withDSA&quot;, &quot;PROVIDER_2&quot;); In this case, if PROVIDER_2 was not installed, a NoSuchProviderException would be thrown, even if another installed provider implements the algorithm requested. A program also has the option of getting a list of all the installed providers (using the getProviders method in the Security class) and choosing one from the list. NOTE: General purpose applications SHOULD NOT request cryptographic services from specific providers. Otherwise, applications are tied to specific providers which may not be available on other Java implementations. They also might not be able to take advantage of available optimized providers (for example hardware accelerators via PKCS11 or native OS implementations such as Microsoft&apos;s MSCAPI) that have a higher preference order than the specific requested provider. &#x5B89;&#x88C5; Providers In order to be used, a cryptographic provider must first be installed, then registered either statically or dynamically. There are a variety of Sun providers shipped with this release (SUN, SunJCE, SunJSSE, SunRsaSign, etc.) that are already installed and registered. The following sections describe how to install and register additional providers. &#x5B89;&#x88C5; Provider Classes There are two possible ways to install the provider classes: On the normal Java classpath Place a zip or JAR file containing the classes anywhere in your classpath. Some algorithms types (Ciphers) require the provider be a signed Jar file. As an Installed/Bundled Extension The provider will be considered an installed extension if it is placed in the standard extension directory. In the JDK, that would be located in: Solaris, Linux, or Mac OS X: &lt;java-home&gt;/lib/ext Windows: &lt;java-home&gt;\\lib\\ext Here &lt;java-home&gt; refers to the directory where the runtime software is installed, which is the top-level directory of the Java Runtime Environment (JRE) or the jre directory in the Java JDK software. For example, if you have JDK 6 installed on Solaris in a directory named /home/user1/JDK1.6.0, or on Microsoft Windows in a directory named C:\\Java\\JDK1.6.0, then you need to install the JAR file in the following directory: Solaris, Linux, or Mac OS X: /home/user1/JDK1.6.0/jre/lib/ext Windows: C:\\JDK1.6.0\\jre\\lib\\ext Similarly, if you have the JRE 6 installed on Solaris in a directory named /home/user1/jre1.6.0, or on Microsoft Windows in a directory named C:\\jre1.6.0, you need to install the JAR file in the following directory: Solaris, Linux, or Mac OS X: /home/user1/jre1.6.0/lib/ext Windows: C:\\jre1.6.0\\lib\\ext For more information on how to deploy an extension, see How is an extension deployed? &#x6CE8;&#x518C; Provider The next step is to add the provider to your list of registered providers. Providers can be registered statically by editing a security properties configuration file before running a Java application, or dynamically by calling a method at runtime. To prevent the installation of rogue providers being added to the runtime environment, applications attempting to dynamically register a provider must possess the appropriate runtime privilege. Static Registration The configuration file is located in the following location: Solaris, Linux, or Mac OS X: &lt;java-home&gt;/lib/security/java.security Windows: &lt;java-home&gt;\\lib\\security\\java.security For each registered provider, this file should have a statement of the following form: security.provider.n=masterClassName This declares a provider, and specifies its preference order n. The preference order is the order in which providers are searched for requested algorithms (when no specific provider is requested). The order is 1-based: 1 is the most preferred, followed by 2, and so on. masterClassName must specify the fully qualified name of provider&apos;s master class. The provider&apos;s documentation will specify its master class. This class is always a subclass of the Provider class. The subclass constructor sets the values of various properties that are required for the Java Cryptography API to look up the algorithms or other facilities the provider implements. The JDK comes standard with automatically installed and configured providers such as &quot;SUN&quot; and &quot;SunJCE&quot;. The &quot;SUN&quot; provider&apos;s master class is the SUN class in the sun.security.provider package, and the corresponding java.security file entry is as follows: security.provider.5=sun.security.provider.Sun To utilize another JCA provider, add a line referencing the alternate provider, specify the preference order ( making corresponding adjustments to the other providers&apos; orders, if needed). Suppose that the master class of CompanyX&apos;s provider is com.companyx.provider.ProviderX, and that you would like to configure this provider as the eighth most-preferred. To do so, you would add the following line to the java.security file: security.provider.8=com.companyx.provider.ProviderX Dynamic Registration To register providers dynamically, applications call either the addProvider or insertProviderAt method in the Security class. This type of registration is not persistent across VM instances, and can only be done by &quot;trusted&quot; programs with the appropriate privilege. See Security. Setting Provider Permissions Whenever encryption providers are used (that is, those that supply implementations of Cipher, KeyAgreement, KeyGenerator, Mac, or SecretKeyFactory), and the provider is not an installed extension Permissions may need to be granted for when applets or applications using JCA are run while a security manager is installed. There is typically a security manager installed whenever an applet is running, and a security manager may be installed for an application either via code in the application itself or via a command-line argument. Permissions do not need to be granted to installed extensions, since the default system policy configuration file grants all permissions to installed extensions (that is, installed in the extensions directory). The documentation from the vendor of each provider you will be using should include information as to which permissions it requires, and how to grant such permissions. For example, the following permissions may be needed by a provider if it is not an installed extension and a security manager is installed: java.lang.RuntimePermission &quot;getProtectionDomain&quot; to get class protection domains. The provider may need to get its own protection domain in the process of doing self-integrity checking. java.security.SecurityPermission &quot;putProviderProperty.{name}&quot; to set provider properties, where {name} is replaced by the actual provider name. For example, a sample statement granting permissions to a provider whose name is &quot;MyJCE&quot; and whose code is in myjce_provider.jar appears below. Such a statement could appear in a policy file. In this example, the myjce_provider.jar file is assumed to be in the /localWork directory. 12345grant codeBase &quot;file:/localWork/myjce_provider.jar&quot; { permission java.lang.RuntimePermission &quot;getProtectionDomain&quot;; permission java.security.SecurityPermission &quot;putProviderProperty.MyJCE&quot;; }; Provider Class Methods Each Provider class instance has a (currently case-sensitive) name, a version number, and a string description of the provider and its services. You can query the Provider instance for this information by calling the following methods: 123public String getName()public double getVersion()public String getInfo() The Security Class The Security class manages installed providers and security-wide properties. It only contains static methods and is never instantiated. The methods for adding or removing providers, and for setting Security properties, can only be executed by a trusted program. Currently, a &quot;trusted program&quot; is either a local application not running under a security manager, or an applet or application with permission to execute the specified method (see below). The determination that code is considered trusted to perform an attempted action (such as adding a provider) requires that the applet is granted the proper permission(s) for that particular action. The policy configuration file(s) for a JDK installation specify what permissions (which types of system resource accesses) are allowed by code from specified code sources. (See below and the &quot;Default Policy Implementation and Policy File Syntax&quot; and &quot;Java Security Architecture Specification&quot; files for more information.) Code being executed is always considered to come from a particular &quot;code source&quot;. The code source includes not only the location (URL) where the code originated from, but also a reference to any public key(s) corresponding to the private key(s) that may have been used to sign the code. Public keys in a code source are referenced by (symbolic) alias names from the user&apos;s keystore. In a policy configuration file, a code source is represented by two components: a code base (URL), and an alias name (preceded by signedBy), where the alias name identifies the keystore entry containing the public key that must be used to verify the code&apos;s signature. Each &quot;grant&quot; statement in such a file grants a specified code source a set of permissions, specifying which actions are allowed. &#x4E00;&#x4E2A;&#x7B80;&#x5355;&#x7684;&#x7B56;&#x7565;&#x914D;&#x7F6E;&#x6587;&#x4EF6;: 12345grant codeBase &quot;file:/home/sysadmin/&quot;, signedBy &quot;sysadmin&quot; { permission java.security.SecurityPermission &quot;insertProvider.*&quot;; permission java.security.SecurityPermission &quot;removeProvider.*&quot;; permission java.security.SecurityPermission &quot;putProviderProperty.*&quot;;}; This configuration file specifies that code loaded from a signed JAR file from beneath the /home/sysadmin/ directory on the local file system can add or remove providers or set provider properties. (Note that the signature of the JAR file can be verified using the public key referenced by the alias name sysadmin in the user&apos;s keystore.) Either component of the code source (or both) may be missing. Here&apos;s an example of a configuration file where the codeBase is omitted: 1234grant signedBy &quot;sysadmin&quot; { permission java.security.SecurityPermission &quot;insertProvider.*&quot;; permission java.security.SecurityPermission &quot;removeProvider.*&quot;;}; If this policy is in effect, code that comes in a JAR File signed by sysadmin can add/remove providers--regardless of where the JAR File originated. Here&apos;s an example without a signer: 1234grant codeBase &quot;file:/home/sysadmin/&quot; { permission java.security.SecurityPermission &quot;insertProvider.*&quot;; permission java.security.SecurityPermission &quot;removeProvider.*&quot;;}; In this case, code that comes from anywhere within the /home/sysadmin/ directory on the local filesystem can add/remove providers. The code does not need to be signed. An example where neither codeBase nor signedBy is included is: 1234grant { permission java.security.SecurityPermission &quot;insertProvider.*&quot;; permission java.security.SecurityPermission &quot;removeProvider.*&quot;;}; Here, with both code source components missing, any code (regardless of where it originates, or whether or not it is signed, or who signed it) can add/remove providers. Obviously, this is definitely NOT recommended, as this grant could open a security hole. Untrusted code could install a Provider, thus affecting later code that is depending on a properly functioning implementation. (For example, a rogue Cipher object might capture and store the sensitive information it receives.) Managing Providers The following tables summarize the methods in the Security class you can use to query which Providers are installed, as well as to install or remove providers at runtime. Querying Providers Method Description static Provider[] getProviders() Returns an array containing all the installed providers (technically, the Provider subclass for each package provider). The order of the Providers in the array is their preference order. static Provider getProvider(String providerName) Returns the Provider named providerName. It returns null if the Provider is not found. Adding Providers Method Description static int addProvider(Provider provider) Adds a Provider to the end of the list of installed Providers. It returns the preference position in which the Provider was added, or -1 if the Provider was not added because it was already installed. static int insertProviderAt (Provider provider, int position) Adds a new Provider at a specified position. If the given provider is installed at the requested position, the provider formerly at that position and all providers with a position greater than position are shifted up one position (towards the end of the list). This method returns the preference position in which the Provider was added, or -1 if the Provider was not added because it was already installed. Removing Providers Method Description static void removeProvider(String name) Removes the Provider with the specified name. It returns silently if the provider is not installed. When the specified provider is removed, all providers located at a position greater than where the specified provider was are shifted down one position (towards the head of the list of installed providers). NOTE: If you want to change the preference position of a provider, you must first remove it, and then insert it back in at the new preference position. Security Properties The Security class maintains a list of system-wide security properties. These properties are similar to the System properties, but are security-related. These properties can be set statically or dynamically. We have already seen an example of static security properties (that is, registering a provider statically via the &quot;security.provider.i&quot; security property). If you want to set properties dynamically, trusted programs can use the following methods: 12static String getProperty(String key)static void setProperty(String key, String datum) Note: the list of security providers is established during VM startup, therefore the methods described above must be used to alter the provider list. As a reminder, the configuration file is located in the following location: Solaris, Linux, or Mac OS X: &lt;java-home&gt;/lib/security/java.security Windows: &lt;java-home&gt;\\lib\\security\\java.security The SecureRandom Class The SecureRandom class is an engine class that provides the functionality of a Random Number Generator (RNG). It differs from the java.lang.Random class in that it produces cryptographically strong random numbers. If there is insufficient randomness in a generator, it makes it much easier to compromise your protection mechanisms. Random numbers are used throughout cryptography, such as generating cryptographic keys, algorithmic parameters, and so on. All Java SE implementations must indicate the strongest (most random) implementation of SecureRandom that they provide in the securerandom.strongAlgorithms property of the java.security.Security class. This implementation can be used when a particularly strong random value is required. The SecureRandom Class Description of The SecureRandom Class &#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x5B89;&#x5168;&#x968F;&#x673A;&#x6570;&#x751F;&#x6210;&#x5668;&#x5BF9;&#x8C61; There are several ways to obtain an instance of SecureRandom: All Java SE implementations provide a default SecureRandom using the no-argument constructor: new SecureRandom(). To get a specific implementation of SecureRandom, use one of the getInstance() static factory methods. Use the getInstanceStrong() method to obtain a strong SecureRandom implementation as defined by the securerandom.strongAlgorithms property of the java.security.Security class. This property lists platform implementations that are suitable for generating important values. Seeding or Re-Seeding the SecureRandom Object The SecureRandom implementation attempts to completely randomize the internal state of the generator itself unless the caller follows the call to a getInstance method with a call to one of the setSeed methods: synchronized public void setSeed(byte[] seed) public void setSeed(long seed) Once the SecureRandom object has been seeded, it will produce bits as random as the original seeds. At any time a SecureRandom object may be re-seeded using one of the setSeed methods. The given seed supplements, rather than replaces, the existing seed; therefore, repeated calls are guaranteed never to reduce randomness. Using a SecureRandom Object To get random bytes, a caller simply passes an array of any length, which is then filled with random bytes: synchronized public void nextBytes(byte[] bytes) Generating Seed Bytes If desired, it is possible to invoke the generateSeed method to generate a given number of seed bytes (to seed other random number generators, for example): byte[] generateSeed(int numBytes) The MessageDigest Class The MessageDigest class is an engine class designed to provide the functionality of cryptographically secure message digests such as SHA-1 or MD5. A cryptographically secure message digest takes arbitrary-sized input (a byte array), and generates a fixed-size output, called a digest or hash. The MessageDigest Class Description of Figure The MessageDigest Class For example, the MD5 algorithm produces a 16 byte digest, and SHA1&apos;s is 20 bytes. A digest has two properties: It should be computationally infeasible to find two messages that hash to the same value. The digest should not reveal anything about the input that was used to generate it. Message digests are used to produce unique and reliable identifiers of data. They are sometimes called &quot;checksums&quot; or the &quot;digital fingerprints&quot; of the data. Changes to just one bit of the message should produce a different digest value. Message digests have many uses and can determine when data has been modified, intentionally or not. Recently, there has been considerable effort to determine if there are any weaknesses in popular algorithms, with mixed results. When selecting a digest algorithm, one should always consult a recent reference to determine its status and appropriateness for the task at hand. &#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x6D88;&#x606F;&#x7B7E;&#x540D;&#x5BF9;&#x8C61; The first step for computing a digest is to create a message digest instance. MessageDigest objects are obtained by using one of the getInstance() static factory methods in the MessageDigest class. The factory method returns an initialized message digest object. It thus does not need further initialization. &#x66F4;&#x65B0;&#x6D88;&#x606F;&#x7B7E;&#x540D;&#x5BF9;&#x8C61; The next step for calculating the digest of some data is to supply the data to the initialized message digest object. It can be provided all at once, or in chunks. Pieces can be fed to the message digest by calling one of the update methods: 123void update(byte input)void update(byte[] input)void update(byte[] input, int offset, int len) &#x8BA1;&#x7B97;&#x7B7E;&#x540D; After the data chunks have been supplied by calls to update, the digest is computed using a call to one of the digest methods: 123byte[] digest()byte[] digest(byte[] input)int digest(byte[] buf, int offset, int len) The first method return the computed digest. The second method does a final update(input) with the input byte array before calling digest(), which returns the digest byte array. The last method stores the computed digest in the provided buffer buf, starting at offset. len is the number of bytes in buf allotted for the digest, the method returns the number of bytes actually stored in buf. If there is not enough room in the buffer, the method will throw an exception. Please see the Computing a MessageDigest example in the Code Examples section for more details. The Signature Class The Signature class is an engine class designed to provide the functionality of a cryptographic digital signature algorithm such as DSA or RSAwithMD5. A cryptographically secure signature algorithm takes arbitrary-sized input and a private key and generates a relatively short (often fixed-size) string of bytes, called the signature, with the following properties: Only the owner of a private/public key pair is able to create a signature. It should be computationally infeasible for anyone having a public key to recover the private key. Given the public key corresponding to the private key used to generate the signature, it should be possible to verify the authenticity and integrity of the input. The signature and the public key do not reveal anything about the private key. It can also be used to verify whether or not an alleged signature is in fact the authentic signature of the data associated with it. The Signature Class Description of Figure The Signature Class A Signature object is initialized for signing with a Private Key and is given the data to be signed. The resulting signature bytes are typically kept with the signed data. When verification is needed, another Signature object is created and initialized for verification and given the corresponding Public Key. The data and the signature bytes are fed to the signature object, and if the data and signature match, the Signature object reports success. Even though a signature seems similar to a message digest, they have very different purposes in the type of protection they provide. In fact, algorithms such as &quot;SHA1WithRSA&quot; use the message digest &quot;SHA1&quot; to initially &quot;compress&quot; the large data sets into a more manageable form, then sign the resulting 20 byte message digest with the &quot;RSA&quot; algorithm. Please see the Examples section for an example of signing and verifying data. Signature Object States Signature objects are modal objects. This means that a Signature object is always in a given state, where it may only do one type of operation. States are represented as final integer constants defined in their respective classes. &#x7B7E;&#x540D;&#x5BF9;&#x8C61;&#x53EF;&#x80FD;&#x5904;&#x4E8E;&#x7684;&#x4E09;&#x79CD;&#x72B6;&#x6001;: &#x672A;&#x521D;&#x59CB;&#x5316;(UNINITIALIZED) &#x7B7E;&#x540D;(SIGN) &#x9A8C;&#x8BC1;(VERIFY) When it is first created, a Signature object is in the UNINITIALIZED state. The Signature class defines two initialization methods, initSign and initVerify, which change the state to SIGN and VERIFY, respectively. Creating a Signature Object The first step for signing or verifying a signature is to create a Signature instance. Signature objects are obtained by using one of the Signature getInstance() static factory methods. Initializing a Signature Object A Signature object must be initialized before it is used. The initialization method depends on whether the object is going to be used for signing or for verification. If it is going to be used for signing, the object must first be initialized with the private key of the entity whose signature is going to be generated. This initialization is done by calling the method: final void initSign(PrivateKey privateKey) This method puts the Signature object in the SIGN state. If instead the Signature object is going to be used for verification, it must first be initialized with the public key of the entity whose signature is going to be verified. This initialization is done by calling either of these methods: 123final void initVerify(PublicKey publicKey)final void initVerify(Certificate certificate) This method puts the Signature object in the VERIFY state. Signing If the Signature object has been initialized for signing (if it is in the SIGN state), the data to be signed can then be supplied to the object. This is done by making one or more calls to one of the update methods: 123final void update(byte b)final void update(byte[] data)final void update(byte[] data, int off, int len) Calls to the update method(s) should be made until all the data to be signed has been supplied to the Signature object. To generate the signature, simply call one of the sign methods: 12final byte[] sign()final int sign(byte[] outbuf, int offset, int len) The first method returns the signature result in a byte array. The second stores the signature result in the provided buffer outbuf, starting at offset. len is the number of bytes in outbuf allotted for the signature. The method returns the number of bytes actually stored. Signature encoding is algorithm specific. See the Standard Names document for more information about the use of ASN.1 encoding in the Java Cryptography Architecture. A call to a sign method resets the signature object to the state it was in when previously initialized for signing via a call to initSign. That is, the object is reset and available to generate another signature with the same private key, if desired, via new calls to update and sign. Alternatively, a new call can be made to initSign specifying a different private key, or to initVerify (to initialize the Signature object to verify a signature). Verifying If the Signature object has been initialized for verification (if it is in the VERIFY state), it can then verify if an alleged signature is in fact the authentic signature of the data associated with it. To start the process, the data to be verified (as opposed to the signature itself) is supplied to the object. The data is passed to the object by calling one of the update methods: 123final void update(byte b)final void update(byte[] data)final void update(byte[] data, int off, int len) Calls to the update method(s) should be made until all the data to be verified has been supplied to the Signature object. The signature can now be verified by calling one of the verify methods: 123final boolean verify(byte[] signature)final boolean verify(byte[] signature, int offset, int length) The argument must be a byte array containing the signature. This byte array would hold the signature bytes which were returned by a previous call to one of the sign methods. The verify method returns a boolean indicating whether or not the encoded signature is the authentic signature of the data supplied to the update method(s). A call to the verify method resets the signature object to its state when it was initialized for verification via a call to initVerify. That is, the object is reset and available to verify another signature from the identity whose public key was specified in the call to initVerify. Alternatively, a new call can be made to initVerify specifying a different public key (to initialize the Signature object for verifying a signature from a different entity), or to initSign (to initialize the Signature object for generating a signature). The Cipher Class The Cipher class provides the functionality of a cryptographic cipher used for encryption and decryption. Encryption is the process of taking data (called cleartext) and a key, and producing data (ciphertext) meaningless to a third-party who does not know the key. Decryption is the inverse process: that of taking ciphertext and a key and producing cleartext. The Cipher Class Description of Figure The Cipher Class Symmetric vs. Asymmetric Cryptography There are two major types of encryption: symmetric (also known as secret key), and asymmetric (or public key cryptography). In symmetric cryptography, the same secret key to both encrypt and decrypt the data. Keeping the key private is critical to keeping the data confidential. On the other hand, asymmetric cryptography uses a public/private key pair to encrypt data. Data encrypted with one key is decrypted with the other. A user first generates a public/private key pair, and then publishes the public key in a trusted database that anyone can access. A user who wishes to communicate securely with that user encrypts the data using the retrieved public key. Only the holder of the private key will be able to decrypt. Keeping the private key confidential is critical to this scheme. Asymmetric algorithms (such as RSA) are generally much slower than symmetric ones. These algorithms are not designed for efficiently protecting large amounts of data. In practice, asymmetric algorithms are used to exchange smaller secret keys which are used to initialize symmetric algorithms. Stream vs. Block Ciphers There are two major types of ciphers: block and stream. Block ciphers process entire blocks at a time, usually many bytes in length. If there is not enough data to make a complete input block, the data must be padded: that is, before encryption, dummy bytes must be added to make a multiple of the cipher&apos;s block size. These bytes are then stripped off during the decryption phase. The padding can either be done by the application, or by initializing a cipher to use a padding type such as &quot;PKCS5PADDING&quot;. In contrast, stream ciphers process incoming data one small unit (typically a byte or even a bit) at a time. This allows for ciphers to process an arbitrary amount of data without padding. &#x5DE5;&#x4F5C;&#x6A21;&#x5F0F; When encrypting using a simple block cipher, two identical blocks of plaintext will always produce an identical block of cipher text. Cryptanalysts trying to break the ciphertext will have an easier job if they note blocks of repeating text. In order to add more complexity to the text, feedback modes use the previous block of output to alter the input blocks before applying the encryption algorithm. The first block will need an initial value, and this value is called the initialization vector (IV). Since the IV simply alters the data before any encryption, the IV should be random but does not necessarily need to be kept secret. There are a variety of modes, such as CBC (Cipher Block Chaining), CFB (Cipher Feedback Mode), and OFB (Output Feedback Mode). ECB (Electronic Cookbook Mode) is a mode with no feedback. Some algorithms such as AES and RSA allow for keys of different lengths, but others are fixed, such as DES and 3DES. Encryption using a longer key generally implies a stronger resistance to message recovery. As usual, there is a trade off between security and time, so choose the key length appropriately. Most algorithms use binary keys. Most humans do not have the ability to remember long sequences of binary numbers, even when represented in hexadecimal. Character passwords are much easier to recall. Because character passwords are generally chosen from a small number of characters (for example, [a-zA-Z0-9]), protocols such as &quot;Password-Based Encryption&quot; (PBE) have been defined which take character passwords and generate strong binary keys. In order to make the task of getting from password to key very time-consuming for an attacker (via so-called &quot;dictionary attacks&quot; where common dictionary word-&gt;value mappings are precomputed), most PBE implementations will mix in a random number, known as a salt, to increase the key randomness. Newer cipher modes such as Authenticated Encryption with Associated Data (AEAD) (for example, Galois/Counter Mode (GCM)) encrypt data and authenticate the resulting message simultaneously. Additional Associated Data (AAD) can be used during the calculation of the resulting AEAD tag (Mac), but this AAD data is not output as ciphertext. (For example, some data might not need to be kept confidential, but should figure into the tag calculation to detect modifications.) The Cipher.updateAAD() methods can be used to include AAD in the tag calculations. Using an AES Cipher with GCM Mode AES Cipher with GCM is an AEAD Cipher which has different usage patterns than the non-AEAD ciphers. Apart from the regular data, it also takes AAD which is optional for encryption/decryption but AAD must be supplied before data for encryption/decryption. In addition, in order to use GCM securely, callers should not re-use key and IV combinations for encryption. This means that the cipher object should be explicitly re-initialized with a different set of parameters every time for each encryption operation. 1234567891011121314151617181920212223SecretKey myKey = ...byte[] myAAD = ...byte[] plainText = ... int myTLen = ... byte[] myIv = ...GCMParameterSpec myParams = new GCMParameterSpec(myTLen, myIv);Cipher c = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);c.init(Cipher.ENCRYPT_MODE, myKey, myParams);// AAD is optional, if present, it must be supplied before any update/doFinal calls.c.updateAAD(myAAD); // if AAD is non-nullbyte[] cipherText = new byte[c.getOutputSize(plainText.length)];c.doFinal(plainText, 0, plainText.length, cipherText); // conclusion of encryption operation// To decrypt, same AAD and GCM parameters must be suppliedc.init(Cipher.DECRYPT_MODE, myKey, myParams);c.updateAAD(myAAD);byte[] recoveredText = c.doFinal(cipherText);// MUST CHANGE IV VALUE if the same key were to be used again for encryption byte[] newIv = ...;myParams = new GCMParameterSpec(myTLen, newIv); Creating a Cipher Object Cipher objects are obtained by using one of the Cipher getInstance() static factory methods. Here, the algorithm name is slightly different than with other engine classes, in that it specifies not just an algorithm name, but a &quot;transformation&quot;. A transformation is a string that describes the operation (or set of operations) to be performed on the given input to produce some output. A transformation always includes the name of a cryptographic algorithm (e.g., DES), and may be followed by a mode and padding scheme. A transformation is of the form: &quot;algorithm/mode/padding&quot; or &quot;algorithm&quot; For example, the following are valid transformations: &quot;DES/CBC/PKCS5Padding&quot; &quot;DES&quot; If just a transformation name is specified, the system will determine if there is an implementation of the requested transformation available in the environment, and if there is more than one, returns there is a preferred one. If both a transformation name and a package provider are specified, the system will determine if there is an implementation of the requested transformation in the package requested, and throw an exception if there is not. It is recommended to use a transformation that fully specifies the algorithm, mode, and padding. By not doing so, the provider will use a default. For example, the SunJCE and SunPKCS11 providers use ECB as the default mode, and PKCS5Padding as the default padding for many symmetric ciphers. This means that in the case of the SunJCE provider: 1Cipher c1 = Cipher.getInstance(&quot;DES/ECB/PKCS5Padding&quot;); and 1Cipher c1 = Cipher.getInstance(&quot;DES&quot;); are equivalent statements. Note: ECB mode is the easiest block cipher mode to use and is the default in the JDK/JRE. ECB works well for single blocks of data, but absolutely should not be used for multiple data blocks. Using modes such as CFB and OFB, block ciphers can encrypt data in units smaller than the cipher&apos;s actual block size. When requesting such a mode, you may optionally specify the number of bits to be processed at a time by appending this number to the mode name as shown in the &quot;DES/CFB8/NoPadding&quot; and &quot;DES/OFB32/PKCS5Padding&quot; transformations. If no such number is specified, a provider-specific default is used. (For example, the SunJCE provider uses a default of 64 bits for DES.) Thus, block ciphers can be turned into byte-oriented stream ciphers by using an 8 bit mode such as CFB8 or OFB8. Appendix A of this document contains a list of standard names that can be used to specify the algorithm name, mode, and padding scheme components of a transformation. The objects returned by factory methods are uninitialized, and must be initialized before they become usable. Initializing a Cipher Object A Cipher object obtained via getInstance must be initialized for one of four modes, which are defined as final integer constants in the Cipher class. The modes can be referenced by their symbolic names, which are shown below along with a description of the purpose of each mode: ENCRYPT_MODE Encryption of data. DECRYPT_MODE Decryption of data. WRAP_MODE Wrapping a java.security.Key into bytes so that the key can be securely transported. UNWRAP_MODE Unwrapping of a previously wrapped key into a java.security.Key object. Each of the Cipher initialization methods takes an operational mode parameter (opmode), and initializes the Cipher object for that mode. Other parameters include the key (key) or certificate containing the key (certificate), algorithm parameters (params), and a source of randomness (random). To initialize a Cipher object, call one of the following init methods: 12345678public void init(int opmode, Key key);public void init(int opmode, Certificate certificate);public void init(int opmode, Key key, SecureRandom random);public void init(int opmode, Certificate certificate, SecureRandom random);public void init(int opmode, Key key, AlgorithmParameterSpec params);public void init(int opmode, Key key, AlgorithmParameterSpec params, SecureRandom random);public void init(int opmode, Key key, AlgorithmParameters params);public void init(int opmode, Key key, AlgorithmParameters params, SecureRandom random); If a Cipher object that requires parameters (e.g., an initialization vector) is initialized for encryption, and no parameters are supplied to the init method, the underlying cipher implementation is supposed to supply the required parameters itself, either by generating random parameters or by using a default, provider-specific set of parameters. However, if a Cipher object that requires parameters is initialized for decryption, and no parameters are supplied to the init method, an InvalidKeyException or InvalidAlgorithmParameterException exception will be raised, depending on the init method that has been used. See the section about Managing Algorithm Parameters for more details. The same parameters that were used for encryption must be used for decryption. Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher, and initializing it. For example, if a Cipher is first initialized for decryption with a given key, and then initialized for encryption, it will lose any state acquired while in decryption mode. &#x52A0;&#x5BC6;&#x548C;&#x89E3;&#x5BC6;&#x6570;&#x636E; Data can be encrypted or decrypted in one step (single-part operation) or in multiple steps (multiple-part operation). A multiple-part operation is useful if you do not know in advance how long the data is going to be, or if the data is too long to be stored in memory all at once. To encrypt or decrypt data in a single step, call one of the doFinal methods: 1234public byte[] doFinal(byte[] input);public byte[] doFinal(byte[] input, int inputOffset, int inputLen);public int doFinal(byte[] input, int inputOffset, int inputLen, byte[] output);public int doFinal(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) To encrypt or decrypt data in multiple steps, call one of the update methods: 1234public byte[] update(byte[] input);public byte[] update(byte[] input, int inputOffset, int inputLen);public int update(byte[] input, int inputOffset, int inputLen, byte[] output);public int update(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) A multiple-part operation must be terminated by one of the above doFinal methods (if there is still some input data left for the last step), or by one of the following doFinal methods (if there is no input data left for the last step): 12public byte[] doFinal();public int doFinal(byte[] output, int outputOffset); All the doFinal methods take care of any necessary padding (or unpadding), if padding (or unpadding) has been requested as part of the specified transformation. A call to doFinal resets the Cipher object to the state it was in when initialized via a call to init. That is, the Cipher object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to init) more data. &#x5305;&#x88C5;&#x548C;&#x89E3;&#x5305;&#x5BC6;&#x94A5; Wrapping a key enables secure transfer of the key from one place to another. The wrap/unwrap API makes it more convenient to write code since it works with key objects directly. These methods also enable the possibility of secure transfer of hardware-based keys. To wrap a Key, first initialize the Cipher object for WRAP_MODE, and then call the following: 1public final byte[] wrap(Key key); If you are supplying the wrapped key bytes (the result of calling wrap) to someone else who will unwrap them, be sure to also send additional information the recipient will need in order to do the unwrap: the name of the key algorithm, and the type of the wrapped key (one of Cipher.SECRET_KEY, Cipher.PRIVATE_KEY, or Cipher.PUBLIC_KEY). The key algorithm name can be determined by calling the getAlgorithm method from the Key interface: 1public String getAlgorithm(); To unwrap the bytes returned by a previous call to wrap, first initialize a Cipher object for UNWRAP_MODE, then call the following: 1public final Key unwrap(byte[] wrappedKey, String wrappedKeyAlgorithm, int wrappedKeyType)); Here, wrappedKey is the bytes returned from the previous call to wrap, wrappedKeyAlgorithm is the algorithm associated with the wrapped key, and wrappedKeyType is the type of the wrapped key. This must be one of Cipher.SECRET_KEY, Cipher.PRIVATE_KEY, or Cipher.PUBLIC_KEY. &#x7BA1;&#x7406;&#x7B97;&#x6CD5;&#x53C2;&#x6570; The parameters being used by the underlying Cipher implementation, which were either explicitly passed to the init method by the application or generated by the underlying implementation itself, can be retrieved from the Cipher object by calling its getParameters method, which returns the parameters as a java.security.AlgorithmParameters object (or null if no parameters are being used). If the parameter is an initialization vector (IV), it can also be retrieved by calling the getIV method. In the following example, a Cipher object implementing password-based encryption (PBE) is initialized with just a key and no parameters. However, the selected algorithm for password-based encryption requires two parameters - a salt and an iteration count. Those will be generated by the underlying algorithm implementation itself. The application can retrieve the generated parameters from the Cipher object as follows: 123456789101112131415161718192021import javax.crypto.*;import java.security.AlgorithmParameters;// get cipher object for password-based encryptionCipher c = Cipher.getInstance(&quot;PBEWithHmacSHA256AndAES_256&quot;);// initialize cipher for encryption, without supplying// any parameters. Here, &quot;myKey&quot; is assumed to refer// to an already-generated key.c.init(Cipher.ENCRYPT_MODE, myKey);// encrypt some data and store away ciphertext// for later decryptionbyte[] cipherText = c.doFinal(&quot;This is just an example&quot;.getBytes());// retrieve parameters generated by underlying cipher// implementationAlgorithmParameters algParams = c.getParameters();// get parameter encoding and store it awaybyte[] encodedAlgParams = algParams.getEncoded(); The same parameters that were used for encryption must be used for decryption. They can be instantiated from their encoding and used to initialize the corresponding Cipher object for decryption, as follows: 1234567891011121314151617import javax.crypto.*;import java.security.AlgorithmParameters;// get parameter object for password-based encryptionAlgorithmParameters algParams;algParams = AlgorithmParameters.getInstance(&quot;PBEWithHmacSHA256AndAES_256&quot;);// initialize with parameter encoding from abovealgParams.init(encodedAlgParams);// get cipher object for password-based encryptionCipher c = Cipher.getInstance(&quot;PBEWithHmacSHA256AndAES_256&quot;);// initialize cipher for decryption, using one of the// init() methods that takes an AlgorithmParameters// object, and pass it the algParams object from abovec.init(Cipher.DECRYPT_MODE, myKey, algParams); If you did not specify any parameters when you initialized a Cipher object, and you are not sure whether or not the underlying implementation uses any parameters, you can find out by simply calling the getParameters method of your Cipher object and checking the value returned. A return value of null indicates that no parameters were used. The following cipher algorithms implemented by the SunJCE provider use parameters: DES, DES-EDE, and Blowfish, when used in feedback (i.e., CBC, CFB, OFB, or PCBC) mode, use an initialization vector (IV). The javax.crypto.spec.IvParameterSpec class can be used to initialize a Cipher object with a given IV. PBE Cipher algorithms use a set of parameters, comprising of a salt and an iteration count. The javax.crypto.spec.PBEParameterSpec class can be used to initialize a Cipher object implementing a PBE algorithm (for example: PBEWithHmacSHA256AndAES_256) with a given salt and iteration count. Note that you do not have to worry about storing or transferring any algorithm parameters for use by the decryption operation if you use the SealedObject class. This class attaches the parameters used for sealing (encryption) to the encrypted object contents, and uses the same parameters for unsealing (decryption). Cipher Output Considerations Some of the update and doFinal methods of Cipher allow the caller to specify the output buffer into which to encrypt or decrypt the data. In these cases, it is important to pass a buffer that is large enough to hold the result of the encryption or decryption operation. The following method in Cipher can be used to determine how big the output buffer should be: 1public int getOutputSize(int inputLen) Other Cipher-based Classes There are some helper classes which internally use Ciphers to provide easy access to common cipher uses. The Cipher Stream Classes The CipherInputStream Class This class is a FilterInputStream that encrypts or decrypts the data passing through it. It is composed of an InputStream, or one of its subclasses, and a Cipher. CipherInputStream represents a secure input stream into which a Cipher object has been interposed. The read methods of CipherInputStream return data that are read from the underlying InputStream but have additionally been processed by the embedded Cipher object. The Cipher object must be fully initialized before being used by a CipherInputStream. For example, if the embedded Cipher has been initialized for decryption, the CipherInputStream will attempt to decrypt the data it reads from the underlying InputStream before returning them to the application. This class adheres strictly to the semantics, especially the failure semantics, of its ancestor classes java.io.FilterInputStream and java.io.InputStream. This class has exactly those methods specified in its ancestor classes, and overrides them all, so that the data are additionally processed by the embedded cipher. Moreover, this class catches all exceptions that are not thrown by its ancestor classes. In particular, the skip(long) method skips only data that has been processed by the Cipher. It is crucial for a programmer using this class not to use methods that are not defined or overridden in this class (such as a new method or constructor that is later added to one of the super classes), because the design and implementation of those methods are unlikely to have considered security impact with regard to CipherInputStream. As an example of its usage, suppose cipher1 has been initialized for encryption. The code below demonstrates how to use a CipherInputStream containing that cipher and a FileInputStream in order to encrypt input stream data: 1234567891011121314FileInputStream fis;FileOutputStream fos;CipherInputStream cis;fis = new FileInputStream(&quot;/tmp/a.txt&quot;);cis = new CipherInputStream(fis, cipher1);fos = new FileOutputStream(&quot;/tmp/b.txt&quot;);byte[] b = new byte[8];int i = cis.read(b);while (i != -1) { fos.write(b, 0, i); i = cis.read(b);}fos.close(); The above program reads and encrypts the content from the file /tmp/a.txt and then stores the result (the encrypted bytes) in /tmp/b.txt. The following example demonstrates how to easily connect several instances of CipherInputStream and FileInputStream. In this example, assume that cipher1 and cipher2 have been initialized for encryption and decryption (with corresponding keys), respectively. 123456789101112131415FileInputStream fis;FileOutputStream fos;CipherInputStream cis1, cis2;fis = new FileInputStream(&quot;/tmp/a.txt&quot;);cis1 = new CipherInputStream(fis, cipher1);cis2 = new CipherInputStream(cis1, cipher2);fos = new FileOutputStream(&quot;/tmp/b.txt&quot;);byte[] b = new byte[8];int i = cis2.read(b);while (i != -1) { fos.write(b, 0, i); i = cis2.read(b);}fos.close(); The above program copies the content from file /tmp/a.txt to /tmp/b.txt, except that the content is first encrypted and then decrypted back when it is read from /tmp/a.txt. Of course since this program simply encrypts text and decrypts it back right away, it&apos;s actually not very useful except as a simple way of illustrating chaining of CipherInputStreams. Note that the read methods of the CipherInputStream will block until data is returned from the underlying cipher. If a block cipher is used, a full block of cipher text will have to be obtained from the underlying InputStream. The CipherOutputStream Class This class is a FilterOutputStream that encrypts or decrypts the data passing through it. It is composed of an OutputStream, or one of its subclasses, and a Cipher. CipherOutputStream represents a secure output stream into which a Cipher object has been interposed. The write methods of CipherOutputStream first process the data with the embedded Cipher object before writing them out to the underlying OutputStream. The Cipher object must be fully initialized before being used by a CipherOutputStream. For example, if the embedded Cipher has been initialized for encryption, the CipherOutputStream will encrypt its data, before writing them out to the underlying output stream. This class adheres strictly to the semantics, especially the failure semantics, of its ancestor classes java.io.OutputStream and java.io.FilterOutputStream. This class has exactly those methods specified in its ancestor classes, and overrides them all, so that all data are additionally processed by the embedded cipher. Moreover, this class catches all exceptions that are not thrown by its ancestor classes. It is crucial for a programmer using this class not to use methods that are not defined or overridden in this class (such as a new method or constructor that is later added to one of the super classes), because the design and implementation of those methods are unlikely to have considered security impact with regard to CipherOutputStream. As an example of its usage, suppose cipher1 has been initialized for encryption. The code below demonstrates how to use a CipherOutputStream containing that cipher and a FileOutputStream in order to encrypt data to be written to an output stream: 1234567891011121314FileInputStream fis;FileOutputStream fos;CipherOutputStream cos;fis = new FileInputStream(&quot;/tmp/a.txt&quot;);fos = new FileOutputStream(&quot;/tmp/b.txt&quot;);cos = new CipherOutputStream(fos, cipher1);byte[] b = new byte[8];int i = fis.read(b);while (i != -1) { cos.write(b, 0, i); i = fis.read(b);}cos.flush(); The above program reads the content from the file /tmp/a.txt, then encrypts and stores the result (the encrypted bytes) in /tmp/b.txt. The following example demonstrates how to easily connect several instances of CipherOutputStream and FileOutputStream. In this example, assume that cipher1 and cipher2 have been initialized for decryption and encryption (with corresponding keys), respectively: 123456789101112131415FileInputStream fis;FileOutputStream fos;CipherOutputStream cos1, cos2;fis = new FileInputStream(&quot;/tmp/a.txt&quot;);fos = new FileOutputStream(&quot;/tmp/b.txt&quot;);cos1 = new CipherOutputStream(fos, cipher1);cos2 = new CipherOutputStream(cos1, cipher2);byte[] b = new byte[8];int i = fis.read(b);while (i != -1) { cos2.write(b, 0, i); i = fis.read(b);}cos2.flush(); The above program copies the content from file /tmp/a.txt to /tmp/b.txt, except that the content is first encrypted and then decrypted back before it is written to /tmp/b.txt. One thing to keep in mind when using block cipher algorithms is that a full block of plaintext data must be given to the CipherOutputStream before the data will be encrypted and sent to the underlying output stream. There is one other important difference between the flush and close methods of this class, which becomes even more relevant if the encapsulated Cipher object implements a block cipher algorithm with padding turned on: flush flushes the underlying OutputStream by forcing any buffered output bytes that have already been processed by the encapsulated Cipher object to be written out. Any bytes buffered by the encapsulated Cipher object and waiting to be processed by it will not be written out. close closes the underlying OutputStream and releases any system resources associated with it. It invokes the doFinal method of the encapsulated Cipher object, causing any bytes buffered by it to be processed and written out to the underlying stream by calling its flush method. The SealedObject Class This class enables a programmer to create an object and protect its confidentiality with a cryptographic algorithm. Given any object that implements the java.io.Serializable interface, one can create a SealedObject that encapsulates the original object, in serialized format (i.e., a &quot;deep copy&quot;), and seals (encrypts) its serialized contents, using a cryptographic algorithm such as DES, to protect its confidentiality. The encrypted content can later be decrypted (with the corresponding algorithm using the correct decryption key) and de-serialized, yielding the original object. A typical usage is illustrated in the following code segment: In order to seal an object, you create a SealedObject from the object to be sealed and a fully initialized Cipher object that will encrypt the serialized object contents. In this example, the String &quot;This is a secret&quot; is sealed using the DES algorithm. Note that any algorithm parameters that may be used in the sealing operation are stored inside of SealedObject: 12345678// create Cipher object// NOTE: sKey is assumed to refer to an already-generated// secret DES key.Cipher c = Cipher.getInstance(&quot;DES&quot;);c.init(Cipher.ENCRYPT_MODE, sKey);// do the sealingSealedObject so = new SealedObject(&quot;This is a secret&quot;, c); The original object that was sealed can be recovered in two different ways: by using a Cipher object that has been initialized with the exact same algorithm, key, padding scheme, etc., that were used to seal the object: c.init(Cipher.DECRYPT_MODE, sKey); try { String s = (String)so.getObject(c); } catch (Exception e) { // do something }; This approach has the advantage that the party who unseals the sealed object does not require knowledge of the decryption key. For example, after one party has initialized the cipher object with the required decryption key, it could hand over the cipher object to another party who then unseals the sealed object. by using the appropriate decryption key (since DES is a symmetric encryption algorithm, we use the same key for sealing and unsealing): try { String s = (String)so.getObject(sKey); } catch (Exception e) { // do something }; In this approach, the getObject method creates a cipher object for the appropriate decryption algorithm and initializes it with the given decryption key and the algorithm parameters (if any) that were stored in the sealed object. This approach has the advantage that the party who unseals the object does not need to keep track of the parameters (e.g., the IV) that were used to seal the object. The Mac Class Similar to a MessageDigest, a Message Authentication Code (MAC) provides a way to check the integrity of information transmitted over or stored in an unreliable medium, but includes a secret key in the calculation. Only someone with the proper key will be able to verify the received message. Typically, message authentication codes are used between two parties that share a secret key in order to validate information transmitted between these parties. The Mac Class Description of Figure 8: The Mac Class A MAC mechanism that is based on cryptographic hash functions is referred to as HMAC. HMAC can be used with any cryptographic hash function, e.g., MD5 or SHA-1, in combination with a secret shared key. The Mac class provides the functionality of a Message Authentication Code (MAC). Please refer to the code example. Creating a Mac Object Mac objects are obtained by using one of the Mac getInstance() static factory methods. Initializing a Mac Object A Mac object is always initialized with a (secret) key and may optionally be initialized with a set of parameters, depending on the underlying MAC algorithm. To initialize a Mac object, call one of its init methods: public void init(Key key); public void init(Key key, AlgorithmParameterSpec params); You can initialize your Mac object with any (secret-)key object that implements the javax.crypto.SecretKey interface. This could be an object returned by javax.crypto.KeyGenerator.generateKey(), or one that is the result of a key agreement protocol, as returned by javax.crypto.KeyAgreement.generateSecret(), or an instance of javax.crypto.spec.SecretKeySpec. With some MAC algorithms, the (secret-)key algorithm associated with the (secret-)key object used to initialize the Mac object does not matter (this is the case with the HMAC-MD5 and HMAC-SHA1 implementations of the SunJCE provider). With others, however, the (secret-)key algorithm does matter, and an InvalidKeyException is thrown if a (secret-)key object with an inappropriate (secret-)key algorithm is used. Computing a MAC A MAC can be computed in one step (single-part operation) or in multiple steps (multiple-part operation). A multiple-part operation is useful if you do not know in advance how long the data is going to be, or if the data is too long to be stored in memory all at once. To compute the MAC of some data in a single step, call the following doFinal method: public byte[] doFinal(byte[] input); To compute the MAC of some data in multiple steps, call one of the update methods: public void update(byte input); public void update(byte[] input); public void update(byte[] input, int inputOffset, int inputLen); A multiple-part operation must be terminated by the above doFinal method (if there is still some input data left for the last step), or by one of the following doFinal methods (if there is no input data left for the last step): public byte[] doFinal(); public void doFinal(byte[] output, int outOffset); Key Interfaces To this point, we have focused the high-level uses of the JCA without getting lost in the details of what keys are and how they are generated/represented. It is now time to turn our attention to keys. The java.security.Key interface is the top-level interface for all opaque keys. It defines the functionality shared by all opaque key objects. An opaque key representation is one in which you have no direct access to the key material that constitutes a key. In other words: &quot;opaque&quot; gives you limited access to the key--just the three methods defined by the Key interface (see below): getAlgorithm, getFormat, and getEncoded. This is in contrast to a transparent representation, in which you can access each key material value individually, through one of the get methods defined in the corresponding specification class. All opaque keys have three characteristics: An Algorithm The key algorithm for that key. The key algorithm is usually an encryption or asymmetric operation algorithm (such as AES, DSA or RSA), which will work with those algorithms and with related algorithms (such as MD5withRSA, SHA1withRSA, etc.) The name of the algorithm of a key is obtained using this method: String getAlgorithm() An Encoded Form The external encoded form for the key used when a standard representation of the key is needed outside the Java Virtual Machine, as when transmitting the key to some other party. The key is encoded according to a standard format (such as X.509 or PKCS8), and is returned using the method: byte[] getEncoded() A Format The name of the format of the encoded key. It is returned by the method: String getFormat() Keys are generally obtained through key generators such as KeyGenerator and KeyPairGenerator, certificates, key specifications (using a KeyFactory), or a KeyStore implementation accessing a keystore database used to manage keys. It is possible to parse encoded keys, in an algorithm-dependent manner, using a KeyFactory. It is also possible to parse certificates, using a CertificateFactory. Here is a list of interfaces which extend the Key interface in the java.security.interfaces and javax.crypto.interfaces packages: SecretKey PBEKey PrivateKey DHPrivateKey DSAPrivateKey ECPrivateKey RSAMultiPrimePrivateCrtKey RSAPrivateCrtKey RSAPrivateKey PublicKey DHPublicKey DSAPublicKey ECPublicKey RSAPublicKey The PublicKey and PrivateKey Interfaces The PublicKey and PrivateKey interfaces (which both extend the Key interface) are methodless interfaces, used for type-safety and type-identification. The KeyPair Class The KeyPair class is a simple holder for a key pair (a public key and a private key). It has two public methods, one for returning the private key, and the other for returning the public key: PrivateKey getPrivate() PublicKey getPublic() Key Specification Interfaces and Classes Key objects and key specifications (KeySpecs) are two different representations of key data. Ciphers use Key objects to initialize their encryption algorithms, but keys may need to be converted into a more portable format for transmission or storage. A transparent representation of keys means that you can access each key material value individually, through one of the get methods defined in the corresponding specification class. For example, DSAPrivateKeySpec defines getX, getP, getQ, and getG methods, to access the private key x, and the DSA algorithm parameters used to calculate the key: the prime p, the sub-prime q, and the base g. If the key is stored on a hardware device, its specification may contain information that helps identify the key on the device. This representation is contrasted with an opaque representation, as defined by the Key interface, in which you have no direct access to the key material fields. In other words, an &quot;opaque&quot; representation gives you limited access to the key--just the three methods defined by the Key interface: getAlgorithm, getFormat, and getEncoded. A key may be specified in an algorithm-specific way, or in an algorithm-independent encoding format (such as ASN.1). For example, a DSA private key may be specified by its components x, p, q, and g (see DSAPrivateKeySpec), or it may be specified using its DER encoding (see PKCS8EncodedKeySpec). The KeyFactory and SecretKeyFactory classes can be used to convert between opaque and transparent key representations (that is, between Keys and KeySpecs, assuming that the operation is possible. (For example, private keys on smart cards might not be able leave the card. Such Keys are not convertible.) In the following sections, we discuss the key specification interfaces and classes in the java.security.spec package. The KeySpec Interface This interface contains no methods or constants. Its only purpose is to group and provide type safety for all key specifications. All key specifications must implement this interface. The KeySpec Subinterfaces Like the Key interface, there are a similar set of KeySpec interfaces. SecretKeySpec EncodedKeySpec PKCS8EncodedKeySpec X509EncodedKeySpec DESKeySpec DESedeKeySpec PBEKeySpec DHPrivateKeySpec DSAPrivateKeySpec ECPrivateKeySpec RSAPrivateKeySpec RSAMultiPrimePrivateCrtKeySpec RSAPrivateCrtKeySpec DHPublicKeySpec DSAPublicKeySpec ECPublicKeySpec RSAPublicKeySpec The EncodedKeySpec Class This abstract class (which implements the KeySpec interface) represents a public or private key in encoded format. Its getEncoded method returns the encoded key: abstract byte[] getEncoded(); and its getFormat method returns the name of the encoding format: abstract String getFormat(); See the next sections for the concrete implementations PKCS8EncodedKeySpec and X509EncodedKeySpec. The PKCS8EncodedKeySpec Class This class, which is a subclass of EncodedKeySpec, represents the DER encoding of a private key, according to the format specified in the PKCS8 standard. Its getEncoded method returns the key bytes, encoded according to the PKCS8 standard. Its getFormat method returns the string &quot;PKCS#8&quot;. The X509EncodedKeySpec Class This class, which is a subclass of EncodedKeySpec, represents the DER encoding of a public key, according to the format specified in the X.509 standard. Its getEncoded method returns the key bytes, encoded according to the X.509 standard. Its getFormat method returns the string &quot;X.509&quot;. Of Generators and Factories Newcomers to Java and the JCA APIs in particular sometimes do not grasp the distinction between generators and factories. Differences Between Generators and Factories Description of Figure Differences Between Generators and Factories Generators are used to generate brand new objects. Generators can be initialized in either an algorithm-dependent or algorithm-independent way. For example, to create a Diffie-Hellman (DH) keypair, an application could specify the necessary P and G values, or the generator could simply be initialized with the appropriate key length, and the generator will select appropriate P and G values. In both cases, the generator will produce brand new keys based on the parameters. On the other hand, factories are used to convert data from one existing object type to another. For example, an application might have available the components of a DH private key and can package them as a KeySpec, but needs to convert them into a PrivateKey object that can be used by a KeyAgreement object, or vice-versa. Or they might have the byte array of a certificate, but need to use a CertificateFactory to convert it into a X509Certificate object. Applications use factory objects to do the conversion. The KeyFactory Class The KeyFactory class is an engine class designed to perform conversions between opaque cryptographic Keys and key specifications (transparent representations of the underlying key material). The KeyFactory Class&lt; Description of Figure The KeyFactory Class Key factories are bi-directional. They allow you to build an opaque key object from a given key specification (key material), or to retrieve the underlying key material of a key object in a suitable format. Multiple compatible key specifications can exist for the same key. For example, a DSA public key may be specified by its components y, p, q, and g (see java.security.spec.DSAPublicKeySpec), or it may be specified using its DER encoding according to the X.509 standard (see X509EncodedKeySpec). A key factory can be used to translate between compatible key specifications. Key parsing can be achieved through translation between compatible key specifications, e.g., when you translate from X509EncodedKeySpec to DSAPublicKeySpec, you basically parse the encoded key into its components. For an example, see the end of the Generating/Verifying Signatures Using Key Specifications and KeyFactory section. Creating a KeyFactory Object KeyFactory objects are obtained by using one of the KeyFactory getInstance() static factory methods. Converting Between a Key Specification and a Key Object If you have a key specification for a public key, you can obtain an opaque PublicKey object from the specification by using the generatePublic method: PublicKey generatePublic(KeySpec keySpec) Similarly, if you have a key specification for a private key, you can obtain an opaque PrivateKey object from the specification by using the generatePrivate method: PrivateKey generatePrivate(KeySpec keySpec) Converting Between a Key Object and a Key Specification If you have a Key object, you can get a corresponding key specification object by calling the getKeySpec method: KeySpec getKeySpec(Key key, Class keySpec) keySpec identifies the specification class in which the key material should be returned. It could, for example, be DSAPublicKeySpec.class, to indicate that the key material should be returned in an instance of the DSAPublicKeySpec class. Please see the Examples section for more details. The SecretKeyFactory Class This class represents a factory for secret keys. Unlike KeyFactory, a javax.crypto.SecretKeyFactory object operates only on secret (symmetric) keys, whereas a java.security.KeyFactory object processes the public and private key components of a key pair. The SecretKeyFactory Class Description of The SecretKeyFactory Class Key factories are used to convert Keys (opaque cryptographic keys of type java.security.Key) into key specifications (transparent representations of the underlying key material in a suitable format), and vice versa. Objects of type java.security.Key, of which java.security.PublicKey, java.security.PrivateKey, and javax.crypto.SecretKey are subclasses, are opaque key objects, because you cannot tell how they are implemented. The underlying implementation is provider-dependent, and may be software or hardware based. Key factories allow providers to supply their own implementations of cryptographic keys. For example, if you have a key specification for a Diffie Hellman public key, consisting of the public value y, the prime modulus p, and the base g, and you feed the same specification to Diffie-Hellman key factories from different providers, the resulting PublicKey objects will most likely have different underlying implementations. A provider should document the key specifications supported by its secret key factory. For example, the SecretKeyFactory for DES keys supplied by the SunJCE provider supports DESKeySpec as a transparent representation of DES keys, the SecretKeyFactory for DES-EDE keys supports DESedeKeySpec as a transparent representation of DES-EDE keys, and the SecretKeyFactory for PBE supports PBEKeySpec as a transparent representation of the underlying password. The following is an example of how to use a SecretKeyFactory to convert secret key data into a SecretKey object, which can be used for a subsequent Cipher operation: // Note the following bytes are not realistic secret key data // bytes but are simply supplied as an illustration of using data // bytes (key material) you already have to build a DESKeySpec. byte[] desKeyData = { (byte)0x01, (byte)0x02, (byte)0x03, (byte)0x04, (byte)0x05, (byte)0x06, (byte)0x07, (byte)0x08 }; DESKeySpec desKeySpec = new DESKeySpec(desKeyData); SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;); SecretKey secretKey = keyFactory.generateSecret(desKeySpec); In this case, the underlying implementation of SecretKey is based on the provider of KeyFactory. An alternative, provider-independent way of creating a functionally equivalent SecretKey object from the same key material is to use the javax.crypto.spec.SecretKeySpec class, which implements the javax.crypto.SecretKey interface: byte[] desKeyData = { (byte)0x01, (byte)0x02, ...}; SecretKeySpec secretKey = new SecretKeySpec(desKeyData, &quot;DES&quot;); Creating a SecretKeyFactory Object SecretKeyFactory objects are obtained by using one of the SecretKeyFactory getInstance() static factory methods. Converting Between a Key Specification and a Secret Key Object If you have a key specification for a secret key, you can obtain an opaque SecretKey object from the specification by using the generateSecret method: SecretKey generateSecret(KeySpec keySpec) Converting Between a Secret Key Object and a Key Specification If you have a Secret Key object, you can get a corresponding key specification object by calling the getKeySpec method: KeySpec getKeySpec(Key key, Class keySpec) keySpec identifies the specification class in which the key material should be returned. It could, for example, be DESKeySpec.class, to indicate that the key material should be returned in an instance of the DESKeySpec class. The KeyPairGenerator Class The KeyPairGenerator class is an engine class used to generate pairs of public and private keys. The KeyPairGenerator Class Description of The KeyPairGenerator Class There are two ways to generate a key pair: in an algorithm-independent manner, and in an algorithm-specific manner. The only difference between the two is the initialization of the object. Please see the Examples section for examples of calls to the methods documented below. Creating a KeyPairGenerator All key pair generation starts with a KeyPairGenerator. KeyPairGenerator objects are obtained by using one of the KeyPairGenerator getInstance() static factory methods. Initializing a KeyPairGenerator A key pair generator for a particular algorithm creates a public/private key pair that can be used with this algorithm. It also associates algorithm-specific parameters with each of the generated keys. A key pair generator needs to be initialized before it can generate keys. In most cases, algorithm-independent initialization is sufficient. But in other cases, algorithm-specific initialization can be used. Algorithm-Independent Initialization All key pair generators share the concepts of a keysize and a source of randomness. The keysize is interpreted differently for different algorithms. For example, in the case of the DSA algorithm, the keysize corresponds to the length of the modulus. (See the Standard Names document for information about the keysizes for specific algorithms.) An initialize method takes two universally shared types of arguments: void initialize(int keysize, SecureRandom random) Another initialize method takes only a keysize argument; it uses a system-provided source of randomness: void initialize(int keysize) Since no other parameters are specified when you call the above algorithm-independent initialize methods, it is up to the provider what to do about the algorithm-specific parameters (if any) to be associated with each of the keys. If the algorithm is a &quot;DSA&quot; algorithm, and the modulus size (keysize) is 512, 768, or 1024, then the SUN provider uses a set of precomputed values for the p, q, and g parameters. If the modulus size is not one of the above values, the SUN provider creates a new set of parameters. Other providers might have precomputed parameter sets for more than just the three modulus sizes mentioned above. Still others might not have a list of precomputed parameters at all and instead always create new parameter sets. Algorithm-Specific Initialization For situations where a set of algorithm-specific parameters already exists (such as &quot;community parameters&quot; in DSA), there are two initialize methods that have an AlgorithmParameterSpec argument. One also has a SecureRandom argument, while the source of randomness is system-provided for the other: void initialize(AlgorithmParameterSpec params, SecureRandom random) void initialize(AlgorithmParameterSpec params) See the Examples section for more details. Generating a Key Pair The procedure for generating a key pair is always the same, regardless of initialization (and of the algorithm). You always call the following method from KeyPairGenerator: KeyPair generateKeyPair() Multiple calls to generateKeyPair will yield different key pairs. The KeyGenerator Class A key generator is used to generate secret keys for symmetric algorithms. The KeyGenerator Class Description of Figure The KeyGenerator Class Creating a KeyGenerator KeyGenerator objects are obtained by using one of the KeyGenerator getInstance() static factory methods. Initializing a KeyGenerator Object A key generator for a particular symmetric-key algorithm creates a symmetric key that can be used with that algorithm. It also associates algorithm-specific parameters (if any) with the generated key. There are two ways to generate a key: in an algorithm-independent manner, and in an algorithm-specific manner. The only difference between the two is the initialization of the object: Algorithm-Independent Initialization All key generators share the concepts of a keysize and a source of randomness. There is an init method that takes these two universally shared types of arguments. There is also one that takes just a keysize argument, and uses a system-provided source of randomness, and one that takes just a source of randomness: public void init(SecureRandom random); public void init(int keysize); public void init(int keysize, SecureRandom random); Since no other parameters are specified when you call the above algorithm-independent init methods, it is up to the provider what to do about the algorithm-specific parameters (if any) to be associated with the generated key. Algorithm-Specific Initialization For situations where a set of algorithm-specific parameters already exists, there are two init methods that have an AlgorithmParameterSpec argument. One also has a SecureRandom argument, while the source of randomness is system-provided for the other: public void init(AlgorithmParameterSpec params); public void init(AlgorithmParameterSpec params, SecureRandom random); In case the client does not explicitly initialize the KeyGenerator (via a call to an init method), each provider must supply (and document) a default initialization. Creating a Key The following method generates a secret key: public SecretKey generateKey(); The KeyAgreement Class Key agreement is a protocol by which 2 or more parties can establish the same cryptographic keys, without having to exchange any secret information. The KeyAgreement Class Description of Figure The KeyAgreement Class Each party initializes their key agreement object with their private key, and then enters the public keys for each party that will participate in the communication. In most cases, there are just two parties, but algorithms such as Diffie-Hellman allow for multiple parties (3 or more) to participate. When all the public keys have been entered, each KeyAgreement object will generate (agree upon) the same key. The KeyAgreement class provides the functionality of a key agreement protocol. The keys involved in establishing a shared secret are created by one of the key generators (KeyPairGenerator or KeyGenerator), a KeyFactory, or as a result from an intermediate phase of the key agreement protocol. Creating a KeyAgreement Object Each party involved in the key agreement has to create a KeyAgreement object. KeyAgreement objects are obtained by using one of the KeyAgreement getInstance() static factory methods. Initializing a KeyAgreement Object You initialize a KeyAgreement object with your private information. In the case of Diffie-Hellman, you initialize it with your Diffie-Hellman private key. Additional initialization information may contain a source of randomness and/or a set of algorithm parameters. Note that if the requested key agreement algorithm requires the specification of algorithm parameters, and only a key, but no parameters are provided to initialize the KeyAgreement object, the key must contain the required algorithm parameters. (For example, the Diffie-Hellman algorithm uses a prime modulus p and a base generator g as its parameters.) To initialize a KeyAgreement object, call one of its init methods: public void init(Key key); public void init(Key key, SecureRandom random); public void init(Key key, AlgorithmParameterSpec params); public void init(Key key, AlgorithmParameterSpec params, SecureRandom random); Executing a KeyAgreement Phase Every key agreement protocol consists of a number of phases that need to be executed by each party involved in the key agreement. To execute the next phase in the key agreement, call the doPhase method: public Key doPhase(Key key, boolean lastPhase); The key parameter contains the key to be processed by that phase. In most cases, this is the public key of one of the other parties involved in the key agreement, or an intermediate key that was generated by a previous phase. doPhase may return an intermediate key that you may have to send to the other parties of this key agreement, so they can process it in a subsequent phase. The lastPhase parameter specifies whether or not the phase to be executed is the last one in the key agreement: A value of FALSE indicates that this is not the last phase of the key agreement (there are more phases to follow), and a value of TRUE indicates that this is the last phase of the key agreement and the key agreement is completed, i.e., generateSecret can be called next. In the example of Diffie-Hellman between two parties , you call doPhase once, with lastPhase set to TRUE. In the example of Diffie-Hellman between three parties, you call doPhase twice: the first time with lastPhase set to FALSE, the 2nd time with lastPhase set to TRUE. Generating the Shared Secret After each party has executed all the required key agreement phases, it can compute the shared secret by calling one of the generateSecret methods: public byte[] generateSecret(); public int generateSecret(byte[] sharedSecret, int offset); public SecretKey generateSecret(String algorithm); Key Management A database called a &quot;keystore&quot; can be used to manage a repository of keys and certificates. (A certificate is a digitally signed statement from one entity, saying that the public key of some other entity has a particular value.) Keystore Location The user keystore is by default stored in a file named .keystore in the user&apos;s home directory, as determined by the &quot;user.home&quot; system property. On Solaris systems &quot;user.home&quot; defaults to the user&apos;s home directory. On Win32 systems, given user name uName, &quot;user.home&quot; defaults to: C:\\Winnt\\Profiles\\uName on multi-user Windows NT systems C:\\Windows\\Profiles\\uName on multi-user Windows 95/98/2000 systems C:\\Windows on single-user Windows 95/98/2000 systems Of course, keystore files can be located as desired. In some environments, it may make sense for multiple keystores to exist. For example, in JSSE (SSL/TLS), one keystore might hold a user&apos;s private keys, and another might hold certificates used to establish trust relationships. In addition to the user&apos;s keystore, the JDK also maintains a system-wide keystore which is used to store trusted certificates from a variety of Certificate Authorities (CA&apos;s). These CA certificates can be used to help make trust decisions. For example, in SSL/TLS when the SunJSSE provider is presented with certificates from a remote peer, the default trustmanager will consult the: Solaris, Linux, or Mac OS X: &lt;java-home&gt;/lib/ext/cacerts Windows: &lt;java-home&gt;\\lib\\ext\\cacerts file to determine if the connection is to be trusted. Instead of using the system-wide cacerts keystore, applications can set up and use their own keystores, or even use the user keystore described above. Keystore Implementation The KeyStore class supplies well-defined interfaces to access and modify the information in a keystore. It is possible for there to be multiple different concrete implementations, where each implementation is that for a particular type of keystore. Currently, there are two command-line tools that make use of KeyStore: keytool and jarsigner, and also a GUI-based tool named policytool. It is also used by the Policy reference implementation when it processes policy files specifying the permissions (allowed accesses to system resources) to be granted to code from various sources. Since KeyStore is publicly available, JDK users can write additional security applications that use it. Applications can choose different types of keystore implementations from different providers, using the getInstance factory method in the KeyStore class. A keystore type defines the storage and data format of the keystore information, and the algorithms used to protect private keys in the keystore and the integrity of the keystore itself. Keystore implementations of different types are not compatible. There is a built-in default keystore implementation type known as &quot;jks&quot; that is provided by Sun Microsystems. It implements the keystore as a file, utilizing a proprietary keystore type (format). It protects each private key with its own individual password, and also protects the integrity of the entire keystore with a (possibly different) password. The default is specified by the following line in the security properties file: keystore.type=jks To have tools and other applications use a different default keystore implementation, you can change that line to specify a default type. If you have a provider package that supplies a keystore implementation for a keystore type called &quot;jceks&quot;, change the line to: keystore.type=jceks Some applications, such as keytool, also let you override the default keystore type (via the -storetype command-line parameter). NOTE: Keystore type designations are case-insensitive. For example, &quot;jks&quot; would be considered the same as &quot;JKS&quot;. There are three other types of keystores that come with the JDK implementation. &quot;jceks&quot; is an alternate proprietary keystore format to &quot;jks&quot; that uses much stronger encryption in the form of Password-Based Encryption with Triple-DES. The Sun &quot;jceks&quot; implementation can parse and convert a &quot;jks&quot; keystore file to the &quot;jceks&quot; format. You may upgrade your keystore of type &quot;jks&quot; to a keystore of type &quot;jceks&quot; by changing the password of a private-key entry in your keystore and specifying &quot;-storetype jceks&quot; as the keystore type. To apply the cryptographically strong(er) key protection supplied to a private key named &quot;signkey&quot; in your default keystore, use the following command, which will prompt you for the old and new key passwords: keytool -keypasswd -alias signkey -storetype jceks See Security Tools for more information about keytool and about keystores and how they are managed. NOTE: Keystore type designations are case-insensitive. For example, &quot;jceks&quot; would be considered the same as &quot;JCEKS&quot;. &quot;pkcs12&quot; is another option. This is a cross platform keystore based on the RSA PKCS12 Personal Information Exchange Syntax Standard. This standard is primarily meant for storing or transporting a user&apos;s private keys, certificates, and miscellaneous secrets. As of JDK 8, arbitrary attributes can be associated with individual entries in a PKCS12 keystore. &quot;dks&quot; is a domain keystore. It is a collection of keystores presented as a single logical keystore. The keystores that comprise a given domain are specified by configuration data whose syntax is described in DomainLoadStoreParameter. Keystore implementations are provider-based. Developers interested in writing their own KeyStore implementations should consult How to Implement a Provider for the Java Cryptography Architecture for more information on this topic. The KeyStore Class The KeyStore class is an engine class that supplies well-defined interfaces to access and modify the information in a keystore. The KeyStore Class Description of Figure The KeyStore Class This class represents an in-memory collection of keys and certificates. KeyStore manages two types of entries: Key Entry This type of keystore entry holds very sensitive cryptographic key information, which is stored in a protected format to prevent unauthorized access. Typically, a key stored in this type of entry is a secret key, or a private key accompanied by the certificate chain authenticating the corresponding public key. Private keys and certificate chains are used by a given entity for self-authentication using digital signatures. For example, software distribution organizations digitally sign JAR files as part of releasing and/or licensing software. Trusted Certificate Entry This type of entry contains a single public key certificate belonging to another party. It is called a trusted certificate because the keystore owner trusts that the public key in the certificate indeed belongs to the identity identified by the subject (owner) of the certificate. This type of entry can be used to authenticate other parties. Each entry in a keystore is identified by an &quot;alias&quot; string. In the case of private keys and their associated certificate chains, these strings distinguish among the different ways in which the entity may authenticate itself. For example, the entity may authenticate itself using different certificate authorities, or using different public key algorithms. Whether keystores are persistent, and the mechanisms used by the keystore if it is persistent, are not specified here. This convention allows use of a variety of techniques for protecting sensitive (e.g., private or secret) keys. Smart cards or other integrated cryptographic engines (SafeKeyper) are one option, and simpler mechanisms such as files may also be used (in a variety of formats). The main KeyStore methods are described below. Creating a KeyStore Object KeyStore objects are obtained by using one of the KeyStore getInstance() static factory methods. Loading a Particular Keystore into Memory Before a KeyStore object can be used, the actual keystore data must be loaded into memory via the load method: final void load(InputStream stream, char[] password) The optional password is used to check the integrity of the keystore data. If no password is supplied, no integrity check is performed. To create an empty keystore, you pass null as the InputStream argument to the load method. A DKS keystore is loaded by passing a DomainLoadStoreParameter to the alternative load method: final void load(KeyStore.LoadStoreParameter param) Getting a List of the Keystore Aliases All keystore entries are accessed via unique aliases. The aliases method returns an enumeration of the alias names in the keystore: final Enumeration aliases() Determining Keystore Entry Types As stated in The KeyStore Class, there are two different types of entries in a keystore. The following methods determine whether the entry specified by the given alias is a key/certificate or a trusted certificate entry, respectively: final boolean isKeyEntry(String alias) final boolean isCertificateEntry(String alias) Adding/Setting/Deleting Keystore Entries The setCertificateEntry method assigns a certificate to a specified alias: final void setCertificateEntry(String alias, Certificate cert) If alias doesn&apos;t exist, a trusted certificate entry with that alias is created. If alias exists and identifies a trusted certificate entry, the certificate associated with it is replaced by cert. The setKeyEntry methods add (if alias doesn&apos;t yet exist) or set key entries: final void setKeyEntry(String alias, Key key, char[] password, Certificate[] chain) final void setKeyEntry(String alias, byte[] key, Certificate[] chain) In the method with key as a byte array, it is the bytes for a key in protected format. For example, in the keystore implementation supplied by the SUN provider, the key byte array is expected to contain a protected private key, encoded as an EncryptedPrivateKeyInfo as defined in the PKCS8 standard. In the other method, the password is the password used to protect the key. The deleteEntry method deletes an entry: final void deleteEntry(String alias) PKCS #12 keystores support entries containing arbitrary attributes. Use the java.security.PKCS12Attribute class to create the attributes. When creating the new keystore entry use a constructor method that accepts attributes. Finally, use the following method to add the entry to the keystore: final void setEntry(String alias, Entry entry, ProtectionParameter protParam) Getting Information from the Keystore The getKey method returns the key associated with the given alias. The key is recovered using the given password: final Key getKey(String alias, char[] password) The following methods return the certificate, or certificate chain, respectively, associated with the given alias: final Certificate getCertificate(String alias) final Certificate[] getCertificateChain(String alias) You can determine the name (alias) of the first entry whose certificate matches a given certificate via the following: final String getCertificateAlias(Certificate cert) PKCS #12 keystores support entries containing arbitrary attributes. Use the following method to retrieve an entry that may contain attributes: final Entry getEntry(String alias, ProtectionParameter protParam) and then use the KeyStore.Entry.getAttributes method to extract such attributes and use the methods of the KeyStore.Entry.Attribute interface to examine them. Saving the KeyStore The in-memory keystore can be saved via the store method: final void store(OutputStream stream, char[] password) The password is used to calculate an integrity checksum of the keystore data, which is appended to the keystore data. A DKS keystore is stored by passing a DomainLoadStoreParameter to the alternative store method: final void store(KeyStore.LoadStoreParameter param) Algorithm Parameters Classes Like Keys and Keyspecs, an algorithm&apos;s initialization parameters are represented by either AlgorithmParameters or AlgorithmParameterSpecs. Depending on the use situation, algorithms can use the parameters directly, or the parameters might need to be converted into a more portable format for transmission or storage. A transparent representation of a set of parameters (via AlgorithmParameterSpec) means that you can access each parameter value in the set individually. You can access these values through one of the get methods defined in the corresponding specification class (e.g., DSAParameterSpec defines getP, getQ, and getG methods, to access p, q, and g, respectively). In contrast, the AlgorithmParameters class supplies an opaque representation, in which you have no direct access to the parameter fields. You can only get the name of the algorithm associated with the parameter set (via getAlgorithm) and some kind of encoding for the parameter set (via getEncoded). The AlgorithmParameterSpec Interface AlgorithmParameterSpec is an interface to a transparent specification of cryptographic parameters. This interface contains no methods or constants. Its only purpose is to group (and provide type safety for) all parameter specifications. All parameter specifications must implement this interface. The algorithm parameter specification interfaces and classes in the java.security.spec and javax.crypto.spec packages are described in the JDK javadocs: DHParameterSpec DHGenParameterSpec DSAParameterSpec ECGenParameterSpec ECParameterSpec GCMParameterSpec IvParameterSpec MGF1ParameterSpec OAEPParameterSpec PBEParameterSpec PSSParameterSpec RC2ParameterSpec RC5ParameterSpec RSAKeyGenParameterSpec The following algorithm parameter specs are used specifically for digital signatures, as part of JSR 105. C14NMethodParameterSpec DigestMethodParameterSpec SignatureMethodParameterSpec TransformParameterSpec ExcC14NParameterSpec HMACParameterSpec XPathFilter2ParameterSpec XPathFilterParameterSpec XSLTTransformParameterSpec The AlgorithmParameters Class The AlgorithmParameters class is an engine class that provides an opaque representation of cryptographic parameters. You can initialize the AlgorithmParameters class using a specific AlgorithmParameterSpec object, or by encoding the parameters in a recognized format. You can retrieve the resulting specification with the getParameterSpec method (see the following section). Creating an AlgorithmParameters Object AlgorithmParameters objects are obtained by using one of the AlgorithmParameters getInstance() static factory methods. Initializing an AlgorithmParameters Object Once an AlgorithmParameters object is instantiated, it must be initialized via a call to init, using an appropriate parameter specification or parameter encoding: void init(AlgorithmParameterSpec paramSpec) void init(byte[] params) void init(byte[] params, String format) In these init methods, params is an array containing the encoded parameters, and format is the name of the decoding format. In the init method with a params argument but no format argument, the primary decoding format for parameters is used. The primary decoding format is ASN.1, if an ASN.1 specification for the parameters exists. NOTE: AlgorithmParameters objects can be initialized only once. They are not reusable. Obtaining the Encoded Parameters A byte encoding of the parameters represented in an AlgorithmParameters object may be obtained via a call to getEncoded: byte[] getEncoded() This method returns the parameters in their primary encoding format. The primary encoding format for parameters is ASN.1, if an ASN.1 specification for this type of parameters exists. If you want the parameters returned in a specified encoding format, use byte[] getEncoded(String format) If format is null, the primary encoding format for parameters is used, as in the other getEncoded method. NOTE: In the default AlgorithmParameters implementation, supplied by the SUN provider, the format argument is currently ignored. Converting an AlgorithmParameters Object to a Transparent Specification A transparent parameter specification for the algorithm parameters may be obtained from an AlgorithmParameters object via a call to getParameterSpec: AlgorithmParameterSpec getParameterSpec(Class paramSpec) paramSpec identifies the specification class in which the parameters should be returned. The specification class could be, for example, DSAParameterSpec.class to indicate that the parameters should be returned in an instance of the DSAParameterSpec class. (This class is in the java.security.spec package.) The AlgorithmParameterGenerator Class The AlgorithmParameterGenerator class is an engine class used to generate a set of brand-new parameters suitable for a certain algorithm (the algorithm is specified when an AlgorithmParameterGenerator instance is created). This object is used when you do not have an existing set of algorithm parameters, and want to generate one from scratch. Creating an AlgorithmParameterGenerator Object AlgorithmParameterGenerator objects are obtained by using one of the AlgorithmParameterGenerator getInstance() static factory methods. Initializing an AlgorithmParameterGenerator Object The AlgorithmParameterGenerator object can be initialized in two different ways: an algorithm-independent manner or an algorithm-specific manner. The algorithm-independent approach uses the fact that all parameter generators share the concept of a &quot;size&quot; and a source of randomness. The measure of size is universally shared by all algorithm parameters, though it is interpreted differently for different algorithms. For example, in the case of parameters for the DSA algorithm, &quot;size&quot; corresponds to the size of the prime modulus, in bits. (See the Standard Names document for information about the sizes for specific algorithms.) When using this approach, algorithm-specific parameter generation values--if any--default to some standard values. One init method that takes these two universally shared types of arguments: void init(int size, SecureRandom random); Another init method takes only a size argument and uses a system-provided source of randomness: void init(int size) A third approach initializes a parameter generator object using algorithm-specific semantics, which are represented by a set of algorithm-specific parameter generation values supplied in an AlgorithmParameterSpec object: void init(AlgorithmParameterSpec genParamSpec, SecureRandom random) void init(AlgorithmParameterSpec genParamSpec) To generate Diffie-Hellman system parameters, for example, the parameter generation values usually consist of the size of the prime modulus and the size of the random exponent, both specified in number of bits. Generating Algorithm Parameters Once you have created and initialized an AlgorithmParameterGenerator object, you can use the generateParameters method to generate the algorithm parameters: AlgorithmParameters generateParameters() The CertificateFactory Class The CertificateFactory class is an engine class that defines the functionality of a certificate factory, which is used to generate certificate and certificate revocation list (CRL) objects from their encodings. A certificate factory for X.509 must return certificates that are an instance of java.security.cert.X509Certificate, and CRLs that are an instance of java.security.cert.X509CRL. Creating a CertificateFactory Object CertificateFactory objects are obtained by using one of the getInstance() static factory methods. Generating Certificate Objects To generate a certificate object and initialize it with the data read from an input stream, use the generateCertificate method: final Certificate generateCertificate(InputStream inStream) To return a (possibly empty) collection view of the certificates read from a given input stream, use the generateCertificates method: final Collection generateCertificates(InputStream inStream) Generating CRL Objects To generate a certificate revocation list (CRL) object and initialize it with the data read from an input stream, use the generateCRL method: final CRL generateCRL(InputStream inStream) To return a (possibly empty) collection view of the CRLs read from a given input stream, use the generateCRLs method: final Collection generateCRLs(InputStream inStream) Generating CertPath Objects The certificate path builder and validator for PKIX is defined by the Internet X.509 Public Key Infrastructure Certificate and CRL Profile, RFC 3280. A certificate store implementation for retrieving certificates and CRLs from Collection and LDAP directories, using the PKIX LDAP V2 Schema is also available from the IETF as RFC 2587. To generate a CertPath object and initialize it with data read from an input stream, use one of the following generateCertPath methods (with or without specifying the encoding to be used for the data): final CertPath generateCertPath(InputStream inStream) final CertPath generateCertPath(InputStream inStream, String encoding) To generate a CertPath object and initialize it with a list of certificates, use the following method: final CertPath generateCertPath(List certificates) To retrieve a list of the CertPath encodings supported by this certificate factory, you can call the getCertPathEncodings method: final Iterator getCertPathEncodings() The default encoding will be listed first. How the JCA Might Be Used in a SSL/TLS Implementation With an understanding of the JCA classes, consider how these classes might be combined to implement an advanced network protocol like SSL/TLS. The SSL/TLS Overview section in the JSSE Reference Guide describes at a high level how the protocols work. As asymmetric (public key) cipher operations are much slower than symmetric operations (secret key), public key cryptography is used to establish secret keys which are then used to protect the actual application data. Vastly simplified, the SSL/TLS handshake involves exchanging initialization data, performing some public key operations to arrive at a secret key, and then using that key to encrypt further traffic. NOTE: The details presented here simply show how some of the above classes might be employed. This section will not present sufficient information for building a SSL/TLS implementation. For more details, please see the JSSE Reference Guide and RFC 2246: The TLS Protocol. Assume that this SSL/TLS implementation will be made available as a JSSE provider. A concrete implementation of the Provider class is first written that will eventually be registered in the Security class&apos; list of providers. This provider mainly provides a mapping from algorithm names to actual implementation classes. (that is: &quot;SSLContext.TLS&quot;-&gt;&quot;com.foo.TLSImpl&quot;) When an application requests an &quot;TLS&quot; instance (via SSLContext.getInstance(&quot;TLS&quot;), the provider&apos;s list is consulted for the requested algorithm, and an appropriate instance is created. Before discussing details of the actual handshake, a quick review of some of the JSSE&apos;s architecture is needed. The heart of the JSSE architecture is the SSLContext. The context eventually creates end objects (SSLSocket and SSLEngine) which actually implement the SSL/TLS protocol. SSLContexts are initialized with two callback classes, KeyManager and TrustManager, which allow applications to first select authentication material to send and second to verify credentials sent by a peer. A JSSE KeyManager is responsible for choosing which credentials to present to a peer. Many algorithms are possible, but a common strategy is to maintain a RSA or DSA public/private key pair along with a X509Certificate in a KeyStore backed by a disk file. When a KeyStore object is initialized and loaded from the file, the file&apos;s raw bytes are converted into PublicKey and PrivateKey objects using a KeyFactory, and a certificate chain&apos;s bytes are converted using a CertificateFactory. When a credential is needed, the KeyManager simply consults this KeyStore object and determines which credentials to present. A KeyStore&apos;s contents might have originally been created using a utility such as keytool. keytool creates a RSA or DSA KeyPairGenerator and initializes it with an appropriate keysize. This generator is then used to create a KeyPair which keytool would store along with the newly-created certificate in the KeyStore, which is eventually written to disk. A JSSE TrustManager is responsible for verifying the credentials received from a peer. There are many ways to verify credentials: one of them is to create a CertPath object, and let the JDK&apos;s built-in Public Key Infrastructure (PKI) framework handle the validation. Internally, the CertPath implementation might create a Signature object, and use that to verify that the each of the signatures in the certificate chain. With this basic understanding of the architecture, we can look at some of the steps in the SSL/TLS handshake. The client begins by sending a ClientHello message to the server. The server selects a ciphersuite to use, and sends that back in a ServerHello message, and begins creating JCA objects based on the suite selection. We&apos;ll use server-only authentication in the following examples. SSL Messages Description of Figure SSL Messages In the first example, the server tries to use a RSA-based ciphersuite such as TLS_RSA_WITH_AES_128_CBC_SHA. The server&apos;s KeyManager is queried, and returns an appropriate RSA entry. The server&apos;s credentials (that is: certificate/public key) are sent in the server&apos;s Certificate message. The client&apos;s TrustManager verifies the server&apos;s certificate, and if accepted, the client generates some random bytes using a SecureRandom object. This is then encrypted using an encrypting asymmetric RSA Cipher object that has been initialized with the PublicKey found in the server&apos;s certificate. This encrypted data is sent in a Client Key Exchange message. The server would use its corresponding PrivateKey to recover the bytes using a similar Cipher in decrypt mode. These bytes are then used to establish the actual encryption keys. In a different example, an ephemeral Diffie-Hellman key agreement algorithm along with the DSA signature algorithm is chosen, such as TLS_DHE_DSS_WITH_AES_128_CBC_SHA. The two sides must each establish a new temporary DH public/private keypair using a KeyPairGenerator. Each generator creates DH keys which can then be further converted into pieces using the KeyFactory and DHPublicKeySpec classes. Each side then creates a KeyAgreement object and initializes it with their respective DH PrivateKeys. The server sends its public key pieces in a ServerKeyExchange message (protected by the DSA signature algorithm, and the client sends its public key in a ClientKeyExchange message. When the public keys are reassembled using another KeyFactory, they are fed into the agreement objects. The KeyAgreement objects then generate agreed-upon bytes that are then used to establish the actual encryption keys. Once the actual encryption keys have been established, the secret key is used to initialize a symmetric Cipher object, and this cipher is used to protect all data in transit. To help determine if the data has been modified, a MessageDigest is created and receives a copy of the data destined for the network. When the packet is complete, the digest (hash) is appended to data, and the entire packet is encrypted by the Cipher. If a block cipher such as AES is used, the data must be padded to make a complete block. On the remote side, the steps are simply reversed. Again, this is vastly simplified, but gives one an idea of how these classes might be combined to create a higher level protocol. How to Make Applications &quot;Exempt&quot; from Cryptographic Restrictions Note 1: This section should be ignored by most application developers. It is only for people whose applications may be exported to those few countries whose governments mandate cryptographic restrictions, if it is desired that such applications have fewer cryptographic restrictions than those mandated. Note 2: Throughout this section, the term &quot;application&quot; is meant to encompass both applications and applets.] The JCA framework includes an ability to enforce restrictions regarding the cryptographic algorithms and maximum cryptographic strengths available to applets/applications in different jurisdiction contexts (locations). Any such restrictions are specified in &quot;jurisdiction policy files&quot;. Due to import control restrictions by the governments of a few countries, the jurisdiction policy files shipped with the Java SE Development Kit 6 specify that &quot;strong&quot; but limited cryptography may be used. An &quot;unlimited strength&quot; version of these files indicating no restrictions on cryptographic strengths is available for those living in eligible countries (which is most countries). But only the &quot;strong&quot; version can be imported into those countries whose governments mandate restrictions. The JCA framework will enforce the restrictions specified in the installed jurisdiction policy files. It is possible that the governments of some or all such countries may allow certain applications to become exempt from some or all cryptographic restrictions. For example, they may consider certain types of applications as &quot;special&quot; and thus exempt. Or they may exempt any application that utilizes an &quot;exemption mechanism,&quot; such as key recovery. Applications deemed to be exempt could get access to stronger cryptography than that allowed for non-exempt applications in such countries. In order for an application to be recognized as &quot;exempt&quot; at runtime, it must meet the following conditions: It must have a permission policy file bundled with it in a JAR file. The permission policy file specifies what cryptography-related permissions the application has, and under what conditions (if any). The JAR file containing the application and the permission policy file must have been signed using a code-signing certificate issued after the application was accepted as exempt. Below are sample steps required in order to make an application exempt from some or all cryptographic restrictions. This is a basic outline that includes information about what is required by JCA in order to recognize and treat applications as being exempt. You will need to know the exemption requirements of the particular country or countries in which you would like your application to be able to be run but whose governments require cryptographic restrictions. You will also need to know the requirements of a JCA framework vendor that has a process in place for handling exempt applications. Consult such a vendor for further information. (NOTE: The SunJCE provider does not supply an implementation of the ExemptionMechanismSpi class.) Step 1: Write and Compile Your Application Code Step 2: Create a Permission Policy File Granting Appropriate Cryptographic Permissions Step 3: Prepare for Testing Step 3a: Apply for Government Approval From the Government Mandating Restrictions. Step 3b: Get a Code-Signing Certificate Step 3c: Bundle the Application and Permission Policy File into a JAR file Step 3d: Sign the JAR file Step 3e: Set Up Your Environment Like That of a User in a Restricted Country Step 3f: (only for applications using exemption mechanisms) Install a Provider Implementing the Exemption Mechanism Specified by the entry in the Permission Policy File Step 4: Test Your Application Step 5: Apply for U.S. Government Export Approval If Required Step 6: Deploy Your Application Special Code Requirements for Applications that Use Exemption Mechanisms When an application has a permission policy file associated with it (in the same JAR file) and that permission policy file specifies an exemption mechanism, then when the Cipher getInstance method is called to instantiate a Cipher, the JCA code searches the installed providers for one that implements the specified exemption mechanism. If it finds such a provider, JCA instantiates an ExemptionMechanism API object associated with the provider&apos;s implementation, and then associates the ExemptionMechanism object with the Cipher returned by getInstance. After instantiating a Cipher, and prior to initializing it (via a call to the Cipher init method), your code must call the following Cipher method: public ExemptionMechanism getExemptionMechanism() This call returns the ExemptionMechanism object associated with the Cipher. You must then initialize the exemption mechanism implementation by calling the following method on the returned ExemptionMechanism: public final void init(Key key) The argument you supply should be the same as the argument of the same types that you will subsequently supply to a Cipher init method. Once you have initialized the ExemptionMechanism, you can proceed as usual to initialize and use the Cipher. Permission Policy Files In order for an application to be recognized at runtime as being &quot;exempt&quot; from some or all cryptographic restrictions, it must have a permission policy file bundled with it in a JAR file. The permission policy file specifies what cryptography-related permissions the application has, and under what conditions (if any). NOTE: The permission policy file bundled with an application must be named cryptoPerms. The format of a permission entry in a permission policy file that accompanies an exempt application is the same as the format for a jurisdiction policy file downloaded with the JDK, which is: permission &lt;crypto permission class name&gt;[ &lt;alg_name&gt; [[, &lt;exemption mechanism name&gt;][, &lt;maxKeySize&gt; [, &lt;AlgorithmParameterSpec class name&gt;, &lt;parameters for constructing an AlgorithmParameterSpec object&gt; ]]]]; See Appendix B for more information about the jurisdiction policy file format. Permission Policy Files for Exempt Applications Some applications may be allowed to be completely unrestricted. Thus, the permission policy file that accompanies such an application usually just needs to contain the following: grant { // There are no restrictions to any algorithms. permission javax.crypto.CryptoAllPermission; }; If an application just uses a single algorithm (or several specific algorithms), then the permission policy file could simply mention that algorithm (or algorithms) explicitly, rather than granting CryptoAllPermission. For example, if an application just uses the Blowfish algorithm, the permission policy file doesn&apos;t have to grant CryptoAllPermission to all algorithms. It could just specify that there is no cryptographic restriction if the Blowfish algorithm is used. In order to do this, the permission policy file would look like the following: grant { permission javax.crypto.CryptoPermission &quot;Blowfish&quot;; }; Permission Policy Files for Applications Exempt Due to Exemption Mechanisms If an application is considered &quot;exempt&quot; if an exemption mechanism is enforced, then the permission policy file that accompanies the application must specify one or more exemption mechanisms. At runtime, the application will be considered exempt if any of those exemption mechanisms is enforced. Each exemption mechanism must be specified in a permission entry that looks like the following: // No algorithm restrictions if specified // exemption mechanism is enforced. permission javax.crypto.CryptoPermission *, &quot;&lt;ExemptionMechanismName&gt;&quot;; where &lt;ExemptionMechanismName&gt; specifies the name of an exemption mechanism. The list of possible exemption mechanism names includes: KeyRecovery KeyEscrow KeyWeakening As an example, suppose your application is exempt if either key recovery or key escrow is enforced. Then your permission policy file should contain the following: grant { // No algorithm restrictions if KeyRecovery is enforced. permission javax.crypto.CryptoPermission *, &quot;KeyRecovery&quot;; // No algorithm restrictions if KeyEscrow is enforced. permission javax.crypto.CryptoPermission *, &quot;KeyEscrow&quot;; }; NOTE: Permission entries that specify exemption mechanisms should not also specify maximum key sizes. The allowed key sizes are actually determined from the installed exempt jurisdiction policy files, as described in the next section. How Bundled Permission Policy Files Affect Cryptographic Permissions At runtime, when an application instantiates a Cipher (via a call to its getInstance method) and that application has an associated permission policy file, JCA checks to see whether the permission policy file has an entry that applies to the algorithm specified in the getInstance call. If it does, and the entry grants CryptoAllPermission or does not specify that an exemption mechanism must be enforced, it means there is no cryptographic restriction for this particular algorithm. If the permission policy file has an entry that applies to the algorithm specified in the getInstance call and the entry does specify that an exemption mechanism must be enforced, then the exempt jurisdiction policy file(s) are examined. If the exempt permissions include an entry for the relevant algorithm and exemption mechanism, and that entry is implied by the permissions in the permission policy file bundled with the application, and if there is an implementation of the specified exemption mechanism available from one of the registered providers, then the maximum key size and algorithm parameter values for the Cipher are determined from the exempt permission entry. If there is no exempt permission entry implied by the relevant entry in the permission policy file bundled with the application, or if there is no implementation of the specified exemption mechanism available from any of the registered providers, then the application is only allowed the standard default cryptographic permissions. Code Examples Here are some short examples which illustrate use of several of the JCA mechanisms. In addition, complete working examples can be found in Appendix D. Computing a MessageDigest Object First create the message digest object, as in the following example: MessageDigest sha = MessageDigest.getInstance(&quot;SHA-1&quot;); This call assigns a properly initialized message digest object to the sha variable. The implementation implements the Secure Hash Algorithm (SHA-1), as defined in the National Institute for Standards and Technology&apos;s (NIST) FIPS 180-2 document. See Appendix A for a complete discussion of standard names and algorithms. Next, suppose we have three byte arrays, i1, i2 and i3, which form the total input whose message digest we want to compute. This digest (or &quot;hash&quot;) could be calculated via the following calls: sha.update(i1); sha.update(i2); sha.update(i3); byte[] hash = sha.digest(); An equivalent alternative series of calls would be: sha.update(i1); sha.update(i2); byte[] hash = sha.digest(i3); After the message digest has been calculated, the message digest object is automatically reset and ready to receive new data and calculate its digest. All former state (i.e., the data supplied to update calls) is lost. Some hash implementations may support intermediate hashes through cloning. Suppose we want to calculate separate hashes for: i1 i1 and i2 i1, i2, and i3 A way to do it is: /* compute the hash for i1 */ sha.update(i1); byte[] i1Hash = sha.clone().digest(); /* compute the hash for i1 and i2 */ sha.update(i2); byte[] i12Hash = sha.clone().digest(); /* compute the hash for i1, i2 and i3 / sha.update(i3); byte[] i123hash = sha.digest(); This code works only if the SHA-1 implementation is cloneable. While some implementations of message digests are cloneable, others are not. To determine whether or not cloning is possible, attempt to clone the MessageDigest object and catch the potential exception as follows: try { // try and clone it / compute the hash for i1 */ sha.update(i1); byte[] i1Hash = sha.clone().digest(); // ... byte[] i123hash = sha.digest(); } catch (CloneNotSupportedException cnse) { // do something else, such as the code shown below } If a message digest is not cloneable, the other, less elegant way to compute intermediate digests is to create several digests. In this case, the number of intermediate digests to be computed must be known in advance: MessageDigest sha1 = MessageDigest.getInstance(&quot;SHA-1&quot;); MessageDigest sha12 = MessageDigest.getInstance(&quot;SHA-1&quot;); MessageDigest sha123 = MessageDigest.getInstance(&quot;SHA-1&quot;); byte[] i1Hash = sha1.digest(i1); sha12.update(i1); byte[] i12Hash = sha12.digest(i2); sha123.update(i1); sha123.update(i2); byte[] i123Hash = sha123.digest(i3); Generating a Pair of Keys In this example we will generate a public-private key pair for the algorithm named &quot;DSA&quot; (Digital Signature Algorithm), and use this keypair in future examples. We will generate keys with a 1024-bit modulus. We don&apos;t care which provider supplies the algorithm implementation. Creating the Key Pair Generator The first step is to get a key pair generator object for generating keys for the DSA algorithm: KeyPairGenerator keyGen = KeyPairGenerator.getInstance(&quot;DSA&quot;); Initializing the Key Pair Generator The next step is to initialize the key pair generator. In most cases, algorithm-independent initialization is sufficient, but in some cases, algorithm-specific initialization is used. Algorithm-Independent Initialization All key pair generators share the concepts of a keysize and a source of randomness. The KeyPairGenerator class initialization methods at a minimum needs a keysize. If the source of randomness is not explicitly provided, a SecureRandom implementation of the highest-priority installed provider will be used. Thus to generate keys with a keysize of 1024, simply call: SecureRandom random = SecureRandom.getInstance(&quot;SHA1PRNG&quot;, &quot;SUN&quot;); keyGen.initialize(1024, random); The following code illustrates how to use a specific, additionally seeded SecureRandom object: SecureRandom random = SecureRandom.getInstance(&quot;SHA1PRNG&quot;, &quot;SUN&quot;); random.setSeed(userSeed); keyGen.initialize(1024, random); Since no other parameters are specified when you call the above algorithm-independent initialize method, it is up to the provider what to do about the algorithm-specific parameters (if any) to be associated with each of the keys. The provider may use precomputed parameter values or may generate new values. Algorithm-Specific Initialization For situations where a set of algorithm-specific parameters already exists (such as &quot;community parameters&quot; in DSA), there are two initialize methods that have an AlgorithmParameterSpec argument. Suppose your key pair generator is for the &quot;DSA&quot; algorithm, and you have a set of DSA-specific parameters, p, q, and g, that you would like to use to generate your key pair. You could execute the following code to initialize your key pair generator (recall that DSAParameterSpec is an AlgorithmParameterSpec): DSAParameterSpec dsaSpec = new DSAParameterSpec(p, q, g); SecureRandom random = SecureRandom.getInstance(&quot;SHA1PRNG&quot;, &quot;SUN&quot;); random.setSeed(userSeed); keyGen.initialize(dsaSpec, random); NOTE: The parameter named p is a prime number whose length is the modulus length (&quot;size&quot;). Therefore, you don&apos;t need to call any other method to specify the modulus length. Generating the Pair of Keys The final step is actually generating the key pair. No matter which type of initialization was used (algorithm-independent or algorithm-specific), the same code is used to generate the key pair: KeyPair pair = keyGen.generateKeyPair(); Generating and Verifying a Signature Using Generated Keys The following signature generation and verification examples use the KeyPair generated in the key pair example above. Generating a Signature We first create a signature object: Signature dsa = Signature.getInstance(&quot;SHA1withDSA&quot;); Next, using the key pair generated in the key pair example, we initialize the object with the private key, then sign a byte array called data. /* Initializing the object with a private key */ PrivateKey priv = pair.getPrivate(); dsa.initSign(priv); /* Update and sign the data */ dsa.update(data); byte[] sig = dsa.sign(); Verifying a Signature Verifying the signature is straightforward. (Note that here we also use the key pair generated in the key pair example.) /* Initializing the object with the public key */ PublicKey pub = pair.getPublic(); dsa.initVerify(pub); /* Update and verify the data */ dsa.update(data); boolean verifies = dsa.verify(sig); System.out.println(&quot;signature verifies: &quot; + verifies); Generating/Verifying Signatures Using Key Specifications and KeyFactory Suppose that, rather than having a public/private key pair (as, for example, was generated in the key pair example above), you simply have the components of your DSA private key: x (the private key), p (the prime), q (the sub-prime), and g (the base). Further suppose you want to use your private key to digitally sign some data, which is in a byte array named someData. You would do the following steps, which also illustrate creating a key specification and using a key factory to obtain a PrivateKey from the key specification (initSign requires a PrivateKey): DSAPrivateKeySpec dsaPrivKeySpec = new DSAPrivateKeySpec(x, p, q, g); KeyFactory keyFactory = KeyFactory.getInstance(&quot;DSA&quot;); PrivateKey privKey = keyFactory.generatePrivate(dsaPrivKeySpec); Signature sig = Signature.getInstance(&quot;SHA1withDSA&quot;); sig.initSign(privKey); sig.update(someData); byte[] signature = sig.sign(); Suppose Alice wants to use the data you signed. In order for her to do so, and to verify your signature, you need to send her three things: the data, the signature, and the public key corresponding to the private key you used to sign the data. You can store the someData bytes in one file, and the signature bytes in another, and send those to Alice. For the public key, assume, as in the signing example above, you have the components of the DSA public key corresponding to the DSA private key used to sign the data. Then you can create a DSAPublicKeySpec from those components: DSAPublicKeySpec dsaPubKeySpec = new DSAPublicKeySpec(y, p, q, g); You still need to extract the key bytes so that you can put them in a file. To do so, you can first call the generatePublic method on the DSA key factory already created in the example above: PublicKey pubKey = keyFactory.generatePublic(dsaPubKeySpec); Then you can extract the (encoded) key bytes via the following: byte[] encKey = pubKey.getEncoded(); You can now store these bytes in a file, and send it to Alice along with the files containing the data and the signature. Now, assume Alice has received these files, and she copied the data bytes from the data file to a byte array named data, the signature bytes from the signature file to a byte array named signature, and the encoded public key bytes from the public key file to a byte array named encodedPubKey. Alice can now execute the following code to verify the signature. The code also illustrates how to use a key factory in order to instantiate a DSA public key from its encoding (initVerify requires a PublicKey). X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(encodedPubKey); KeyFactory keyFactory = KeyFactory.getInstance(&quot;DSA&quot;); PublicKey pubKey = keyFactory.generatePublic(pubKeySpec); Signature sig = Signature.getInstance(&quot;SHA1withDSA&quot;); sig.initVerify(pubKey); sig.update(data); sig.verify(signature); NOTE: In the above, Alice needed to generate a PublicKey from the encoded key bits, since initVerify requires a PublicKey. Once she has a PublicKey, she could also use the KeyFactory getKeySpec method to convert it to a DSAPublicKeySpec so that she can access the components, if desired, as in: DSAPublicKeySpec dsaPubKeySpec = (DSAPublicKeySpec)keyFactory.getKeySpec(pubKey, DSAPublicKeySpec.class) Now she can access the DSA public key components y, p, q, and g through the corresponding &quot;get&quot; methods on the DSAPublicKeySpec class (getY, getP, getQ, and getG). Determining If Two Keys Are Equal In many cases you would like to know if two keys are equal; however, the default method java.lang.Object.equals may not give the desired result. The most provider-independent approach is to compare the encoded keys. If this comparison isn&apos;t appropriate (for example, when comparing an RSAPrivateKey and an RSAPrivateCrtKey), you should compare each component. The following code demonstrates this idea: static boolean keysEqual(Key key1, Key key2) { if (key1.equals(key2)) { return true; } if (Arrays.equals(key1.getEncoded(), key2.getEncoded())) { return true; } // More code for different types of keys here. // For example, the following code can check if // an RSAPrivateKey and an RSAPrivateCrtKey are equal: // if ((key1 instanceof RSAPrivateKey) &amp;&amp; // (key2 instanceof RSAPrivateKey)) { // if ((key1.getModulus().equals(key2.getModulus())) &amp;&amp; // (key1.getPrivateExponent().equals( // key2.getPrivateExponent()))) { // return true; // } // } return false; } Reading Base64-Encoded Certificates The following example reads a file with Base64-encoded certificates, which are each bounded at the beginning by -----BEGIN CERTIFICATE----- and at the end by -----END CERTIFICATE----- We convert the FileInputStream (which does not support mark and reset) to a ByteArrayInputStream (which supports those methods), so that each call to generateCertificate consumes only one certificate, and the read position of the input stream is positioned to the next certificate in the file: FileInputStream fis = new FileInputStream(filename); BufferedInputStream bis = new BufferedInputStream(fis); CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;); while (bis.available() &gt; 0) { Certificate cert = cf.generateCertificate(bis); System.out.println(cert.toString()); } Parsing a Certificate Reply The following example parses a PKCS7-formatted certificate reply stored in a file and extracts all the certificates from it: FileInputStream fis = new FileInputStream(filename); CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;); Collection c = cf.generateCertificates(fis); Iterator i = c.iterator(); while (i.hasNext()) { Certificate cert = (Certificate)i.next(); System.out.println(cert); } Using Encryption This section takes the user through the process of generating a key, creating and initializing a cipher object, encrypting a file, and then decrypting it. Throughout this example, we use the Advanced Encryption Standard (AES). Generating a Key To create an AES key, we have to instantiate a KeyGenerator for AES. We do not specify a provider, because we do not care about a particular AES key generation implementation. Since we do not initialize the KeyGenerator, a system-provided source of randomness and a default keysize will be used to create the AES key: KeyGenerator keygen = KeyGenerator.getInstance(&quot;AES&quot;); SecretKey aesKey = keygen.generateKey(); After the key has been generated, the same KeyGenerator object can be re-used to create further keys. Creating a Cipher The next step is to create a Cipher instance. To do this, we use one of the getInstance factory methods of the Cipher class. We must specify the name of the requested transformation, which includes the following components, separated by slashes (/): the algorithm name the mode (optional) the padding scheme (optional) In this example, we create an AES cipher in Electronic Codebook mode, with PKCS5-style padding. We do not specify a provider, because we do not care about a particular implementation of the requested transformation. The standard algorithm name for AES is &quot;AES&quot;, the standard name for the Electronic Codebook mode is &quot;ECB&quot;, and the standard name for PKCS5-style padding is &quot;PKCS5Padding&quot;: Cipher aesCipher; // Create the cipher aesCipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;); We use the generated aesKey from above to initialize the Cipher object for encryption: // Initialize the cipher for encryption aesCipher.init(Cipher.ENCRYPT_MODE, aesKey); // Our cleartext byte[] cleartext = &quot;This is just an example&quot;.getBytes(); // Encrypt the cleartext byte[] ciphertext = aesCipher.doFinal(cleartext); // Initialize the same cipher for decryption aesCipher.init(Cipher.DECRYPT_MODE, aesKey); // Decrypt the ciphertext byte[] cleartext1 = aesCipher.doFinal(ciphertext); cleartext and cleartext1 are identical. Using Password-Based Encryption In this example, we prompt the user for a password from which we derive an encryption key. It would seem logical to collect and store the password in an object of type java.lang.String. However, here&apos;s the caveat: Objects of type String are immutable, i.e., there are no methods defined that allow you to change (overwrite) or zero out the contents of a String after usage. This feature makes String objects unsuitable for storing security sensitive information such as user passwords. You should always collect and store security sensitive information in a char array instead. For that reason, the javax.crypto.spec.PBEKeySpec class takes (and returns) a password as a char array. See the ReadPassword class in the sample code in Appendix D for one possible way of reading character array passwords from an input stream. In order to use Password-Based Encryption (PBE) as defined in PKCS5, we have to specify a salt and an iteration count. The same salt and iteration count that are used for encryption must be used for decryption. Newer PBE algorithms use an iteration count of atleast 1000. 1234567891011121314151617181920212223242526272829303132333435363738PBEKeySpec pbeKeySpec;PBEParameterSpec pbeParamSpec;SecretKeyFactory keyFac;// Saltbyte[] salt = { (byte)0xc7, (byte)0x73, (byte)0x21, (byte)0x8c, (byte)0x7e, (byte)0xc8, (byte)0xee, (byte)0x99};// Iteration countint count = 1000;// Create PBE parameter setpbeParamSpec = new PBEParameterSpec(salt, count);// Prompt user for encryption password.// Collect user password as char array (using the// &quot;readPassword&quot; method from above), and convert// it into a SecretKey object, using a PBE key// factory.System.out.print(&quot;Enter encryption password: &quot;);System.out.flush();pbeKeySpec = new PBEKeySpec(readPassword(System.in));keyFac = SecretKeyFactory.getInstance(&quot;PBEWithHmacSHA256AndAES_256&quot;);SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);// Create PBE CipherCipher pbeCipher = Cipher.getInstance(&quot;PBEWithHmacSHA256AndAES_256&quot;);// Initialize PBE Cipher with key and parameterspbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);// Our cleartextbyte[] cleartext = &quot;This is another example&quot;.getBytes();// Encrypt the cleartextbyte[] ciphertext = pbeCipher.doFinal(cleartext); Using Key Agreement Please refer to Appendix D for sample programs exercising the Diffie-Hellman key exchange between 2 and 3 parties. Appendix A: Standard Names The JDK Security API requires and uses a set of standard names for algorithms, certificate and keystore types. The specification names previously found here in Appendix A and in the other security specifications (JSSE/CertPath/etc.) have been combined in the Standard Names document. This document also contains more information about the algorithm specifications. Specific provider information can be found in the Sun Provider Documentation. Cryptographic implementations in the JDK are distributed through several different providers primarily for historical reasons (Sun, SunJSSE, SunJCE, SunRsaSign). Note these providers may not be available on all JDK implementations, and therefore, truly portable applications should call getInstance() without specifying specific providers. Applications specifying a particular provider may not be able to take advantage of native providers tuned for an underlying operating environment (such as PKCS or Microsoft&apos;s CAPI). The SunPKCS11 provider itself does not contain any cryptographic algorithms, but instead, directs requests into an underlying PKCS11 implementation. The PKCS11 Reference Guide and the underlying PKCS11 implementation should be consulted to determine if a desired algorithm will be available through the PKCS11 provider. Likewise, on Windows systems, the SunMSCAPI provider does not provide any cryptographic functionality, but instead routes requests to the underlying Operating System for handling. Appendix B: Jurisdiction Policy File Format JCA represents its jurisdiction policy files as Java style policy files with corresponding permission statements. As described in Default Policy Implementation and Policy File Syntax, a Java policy file specifies what permissions are allowed for code from specified code sources. A permission represents access to a system resource. In the case of JCA, the &quot;resources&quot; are cryptography algorithms, and code sources do not need to be specified, because the cryptographic restrictions apply to all code. A jurisdiction policy file consists of a very basic &quot;grant entry&quot; containing one or more &quot;permission entries.&quot; grant { &lt;permission entries&gt;; }; The format of a permission entry in a jurisdiction policy file is: permission &lt;crypto permission class name&gt;[ &lt;alg_name&gt; [[, &lt;exemption mechanism name&gt;][, &lt;maxKeySize&gt; [, &lt;AlgorithmParameterSpec class name&gt;, &lt;parameters for constructing an AlgorithmParameterSpec object&gt;]]]]; A sample jurisdiction policy file that includes restricting the &quot;Blowfish&quot; algorithm to maximum key sizes of 64 bits is: grant { permission javax.crypto.CryptoPermission &quot;Blowfish&quot;, 64; // ... }; A permission entry must begin with the word permission. The &lt;crypto permission class name&gt; in the template above would actually be a specific permission class name, such as javax.crypto.CryptoPermission. A crypto permission class reflects the ability of an application/applet to use certain algorithms with certain key sizes in certain environments. There are two crypto permission classes: CryptoPermission and CryptoAllPermission. The special CryptoAllPermission class implies all cryptography-related permissions, that is, it specifies that there are no cryptography-related restrictions. The &lt;alg_name&gt;, when utilized, is a quoted string specifying the standard name (see Appendix A) of a cryptography algorithm, such as &quot;DES&quot; or &quot;RSA&quot;. The &lt;exemption mechanism name&gt;, when specified, is a quoted string indicating an exemption mechanism which, if enforced, enables a reduction in cryptographic restrictions. Exemption mechanism names that can be used include &quot;KeyRecovery&quot; &quot;KeyEscrow&quot;, and &quot;KeyWeakening&quot;. &lt;maxKeySize&gt; is an integer specifying the maximum key size (in bits) allowed for the specified algorithm. For some algorithms it may not be sufficient to specify the algorithm strength in terms of just a key size. For example, in the case of the &quot;RC5&quot; algorithm, the number of rounds must also be considered. For algorithms whose strength needs to be expressed as more than a key size, the permission entry should also specify an AlgorithmParameterSpec class name (such as javax.crypto.spec.RC5ParameterSpec) and a list of parameters for constructing the specified AlgorithmParameterSpec object. Items that appear in a permission entry must appear in the specified order. An entry is terminated with a semicolon. Case is unimportant for the identifiers (grant, permission) but is significant for the &lt;crypto permission class name&gt; or for any string that is passed in as a value. NOTE: An &quot;&quot; can be used as a wildcard for any permission entry option. For example, an &quot;&quot; (without the quotes) for an &lt;alg_name&gt; option means &quot;all algorithms.&quot; Appendix C: Maximum Key Sizes Allowed by &quot;Strong&quot; Jurisdiction Policy Files Due to import control restrictions, the jurisdiction policy files shipped with the Java SE Development Kit allow &quot;strong&quot; but limited cryptography to be used. For more info, please see Import Limits on Cryptographic Algorithms. Appendix D: Sample Programs Diffie-Hellman Key Exchange between 2 Parties 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372/* * Copyright (c) 1997, 2001, Oracle and/or its affiliates. All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * - Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer. * * - Redistributions in binary form must reproduce the above copyright * notice, this list of conditions and the following disclaimer in the * documentation and/or other materials provided with the distribution. * * - Neither the name of Oracle nor the names of its * contributors may be used to endorse or promote products derived * from this software without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS * IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */import java.io.*;import java.math.BigInteger;import java.security.*;import java.security.spec.*;import java.security.interfaces.*;import javax.crypto.*;import javax.crypto.spec.*;import javax.crypto.interfaces.*;import com.sun.crypto.provider.SunJCE;/** * This program executes the Diffie-Hellman key agreement protocol * between 2 parties: Alice and Bob. * * By default, preconfigured parameters (1024-bit prime modulus and base * generator used by SKIP) are used. * If this program is called with the &quot;-gen&quot; option, a new set of * parameters is created. */public class DHKeyAgreement2 { private DHKeyAgreement2() {} public static void main(String argv[]) { try { String mode = &quot;USE_SKIP_DH_PARAMS&quot;; DHKeyAgreement2 keyAgree = new DHKeyAgreement2(); if (argv.length &gt; 1) { keyAgree.usage(); throw new Exception(&quot;Wrong number of command options&quot;); } else if (argv.length == 1) { if (!(argv[0].equals(&quot;-gen&quot;))) { keyAgree.usage(); throw new Exception(&quot;Unrecognized flag: &quot; + argv[0]); } mode = &quot;GENERATE_DH_PARAMS&quot;; } keyAgree.run(mode); } catch (Exception e) { System.err.println(&quot;Error: &quot; + e); System.exit(1); } } private void run(String mode) throws Exception { DHParameterSpec dhSkipParamSpec; if (mode.equals(&quot;GENERATE_DH_PARAMS&quot;)) { // Some central authority creates new DH parameters System.out.println (&quot;Creating Diffie-Hellman parameters (takes VERY long) ...&quot;); AlgorithmParameterGenerator paramGen = AlgorithmParameterGenerator.getInstance(&quot;DH&quot;); paramGen.init(512); AlgorithmParameters params = paramGen.generateParameters(); dhSkipParamSpec = (DHParameterSpec)params.getParameterSpec (DHParameterSpec.class); } else { // use some pre-generated, default DH parameters System.out.println(&quot;Using SKIP Diffie-Hellman parameters&quot;); dhSkipParamSpec = new DHParameterSpec(skip1024Modulus, skip1024Base); } /* * Alice creates her own DH key pair, using the DH parameters from * above */ System.out.println(&quot;ALICE: Generate DH keypair ...&quot;); KeyPairGenerator aliceKpairGen = KeyPairGenerator.getInstance(&quot;DH&quot;); aliceKpairGen.initialize(dhSkipParamSpec); KeyPair aliceKpair = aliceKpairGen.generateKeyPair(); // Alice creates and initializes her DH KeyAgreement object System.out.println(&quot;ALICE: Initialization ...&quot;); KeyAgreement aliceKeyAgree = KeyAgreement.getInstance(&quot;DH&quot;); aliceKeyAgree.init(aliceKpair.getPrivate()); // Alice encodes her public key, and sends it over to Bob. byte[] alicePubKeyEnc = aliceKpair.getPublic().getEncoded(); /* * Let&apos;s turn over to Bob. Bob has received Alice&apos;s public key * in encoded format. * He instantiates a DH public key from the encoded key material. */ KeyFactory bobKeyFac = KeyFactory.getInstance(&quot;DH&quot;); X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec (alicePubKeyEnc); PublicKey alicePubKey = bobKeyFac.generatePublic(x509KeySpec); /* * Bob gets the DH parameters associated with Alice&apos;s public key. * He must use the same parameters when he generates his own key * pair. */ DHParameterSpec dhParamSpec = ((DHPublicKey)alicePubKey).getParams(); // Bob creates his own DH key pair System.out.println(&quot;BOB: Generate DH keypair ...&quot;); KeyPairGenerator bobKpairGen = KeyPairGenerator.getInstance(&quot;DH&quot;); bobKpairGen.initialize(dhParamSpec); KeyPair bobKpair = bobKpairGen.generateKeyPair(); // Bob creates and initializes his DH KeyAgreement object System.out.println(&quot;BOB: Initialization ...&quot;); KeyAgreement bobKeyAgree = KeyAgreement.getInstance(&quot;DH&quot;); bobKeyAgree.init(bobKpair.getPrivate()); // Bob encodes his public key, and sends it over to Alice. byte[] bobPubKeyEnc = bobKpair.getPublic().getEncoded(); /* * Alice uses Bob&apos;s public key for the first (and only) phase * of her version of the DH * protocol. * Before she can do so, she has to instantiate a DH public key * from Bob&apos;s encoded key material. */ KeyFactory aliceKeyFac = KeyFactory.getInstance(&quot;DH&quot;); x509KeySpec = new X509EncodedKeySpec(bobPubKeyEnc); PublicKey bobPubKey = aliceKeyFac.generatePublic(x509KeySpec); System.out.println(&quot;ALICE: Execute PHASE1 ...&quot;); aliceKeyAgree.doPhase(bobPubKey, true); /* * Bob uses Alice&apos;s public key for the first (and only) phase * of his version of the DH * protocol. */ System.out.println(&quot;BOB: Execute PHASE1 ...&quot;); bobKeyAgree.doPhase(alicePubKey, true); /* * At this stage, both Alice and Bob have completed the DH key * agreement protocol. * Both generate the (same) shared secret. */ byte[] aliceSharedSecret = aliceKeyAgree.generateSecret(); int aliceLen = aliceSharedSecret.length; byte[] bobSharedSecret = new byte[aliceLen]; int bobLen; try { // show example of what happens if you // provide an output buffer that is too short bobLen = bobKeyAgree.generateSecret(bobSharedSecret, 1); } catch (ShortBufferException e) { System.out.println(e.getMessage()); } // provide output buffer of required size bobLen = bobKeyAgree.generateSecret(bobSharedSecret, 0); System.out.println(&quot;Alice secret: &quot; + toHexString(aliceSharedSecret)); System.out.println(&quot;Bob secret: &quot; + toHexString(bobSharedSecret)); if (!java.util.Arrays.equals(aliceSharedSecret, bobSharedSecret)) throw new Exception(&quot;Shared secrets differ&quot;); System.out.println(&quot;Shared secrets are the same&quot;); /* * Now let&apos;s return the shared secret as a SecretKey object * and use it for encryption. First, we generate SecretKeys for the * &quot;DES&quot; algorithm (based on the raw shared secret data) and * then we use DES in ECB mode * as the encryption algorithm. DES in ECB mode does not require any * parameters. * * Then we use DES in CBC mode, which requires an initialization * vector (IV) parameter. In CBC mode, you need to initialize the * Cipher object with an IV, which can be supplied using the * javax.crypto.spec.IvParameterSpec class. Note that you have to use * the same IV for encryption and decryption: If you use a different * IV for decryption than you used for encryption, decryption will * fail. * * NOTE: If you do not specify an IV when you initialize the * Cipher object for encryption, the underlying implementation * will generate a random one, which you have to retrieve using the * javax.crypto.Cipher.getParameters() method, which returns an * instance of java.security.AlgorithmParameters. You need to transfer * the contents of that object (e.g., in encoded format, obtained via * the AlgorithmParameters.getEncoded() method) to the party who will * do the decryption. When initializing the Cipher for decryption, * the (reinstantiated) AlgorithmParameters object must be passed to * the Cipher.init() method. */ System.out.println(&quot;Return shared secret as SecretKey object ...&quot;); // Bob // NOTE: The call to bobKeyAgree.generateSecret above reset the key // agreement object, so we call doPhase again prior to another // generateSecret call bobKeyAgree.doPhase(alicePubKey, true); SecretKey bobDesKey = bobKeyAgree.generateSecret(&quot;DES&quot;); // Alice // NOTE: The call to aliceKeyAgree.generateSecret above reset the key // agreement object, so we call doPhase again prior to another // generateSecret call aliceKeyAgree.doPhase(bobPubKey, true); SecretKey aliceDesKey = aliceKeyAgree.generateSecret(&quot;DES&quot;); /* * Bob encrypts, using DES in ECB mode */ Cipher bobCipher = Cipher.getInstance(&quot;DES/ECB/PKCS5Padding&quot;); bobCipher.init(Cipher.ENCRYPT_MODE, bobDesKey); byte[] cleartext = &quot;This is just an example&quot;.getBytes(); byte[] ciphertext = bobCipher.doFinal(cleartext); /* * Alice decrypts, using DES in ECB mode */ Cipher aliceCipher = Cipher.getInstance(&quot;DES/ECB/PKCS5Padding&quot;); aliceCipher.init(Cipher.DECRYPT_MODE, aliceDesKey); byte[] recovered = aliceCipher.doFinal(ciphertext); if (!java.util.Arrays.equals(cleartext, recovered)) throw new Exception(&quot;DES in CBC mode recovered text is &quot; + &quot;different from cleartext&quot;); System.out.println(&quot;DES in ECB mode recovered text is &quot; + &quot;same as cleartext&quot;); /* * Bob encrypts, using DES in CBC mode */ bobCipher = Cipher.getInstance(&quot;DES/CBC/PKCS5Padding&quot;); bobCipher.init(Cipher.ENCRYPT_MODE, bobDesKey); cleartext = &quot;This is just an example&quot;.getBytes(); ciphertext = bobCipher.doFinal(cleartext); // Retrieve the parameter that was used, and transfer it to Alice in // encoded format byte[] encodedParams = bobCipher.getParameters().getEncoded(); /* * Alice decrypts, using DES in CBC mode */ // Instantiate AlgorithmParameters object from parameter encoding // obtained from Bob AlgorithmParameters params = AlgorithmParameters.getInstance(&quot;DES&quot;); params.init(encodedParams); aliceCipher = Cipher.getInstance(&quot;DES/CBC/PKCS5Padding&quot;); aliceCipher.init(Cipher.DECRYPT_MODE, aliceDesKey, params); recovered = aliceCipher.doFinal(ciphertext); if (!java.util.Arrays.equals(cleartext, recovered)) throw new Exception(&quot;DES in CBC mode recovered text is &quot; + &quot;different from cleartext&quot;); System.out.println(&quot;DES in CBC mode recovered text is &quot; + &quot;same as cleartext&quot;); } /* * Converts a byte to hex digit and writes to the supplied buffer */ private void byte2hex(byte b, StringBuffer buf) { char[] hexChars = { &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos; }; int high = ((b &amp; 0xf0) &gt;&gt; 4); int low = (b &amp; 0x0f); buf.append(hexChars[high]); buf.append(hexChars[low]); } /* * Converts a byte array to hex string */ private String toHexString(byte[] block) { StringBuffer buf = new StringBuffer(); int len = block.length; for (int i = 0; i &lt; len; i++) { byte2hex(block[i], buf); if (i &lt; len-1) { buf.append(&quot;:&quot;); } } return buf.toString(); } /* * Prints the usage of this test. */ private void usage() { System.err.print(&quot;DHKeyAgreement usage: &quot;); System.err.println(&quot;[-gen]&quot;); } // The 1024 bit Diffie-Hellman modulus values used by SKIP private static final byte skip1024ModulusBytes[] = { (byte)0xF4, (byte)0x88, (byte)0xFD, (byte)0x58, (byte)0x4E, (byte)0x49, (byte)0xDB, (byte)0xCD, (byte)0x20, (byte)0xB4, (byte)0x9D, (byte)0xE4, (byte)0x91, (byte)0x07, (byte)0x36, (byte)0x6B, (byte)0x33, (byte)0x6C, (byte)0x38, (byte)0x0D, (byte)0x45, (byte)0x1D, (byte)0x0F, (byte)0x7C, (byte)0x88, (byte)0xB3, (byte)0x1C, (byte)0x7C, (byte)0x5B, (byte)0x2D, (byte)0x8E, (byte)0xF6, (byte)0xF3, (byte)0xC9, (byte)0x23, (byte)0xC0, (byte)0x43, (byte)0xF0, (byte)0xA5, (byte)0x5B, (byte)0x18, (byte)0x8D, (byte)0x8E, (byte)0xBB, (byte)0x55, (byte)0x8C, (byte)0xB8, (byte)0x5D, (byte)0x38, (byte)0xD3, (byte)0x34, (byte)0xFD, (byte)0x7C, (byte)0x17, (byte)0x57, (byte)0x43, (byte)0xA3, (byte)0x1D, (byte)0x18, (byte)0x6C, (byte)0xDE, (byte)0x33, (byte)0x21, (byte)0x2C, (byte)0xB5, (byte)0x2A, (byte)0xFF, (byte)0x3C, (byte)0xE1, (byte)0xB1, (byte)0x29, (byte)0x40, (byte)0x18, (byte)0x11, (byte)0x8D, (byte)0x7C, (byte)0x84, (byte)0xA7, (byte)0x0A, (byte)0x72, (byte)0xD6, (byte)0x86, (byte)0xC4, (byte)0x03, (byte)0x19, (byte)0xC8, (byte)0x07, (byte)0x29, (byte)0x7A, (byte)0xCA, (byte)0x95, (byte)0x0C, (byte)0xD9, (byte)0x96, (byte)0x9F, (byte)0xAB, (byte)0xD0, (byte)0x0A, (byte)0x50, (byte)0x9B, (byte)0x02, (byte)0x46, (byte)0xD3, (byte)0x08, (byte)0x3D, (byte)0x66, (byte)0xA4, (byte)0x5D, (byte)0x41, (byte)0x9F, (byte)0x9C, (byte)0x7C, (byte)0xBD, (byte)0x89, (byte)0x4B, (byte)0x22, (byte)0x19, (byte)0x26, (byte)0xBA, (byte)0xAB, (byte)0xA2, (byte)0x5E, (byte)0xC3, (byte)0x55, (byte)0xE9, (byte)0x2F, (byte)0x78, (byte)0xC7 }; // The SKIP 1024 bit modulus private static final BigInteger skip1024Modulus = new BigInteger(1, skip1024ModulusBytes); // The base used with the SKIP 1024 bit modulus private static final BigInteger skip1024Base = BigInteger.valueOf(2);} Diffie-Hellman Key Exchange between 3 Parties 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286/* * Copyright (c) 1997, 2001, Oracle and/or its affiliates. All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * - Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer. * * - Redistributions in binary form must reproduce the above copyright * notice, this list of conditions and the following disclaimer in the * documentation and/or other materials provided with the distribution. * * - Neither the name of Oracle nor the names of its * contributors may be used to endorse or promote products derived * from this software without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS * IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */import java.io.*;import java.math.BigInteger;import java.security.*;import java.security.spec.*;import java.security.interfaces.*;import javax.crypto.*;import javax.crypto.spec.*;import javax.crypto.interfaces.*;import com.sun.crypto.provider.SunJCE;/** * This program executes the Diffie-Hellman key agreement protocol * between 3 parties: Alice, Bob, and Carol. * * We use the same 1024-bit prime modulus and base generator that are * used by SKIP. */public class DHKeyAgreement3 { private DHKeyAgreement3() {} public static void main(String argv[]) { try { DHKeyAgreement3 keyAgree = new DHKeyAgreement3(); keyAgree.run(); } catch (Exception e) { System.err.println(&quot;Error: &quot; + e); System.exit(1); } } private void run() throws Exception { DHParameterSpec dhSkipParamSpec; System.out.println(&quot;Using SKIP Diffie-Hellman parameters&quot;); dhSkipParamSpec = new DHParameterSpec(skip1024Modulus, skip1024Base); // Alice creates her own DH key pair System.out.println(&quot;ALICE: Generate DH keypair ...&quot;); KeyPairGenerator aliceKpairGen = KeyPairGenerator.getInstance(&quot;DH&quot;); aliceKpairGen.initialize(dhSkipParamSpec); KeyPair aliceKpair = aliceKpairGen.generateKeyPair(); // Bob creates his own DH key pair System.out.println(&quot;BOB: Generate DH keypair ...&quot;); KeyPairGenerator bobKpairGen = KeyPairGenerator.getInstance(&quot;DH&quot;); bobKpairGen.initialize(dhSkipParamSpec); KeyPair bobKpair = bobKpairGen.generateKeyPair(); // Carol creates her own DH key pair System.out.println(&quot;CAROL: Generate DH keypair ...&quot;); KeyPairGenerator carolKpairGen = KeyPairGenerator.getInstance(&quot;DH&quot;); carolKpairGen.initialize(dhSkipParamSpec); KeyPair carolKpair = carolKpairGen.generateKeyPair(); // Alice initialize System.out.println(&quot;ALICE: Initialize ...&quot;); KeyAgreement aliceKeyAgree = KeyAgreement.getInstance(&quot;DH&quot;); aliceKeyAgree.init(aliceKpair.getPrivate()); // Bob initialize System.out.println(&quot;BOB: Initialize ...&quot;); KeyAgreement bobKeyAgree = KeyAgreement.getInstance(&quot;DH&quot;); bobKeyAgree.init(bobKpair.getPrivate()); // Carol initialize System.out.println(&quot;CAROL: Initialize ...&quot;); KeyAgreement carolKeyAgree = KeyAgreement.getInstance(&quot;DH&quot;); carolKeyAgree.init(carolKpair.getPrivate()); // Alice uses Carol&apos;s public key Key ac = aliceKeyAgree.doPhase(carolKpair.getPublic(), false); // Bob uses Alice&apos;s public key Key ba = bobKeyAgree.doPhase(aliceKpair.getPublic(), false); // Carol uses Bob&apos;s public key Key cb = carolKeyAgree.doPhase(bobKpair.getPublic(), false); // Alice uses Carol&apos;s result from above aliceKeyAgree.doPhase(cb, true); // Bob uses Alice&apos;s result from above bobKeyAgree.doPhase(ac, true); // Carol uses Bob&apos;s result from above carolKeyAgree.doPhase(ba, true); // Alice, Bob and Carol compute their secrets byte[] aliceSharedSecret = aliceKeyAgree.generateSecret(); System.out.println(&quot;Alice secret: &quot; + toHexString(aliceSharedSecret)); byte[] bobSharedSecret = bobKeyAgree.generateSecret(); System.out.println(&quot;Bob secret: &quot; + toHexString(bobSharedSecret)); byte[] carolSharedSecret = carolKeyAgree.generateSecret(); System.out.println(&quot;Carol secret: &quot; + toHexString(carolSharedSecret)); // Compare Alice and Bob if (!java.util.Arrays.equals(aliceSharedSecret, bobSharedSecret)) throw new Exception(&quot;Alice and Bob differ&quot;); System.out.println(&quot;Alice and Bob are the same&quot;); // Compare Bob and Carol if (!java.util.Arrays.equals(bobSharedSecret, carolSharedSecret)) throw new Exception(&quot;Bob and Carol differ&quot;); System.out.println(&quot;Bob and Carol are the same&quot;); } /* * Converts a byte to hex digit and writes to the supplied buffer */ private void byte2hex(byte b, StringBuffer buf) { char[] hexChars = { &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos; }; int high = ((b &amp; 0xf0) &gt;&gt; 4); int low = (b &amp; 0x0f); buf.append(hexChars[high]); buf.append(hexChars[low]); } /* * Converts a byte array to hex string */ private String toHexString(byte[] block) { StringBuffer buf = new StringBuffer(); int len = block.length; for (int i = 0; i &lt; len; i++) { byte2hex(block[i], buf); if (i &lt; len-1) { buf.append(&quot;:&quot;); } } return buf.toString(); } /* * Prints the usage of this test. */ private void usage() { System.err.print(&quot;DHKeyAgreement usage: &quot;); System.err.println(&quot;[-gen]&quot;); } // The 1024 bit Diffie-Hellman modulus values used by SKIP private static final byte skip1024ModulusBytes[] = { (byte)0xF4, (byte)0x88, (byte)0xFD, (byte)0x58, (byte)0x4E, (byte)0x49, (byte)0xDB, (byte)0xCD, (byte)0x20, (byte)0xB4, (byte)0x9D, (byte)0xE4, (byte)0x91, (byte)0x07, (byte)0x36, (byte)0x6B, (byte)0x33, (byte)0x6C, (byte)0x38, (byte)0x0D, (byte)0x45, (byte)0x1D, (byte)0x0F, (byte)0x7C, (byte)0x88, (byte)0xB3, (byte)0x1C, (byte)0x7C, (byte)0x5B, (byte)0x2D, (byte)0x8E, (byte)0xF6, (byte)0xF3, (byte)0xC9, (byte)0x23, (byte)0xC0, (byte)0x43, (byte)0xF0, (byte)0xA5, (byte)0x5B, (byte)0x18, (byte)0x8D, (byte)0x8E, (byte)0xBB, (byte)0x55, (byte)0x8C, (byte)0xB8, (byte)0x5D, (byte)0x38, (byte)0xD3, (byte)0x34, (byte)0xFD, (byte)0x7C, (byte)0x17, (byte)0x57, (byte)0x43, (byte)0xA3, (byte)0x1D, (byte)0x18, (byte)0x6C, (byte)0xDE, (byte)0x33, (byte)0x21, (byte)0x2C, (byte)0xB5, (byte)0x2A, (byte)0xFF, (byte)0x3C, (byte)0xE1, (byte)0xB1, (byte)0x29, (byte)0x40, (byte)0x18, (byte)0x11, (byte)0x8D, (byte)0x7C, (byte)0x84, (byte)0xA7, (byte)0x0A, (byte)0x72, (byte)0xD6, (byte)0x86, (byte)0xC4, (byte)0x03, (byte)0x19, (byte)0xC8, (byte)0x07, (byte)0x29, (byte)0x7A, (byte)0xCA, (byte)0x95, (byte)0x0C, (byte)0xD9, (byte)0x96, (byte)0x9F, (byte)0xAB, (byte)0xD0, (byte)0x0A, (byte)0x50, (byte)0x9B, (byte)0x02, (byte)0x46, (byte)0xD3, (byte)0x08, (byte)0x3D, (byte)0x66, (byte)0xA4, (byte)0x5D, (byte)0x41, (byte)0x9F, (byte)0x9C, (byte)0x7C, (byte)0xBD, (byte)0x89, (byte)0x4B, (byte)0x22, (byte)0x19, (byte)0x26, (byte)0xBA, (byte)0xAB, (byte)0xA2, (byte)0x5E, (byte)0xC3, (byte)0x55, (byte)0xE9, (byte)0x2F, (byte)0x78, (byte)0xC7 }; // The SKIP 1024 bit modulus private static final BigInteger skip1024Modulus = new BigInteger(1, skip1024ModulusBytes); // The base used with the SKIP 1024 bit modulus private static final BigInteger skip1024Base = BigInteger.valueOf(2);}Blowfish Cipher Example/* * Copyright (c) 1997, 2001, Oracle and/or its affiliates. All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * - Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer. * * - Redistributions in binary form must reproduce the above copyright * notice, this list of conditions and the following disclaimer in the * documentation and/or other materials provided with the distribution. * * - Neither the name of Oracle nor the names of its * contributors may be used to endorse or promote products derived * from this software without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS * IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */import java.security.*;import javax.crypto.*;import javax.crypto.spec.*;/** * This program generates a Blowfish key, retrieves its raw bytes, and * then reinstantiates a Blowfish key from the key bytes. * The reinstantiated key is used to initialize a Blowfish cipher for * encryption. */public class BlowfishKey { public static void main(String[] args) throws Exception { KeyGenerator kgen = KeyGenerator.getInstance(&quot;Blowfish&quot;); SecretKey skey = kgen.generateKey(); byte[] raw = skey.getEncoded(); SecretKeySpec skeySpec = new SecretKeySpec(raw, &quot;Blowfish&quot;); Cipher cipher = Cipher.getInstance(&quot;Blowfish&quot;); cipher.init(Cipher.ENCRYPT_MODE, skeySpec); byte[] encrypted = cipher.doFinal(&quot;This is just an example&quot;.getBytes()); }} HMAC-MD5 Example 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210/* * Copyright (c) 1997, 2001, Oracle and/or its affiliates. All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * - Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer. * * - Redistributions in binary form must reproduce the above copyright * notice, this list of conditions and the following disclaimer in the * documentation and/or other materials provided with the distribution. * * - Neither the name of Oracle nor the names of its * contributors may be used to endorse or promote products derived * from this software without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS * IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */import java.security.*;import javax.crypto.*;/** * This program demonstrates how to generate a secret-key object for * HMAC-MD5, and initialize an HMAC-MD5 object with it. */public class initMac { public static void main(String[] args) throws Exception { // Generate secret key for HMAC-MD5 KeyGenerator kg = KeyGenerator.getInstance(&quot;HmacMD5&quot;); SecretKey sk = kg.generateKey(); // Get instance of Mac object implementing HMAC-MD5, and // initialize it with the above secret key Mac mac = Mac.getInstance(&quot;HmacMD5&quot;); mac.init(sk); byte[] result = mac.doFinal(&quot;Hi There&quot;.getBytes()); }}Reading ASCII Passwords From an InputStream Example/* * @(#)ReadPassword.java 1.1 06/06/07 * * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. */import java.util.*;import java.io.*;import java.security.*;public class ReadPassword { /** * Read a password from the InputStream &quot;in&quot;. * &lt;p&gt; * As Strings are immutable, passwords should be stored as an array * of characters, which can be blanked out when no longer needed. * &lt;p&gt; * If the provided InputStream is the System&apos;s Console, this method * uses the non-echoing readPassword() method of java.io.Console * (new to JDK 6). If not, a fallback implementation is used. * &lt;p&gt; * NOTE: For expository purposes, and because some applications do * not understand multi-byte characters, only 8-bit ASCII passwords * are handled here. * &lt;p&gt; * NOTE: If a SecurityManager is used, the default standard * java.policy file found in the JDK (i.e. * &lt;java-home&gt;/lib/security/java.policy) allows reading the * line.separator property. If your environment is different, this * code will need to be granted the appropriate privilege. * * @param in * the InputStream used to obtain the password. * * @return A character array containing the password or passphrase, * not including the line-termination characters, * or null if an end of stream has been reached. * * @throws IOException * if an I/O problem occurs */ public static final char[] readPassword(InputStream in) throws IOException { /* * If available, directly use the java.io.Console class to * avoid character echoing. */ if (in == System.in &amp;&amp; System.console() != null) { // readPassword returns &quot;&quot; if you just print ENTER, return System.console().readPassword(); } /* * If a console is not available, read the InputStream * directly. This approach may cause password echoing. * * Since different operating systems have different End-Of-Line * (EOL) sequences, this algorithm should allow for * platform-independent implementations. Typical EOL sequences * are a single line feed (&apos;\\n&apos;), or a carriage return/linefeed * combination (&apos;\\r\\n&apos;). However, some OS&apos;s use a single * a carriage return (&apos;\\r&apos;), which complicates portability. * * Since we may not have the ability to push bytes back into the * InputStream, another approach is used here. The javadoc for * &lt;code&gt;java.lang.System.getProperties()&lt;/code&gt; specifies that * the set of system properties will contain a system-specific * value for the &quot;line.separator&quot;. Scan for this character * sequence instead of hard-coding a particular sequence. */ /* * Enclose the getProperty in a doPrivileged block to minimize * the call stack permission required. */ char [] EOL = AccessController.doPrivileged( new PrivilegedAction&lt;char[]&gt;() { public char[] run() { String s = System.getProperty(&quot;line.separator&quot;); // Shouldn&apos;t happen. if (s == null) { throw new RuntimeException( &quot;line.separator not defined&quot;); } return s.toCharArray(); } }); char [] buffer = new char[128]; try { int len = 0; // len of data in buffer. boolean done = false; // found the EOL sequence int b; // byte read while (!done) { /* * realloc if necessary */ if (len &gt;= buffer.length) { char [] newbuffer = new char[len + 128]; System.arraycopy(buffer, 0, newbuffer, 0, len); Arrays.fill(buffer, &apos; &apos;); buffer = newbuffer; } /* * End-of-Stream? */ if ((b = in.read()) == -1) { // Return as much as we have, null otherwise. if (len == 0) { return null; } break; } else { /* * NOTE: In the simple PBE example here, * only 8 bit ASCII characters are handled. */ buffer[len++] = (char) b; } /* * check for the EOL sequence. Do we have enough bytes? */ if (len &gt;= EOL.length) { int i = 0; for (i = 0; i &lt; EOL.length; i++) { if (buffer[len - EOL.length + i] != EOL[i]) { break; } } done = (i == EOL.length); } } /* * If we found the EOL, strip the EOL chars. */ char [] result = new char[done ? len - EOL.length : len]; System.arraycopy(buffer, 0, result, 0, result.length); return result; } finally { /* * Zero out the buffer. */ if (buffer != null) { Arrays.fill(buffer, &apos; &apos;); } } }}","categories":[{"name":"java","slug":"java","permalink":"https://yyhan.github.io/categories/java/"}],"tags":[{"name":"security","slug":"security","permalink":"https://yyhan.github.io/tags/security/"},{"name":"jca","slug":"jca","permalink":"https://yyhan.github.io/tags/jca/"}]},{"title":"java 安全体系","slug":"java-安全体系","date":"2017-06-29T15:25:48.000Z","updated":"2017-06-29T17:29:41.496Z","comments":true,"path":"2017/06/29/java-安全体系/","link":"","permalink":"https://yyhan.github.io/2017/06/29/java-安全体系/","excerpt":"","text":"&#x539F;&#x6587;&#x5730;&#x5740;&#xFF1A;Security Security Java security technology includes a large set of APIs, tools, and implementations of commonly-used security algorithms, mechanisms, and protocols. The Java security APIs span a wide range of areas, including cryptography, public key infrastructure, secure communication, authentication, and access control. Java security technology provides the developer with a comprehensive security framework for writing applications, and also provides the user or administrator with a a set of tools to securely manage applications. Java&#x5B89;&#x5168;&#x6280;&#x672F;&#x5305;&#x62EC;&#x5927;&#x91CF;&#x7684;API&#xFF0C;&#x5DE5;&#x5177;&#x548C;&#x5E38;&#x7528;&#x5B89;&#x5168;&#x7B97;&#x6CD5;&#xFF0C;&#x673A;&#x5236;&#x548C;&#x534F;&#x8BAE;&#x7684;&#x5B9E;&#x73B0;&#x3002; Java&#x5B89;&#x5168;API&#x6DB5;&#x76D6;&#x8303;&#x56F4;&#x5E7F;&#x6CDB;&#x7684;&#x9886;&#x57DF;&#xFF0C;&#x5305;&#x62EC;&#x5BC6;&#x7801;&#x5B66;&#xFF0C;&#x516C;&#x94A5;&#x57FA;&#x7840;&#x8BBE;&#x65BD;&#xFF0C;&#x5B89;&#x5168;&#x901A;&#x4FE1;&#xFF0C;&#x8BA4;&#x8BC1;&#x548C;&#x8BBF;&#x95EE;&#x63A7;&#x5236;&#x3002; Java&#x5B89;&#x5168;&#x6280;&#x672F;&#x4E3A;&#x5F00;&#x53D1;&#x4EBA;&#x5458;&#x63D0;&#x4F9B;&#x4E86;&#x4E00;&#x4E2A;&#x7528;&#x4E8E;&#x7F16;&#x5199;&#x5E94;&#x7528;&#x7A0B;&#x5E8F;&#x7684;&#x5168;&#x9762;&#x5B89;&#x5168;&#x6846;&#x67B6;&#xFF0C;&#x5E76;&#x4E3A;&#x7528;&#x6237;&#x6216;&#x7BA1;&#x7406;&#x5458;&#x63D0;&#x4F9B;&#x4E86;&#x4E00;&#x5957;&#x5B89;&#x5168;&#x7BA1;&#x7406;&#x5E94;&#x7528;&#x7A0B;&#x5E8F;&#x7684;&#x5DE5;&#x5177;&#x3002; Enhancements JDK 8 &#x5B89;&#x5168;&#x589E;&#x5F3A;&#x529F;&#x80FD; JDK 7 &#x5B89;&#x5168;&#x589E;&#x5F3A;&#x529F;&#x80FD; JDK 6 &#x5B89;&#x5168;&#x589E;&#x5F3A;&#x529F;&#x80FD; &#x9ED1;&#x540D;&#x5355;jar&#x5305;&#x7279;&#x6027; &#x7B7E;&#x540D;&#x65F6;&#x95F4;&#x6233;&#x652F;&#x6301; &#x7A0B;&#x5E8F;&#x5458;&#x6307;&#x5357; &#x901A;&#x7528;&#x90E8;&#x5206; Java &#x5B89;&#x5168;&#x6982;&#x89C8; &#x5B89;&#x5168;&#x67B6;&#x6784; Java&#x52A0;&#x5BC6;&#x4F53;&#x7CFB;&#x67B6;&#x6784;&#x53C2;&#x8003;&#x6307;&#x5357;&#xFF08;JCA&#xFF09;&#x53C2;&#x8003;&#x6307;&#x5357; &#x5982;&#x4F55;&#x5728;JCA&#x4E2D;&#x5B9E;&#x73B0;&#x4E00;&#x4E2A;&#x63D0;&#x4F9B;&#x8005; &#x6807;&#x51C6;&#x7B97;&#x6CD5;&#x540D;&#x79F0; Oracle &#x63D0;&#x4F9B;&#x8005; &#x653F;&#x7B56;&#x8BB8;&#x53EF; &#x9ED8;&#x8BA4;&#x7B56;&#x7565;&#x5B9E;&#x73B0;&#x548C;&#x7B56;&#x7565;&#x6587;&#x4EF6;&#x8BED;&#x6CD5; API for Privileged Blocks &#x914D;&#x7F6E;java &#x5BA2;&#x6237;&#x7AEF;&#x7684;&#x5B89;&#x5168;&#x7B49;&#x7EA7; &#x5B89;&#x5168;&#x6545;&#x969C;&#x6392;&#x9664; Java &#x8BA4;&#x8BC1;&#x548C;&#x6388;&#x6743;&#x670D;&#x52A1; (JAAS) JAAS &#x53C2;&#x8003;&#x6307;&#x5357; JAAS &#x6559;&#x7A0B; JAAS &#x767B;&#x5F55;&#x6A21;&#x5757;&#x5F00;&#x53D1;&#x4EBA;&#x5458;&#x6307;&#x5357; Java &#x901A;&#x7528;&#x5B89;&#x5168;&#x670D;&#x52A1; (Java GSS-API) Java GSS-API and JAAS Tutorials for Use with Kerberos Single Sign-on Using Kerberos in Java Java GSS Security Features Java GSS Advanced Security Programming The Kerberos 5 GSS-API Mechanism Java PKCS#11 &#x53C2;&#x8003;&#x6307;&#x5357; Java PKCS#11 Reference Guide Java &#x5B89;&#x5168;&#x5957;&#x63A5;&#x5B57;&#x6269;&#x5C55; (JSSE) JSSE &#x53C2;&#x8003;&#x6307;&#x5357; &#x516C;&#x94A5;&#x57FA;&#x7840;&#x8BBE;&#x65BD; (PKI) Java PKI &#x5F00;&#x53D1;&#x4EBA;&#x5458;&#x6307;&#x5357; X.509 &#x8BC1;&#x4E66;&#x548C;&#x8BC1;&#x4E66;&#x540A;&#x9500;&#x5217;&#x8868; &#x7B80;&#x5355;&#x8EAB;&#x4EFD;&#x9A8C;&#x8BC1;&#x548C;&#x5B89;&#x5168;&#x5C42; (SASL) The Java SASL API &#x5F00;&#x53D1;&#x548C;&#x90E8;&#x7F72;&#x6307;&#x5357; XML &#x7535;&#x5B50;&#x7B7E;&#x540D; The XML Digital Signature API Specification The XML Digital Signature API Reference and Tutorial API &#x89C4;&#x8303; &#x901A;&#x7528; java.security Package javax.crypto Package java.security.cert Package java.security.spec Package javax.crypto.spec Package java.security.interfaces Package javax.crypto.interfaces Package javax.rmi.ssl Package &#x8BA4;&#x8BC1; java.security.cert Package JAAS javax.security.auth Package javax.security.auth.callback Package javax.security.auth.kerberos Package javax.security.auth.login Package javax.security.auth.spi Package javax.security.auth.x500 Package com.sun.security.auth Package com.sun.security.auth.callback Package com.sun.security.auth.login Package com.sun.security.auth.module Package Java GSS-API org.ietf.jgss Package com.sun.security.jgss Package JSSE javax.net Package javax.net.ssl Package javax.security.cert Package (Denigrated, use java.security.cert instead) Java SASL javax.security.sasl Package SSL/TLS-based RMI Socket Factories javax.rmi.ssl Package XML Digital Signature javax.xml.crypto Package javax.xml.crypto.dom Package javax.xml.crypto.dsig Package javax.xml.crypto.dsig.dom Package javax.xml.crypto.dsig.keyinfo Package javax.xml.crypto.dsig.spec Package Smart Card I/O javax.smartcardio Package Tools &#x5B89;&#x5168;&#x5DE5;&#x5177;&#x7B80;&#x4ECB; keytool (Solaris, Linux or Mac OS X) (Windows) jarsigner (for Solaris, Linux or Mac OS X) (for Windows) policytool (for Solaris, Unix, or Mac OS X) (for Windows) kinit (for Windows) klist (for Windows) ktab (for Windows) &#x6559;&#x7A0B; Java &#x6559;&#x7A0B;&#x4E2D;&#x7684;Java SE &#x5B89;&#x5168;&#x7279;&#x6027; JAAS &#x6559;&#x7A0B; Java GSS-API and JAAS Tutorials for Use with Kerberos &#x653F;&#x7B56;&#x5DE5;&#x5177;&#x7528;&#x6237;&#x6307;&#x5357; More Information The Java SE Security Home Page","categories":[{"name":"java","slug":"java","permalink":"https://yyhan.github.io/categories/java/"}],"tags":[{"name":"security","slug":"security","permalink":"https://yyhan.github.io/tags/security/"},{"name":"jca","slug":"jca","permalink":"https://yyhan.github.io/tags/jca/"}]},{"title":"OpenSSL 生成证书","slug":"OpenSSL-生成证书","date":"2017-06-28T16:22:07.000Z","updated":"2017-06-28T17:01:46.024Z","comments":true,"path":"2017/06/29/OpenSSL-生成证书/","link":"","permalink":"https://yyhan.github.io/2017/06/29/OpenSSL-生成证书/","excerpt":"","text":"&#x751F;&#x6210;&#x6839;&#x8BC1;&#x4E66;&#x548C;&#x670D;&#x52A1;&#x5668;&#x8BC1;&#x4E66; 1&#x3001;&#x751F;&#x6210;&#x6839;&#x8BC1;&#x4E66;RSA&#x5BC6;&#x94A5;&#x5BF9; 1openssl genrsa -out ca.key 2048 2&#x3001;&#x751F;&#x6210;&#x81EA;&#x7B7E;&#x540D;&#x6839;&#x8BC1;&#x4E66; 1openssl req -new -x509 -days 365 -key a.key -out a.csr 3&#x3001;&#x8F6C;&#x6362;&#x8BC1;&#x4E66;&#x683C;&#x5F0F;&#xFF08;&#x975E;&#x5FC5;&#x987B;&#xFF09; 1openssl x509 -in ca.csr -out ca.crt 4&#x3001;&#x751F;&#x6210;&#x670D;&#x52A1;&#x5668;&#x8BC1;&#x4E66;RSA&#x5BC6;&#x94A5;&#x5BF9;&#xFF1A; 1openssl genrsa -out server.key 2048 5&#x3001;&#x751F;&#x6210;&#x670D;&#x52A1;&#x5668;&#x8BC1;&#x4E66;&#x7B7E;&#x540D;&#x8BF7;&#x6C42; 1openssl req -new -sha256 -key server.key -out server.csr 6&#x3001;&#x5BF9;&#x670D;&#x52A1;&#x5668;&#x8BC1;&#x4E66;&#x7B7E;&#x540D; 1openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 30 -sha256 -extfile v3.ext v3.ext &#x6307;&#x5B9A;&#x57DF;&#x540D;&#x7B49;&#x4FE1;&#x606F; 123456789authorityKeyIdentifier=keyid,issuerbasicConstraints=CA:FALSEkeyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEnciphermentsubjectAltName = @alt_names[alt_names]DNS.1 = it.jubaopay.comDNS.2 = b.jubaopay.comDNS.3 = oa.jubaopay.com &#x8C37;&#x6B4C;&#x6D4F;&#x89C8;&#x5668;&#x4F7F;&#x7528;SAN (Subject Alternative Name)&#x66FF;&#x4EE3;&#x4E86;CN&#x6765;&#x9A8C;&#x8BC1;&#x57DF;&#x540D;&#xFF0C;&#x6240;&#x4EE5;&#x5FC5;&#x987B;&#x8981;&#x8FD9;&#x6837;&#x641E; 7&#x3001;&#x8F6C;&#x6362;&#x8BC1;&#x4E66;&#x683C;&#x5F0F;&#xFF08;&#x975E;&#x5FC5;&#x987B;&#xFF09; 1openssl x509 -in nginxCert.pem -out nginx.crt &#x5E38;&#x7528;&#x547D;&#x4EE4; &#x8BC1;&#x4E66;&#x683C;&#x5F0F;&#x8F6C;&#x6362; &#x8F6C;&#x6362;&#x8BC1;&#x4E66;&#x683C;&#x5F0F;&#xFF08;pem -&gt; crt&#xFF09; 1openssl x509 -in server.pem -out server.crt &#x8F6C;&#x6362;&#x8BC1;&#x4E66;&#x683C;&#x5F0F;&#xFF08;pem -&gt; key&#xFF09; 1openssl rsa -in server.pem -out server.key &#x67E5;&#x770B;&#x8BC1;&#x4E66;&#x5185;&#x5BB9; &#x67E5;&#x770B;crt&#x6587;&#x4EF6;&#x5185;&#x5BB9;&#xFF1A; 1openssl x509 -text -in server.crt -noout &#x67E5;&#x770B;csr&#x6587;&#x4EF6;&#x5185;&#x5BB9;&#xFF1A; 1openssl req -text -in server.csr -noout","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://yyhan.github.io/categories/工具使用/"}],"tags":[{"name":"openssl","slug":"openssl","permalink":"https://yyhan.github.io/tags/openssl/"},{"name":"https","slug":"https","permalink":"https://yyhan.github.io/tags/https/"},{"name":"ca","slug":"ca","permalink":"https://yyhan.github.io/tags/ca/"},{"name":"证书","slug":"证书","permalink":"https://yyhan.github.io/tags/证书/"}]},{"title":"CryptoJS 使用示例","slug":"CryptoJS-使用示例","date":"2017-06-27T15:51:37.000Z","updated":"2017-06-27T16:17:57.211Z","comments":true,"path":"2017/06/27/CryptoJS-使用示例/","link":"","permalink":"https://yyhan.github.io/2017/06/27/CryptoJS-使用示例/","excerpt":"","text":"&#x5B57;&#x7B26;&#x4E32;&#x7F16;&#x89E3;&#x7801; &#x6240;&#x6709;&#x7684;&#x7F16;&#x89E3;&#x7801;&#x5668;&#xFF0C;&#x90FD;&#x6709;stringify(wordArray)&#x548C;parse(str)&#x4E24;&#x4E2A;&#x65B9;&#x6CD5;&#x3002;stringify&#x65B9;&#x6CD5;&#x7528;&#x4E8E;&#x5C06;WordArray&#x5BF9;&#x8C61;&#x8F6C;&#x6362;&#x4E3A;&#x76F8;&#x5E94;&#x7F16;&#x7801;&#x7684;&#x5B57;&#x7B26;&#x4E32;&#xFF0C;parse&#x65B9;&#x6CD5;&#x7528;&#x4E8E;&#x89E3;&#x7801;&#x76EE;&#x6807;&#x5B57;&#x7B26;&#x4E32;&#xFF0C;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;WordArray&#x5BF9;&#x8C61;&#x3002; Base64 &#x5C06;&#x4E00;&#x4E2A;&#x5B57;&#x7B26;&#x4E32;&#x8F6C;&#x6362;&#x4E3A;Base64&#x5B57;&#x7B26;&#x4E32;&#x65F6;&#xFF0C;&#x5FC5;&#x987B;&#x5148;&#x8F6C;&#x6362;&#x4E3A;WordArray&#x5BF9;&#x8C61;&#xFF0C;&#x518D;&#x8F6C;&#x6362;&#x4E3A;Base64&#x5B57;&#x7B26;&#x4E32;&#x3002; 123456789// Base64 &#x57FA;&#x672C;&#x4F7F;&#x7528;var plainTxt = &quot;hello base64&quot;; // &#x6D4B;&#x8BD5;&#x5B57;&#x7B26;&#x4E32;var plainTxtToWA = CryptoJS.enc.Utf8.parse(plainTxt); // &#x8F6C;&#x6362;&#x4E3A; WordArrayvar base64Str = CryptoJS.enc.Base64.stringify(base64TestStrToWordArray); // &#x8F6C;&#x6362;&#x4E3A;base64&#x5B57;&#x7B26;&#x4E32;console.log(plainTxt);console.log(plainTxtToWA);console.log(base64Str); &#x6458;&#x8981;&#x7B97;&#x6CD5; MD5 123456var plainTxt = &quot;hello world&quot;;var md5Res = CryptoJS.MD5(plainTxt); // MD5&#x7ED3;&#x679C;&#x662F;&#x4E00;&#x4E2A; CryptoJS.lib.WordArray &#x5BF9;&#x8C61;console.log(md5Res.toString()); // WordArray.toString() &#x9ED8;&#x8BA4;&#x8F6C;&#x6362;&#x4E3A;hex&#x5B57;&#x7B26;&#x4E32;console.log(md5Res.toString(CryptoJS.enc.Hex)); // md5 &#x7ED3;&#x679C;&#x8F6C;&#x4E3A;hex&#x5B57;&#x7B26;&#x4E32;console.log(md5Res.toString(CryptoJS.enc.Base64)); // md5 &#x7ED3;&#x679C;&#x8F6C;&#x4E3A;base64&#x5B57;&#x7B26;&#x4E32; &#x52A0;&#x89E3;&#x5BC6; AES 123456789var ciphertext = CryptoJS.AES.encrypt( &apos;plain text&apos;, // &#x9700;&#x8981;&#x52A0;&#x5BC6;&#x7684;&#x660E;&#x6587; &apos;secret key&apos;, // &#x52A0;&#x5BC6;&#x5BC6;&#x94A5; { mode: CBC, // AES&#x5DE5;&#x4F5C;&#x6A21;&#x5F0F;, &#x9ED8;&#x8BA4; CBC padding: Pkcs7, // &#x586B;&#x5145;&#x65B9;&#x5F0F;, &#x9ED8;&#x8BA4; Pkcs7 iv: null // AES &#x5411;&#x91CF; });","categories":[{"name":"javascript","slug":"javascript","permalink":"https://yyhan.github.io/categories/javascript/"}],"tags":[{"name":"CryptoJS","slug":"CryptoJS","permalink":"https://yyhan.github.io/tags/CryptoJS/"},{"name":"AES","slug":"AES","permalink":"https://yyhan.github.io/tags/AES/"},{"name":"BASE64","slug":"BASE64","permalink":"https://yyhan.github.io/tags/BASE64/"},{"name":"MD5","slug":"MD5","permalink":"https://yyhan.github.io/tags/MD5/"},{"name":"SHA","slug":"SHA","permalink":"https://yyhan.github.io/tags/SHA/"}]},{"title":"CryptoJS 使用指南","slug":"CryptoJS-使用指南","date":"2017-06-27T14:12:56.000Z","updated":"2017-06-27T16:40:32.020Z","comments":true,"path":"2017/06/27/CryptoJS-使用指南/","link":"","permalink":"https://yyhan.github.io/2017/06/27/CryptoJS-使用指南/","excerpt":"","text":"CryptoJS &#x662F;&#x4E00;&#x4E2A;&#x5F00;&#x6E90;&#x7684;JavaScript&#x6807;&#x51C6;&#x5BC6;&#x7801;&#x5B66;&#x5E93;&#x3002; Node.js(install) &#x4F9D;&#x8D56;&#xFF1A; Node.js npm &#x5B89;&#x88C5;&#x547D;&#x4EE4;&#xFF1A; 1npm install crypto-js &#x4F7F;&#x7528;&#x793A;&#x4F8B; ES6 &#x4E2D;&#x4F7F;&#x7528; 1234567import sha256 from &apos;crypto-js/sha256&apos;;import hmacSHA512 from &apos;crypto-js/hmac-sha512&apos;;import Base64 from &apos;crypto-js/enc-base64&apos;;const message, nonce, path, privateKey; // ...const hashDigest = sha256(nonce + message);const hmacDigest = Base64.stringify(hmacSHA512(path + hashDigest, privateKey)); &#x5728;&#x6A21;&#x5757;&#x7CFB;&#x7EDF;&#x4E2D;&#x4F7F;&#x7528; 1234var AES = require(&quot;crypto-js/aes&quot;);var SHA256 = require(&quot;crypto-js/sha256&quot;);...console.log(SHA256(&quot;Message&quot;)); &#x5BFC;&#x5165;&#x6240;&#x6709;&#x7684;&#x6A21;&#x5757; 12var CryptoJS = require(&quot;crypto-js&quot;);console.log(CryptoJS.HmacSHA1(&quot;Message&quot;, &quot;Key&quot;)); &#x5728;&#x6D4F;&#x89C8;&#x5668;&#x4E2D;&#x4F7F;&#x7528; 12345&lt;script type=&quot;text/javascript&quot; src=&quot;path-to/bower_components/crypto-js/crypto-js.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var encrypted = CryptoJS.AES(...); var encrypted = CryptoJS.SHA256(...);&lt;/script&gt; API &#x6587;&#x672C;&#x52A0;&#x89E3;&#x5BC6; 12345678910var CryptoJS = require(&quot;crypto-js&quot;);// Encryptvar ciphertext = CryptoJS.AES.encrypt(&apos;my message&apos;, &apos;secret key 123&apos;);// Decryptvar bytes = CryptoJS.AES.decrypt(ciphertext.toString(), &apos;secret key 123&apos;);var plaintext = bytes.toString(CryptoJS.enc.Utf8);console.log(plaintext); &#x5BF9;&#x8C61;&#x7C7B;&#x578B;&#x52A0;&#x89E3;&#x5BC6; 123456789101112var CryptoJS = require(&quot;crypto-js&quot;);var data = [{id: 1}, {id: 2}]// Encryptvar ciphertext = CryptoJS.AES.encrypt(JSON.stringify(data), &apos;secret key 123&apos;);// Decryptvar bytes = CryptoJS.AES.decrypt(ciphertext.toString(), &apos;secret key 123&apos;);var decryptedData = JSON.parse(bytes.toString(CryptoJS.enc.Utf8));console.log(decryptedData); &#x5E93;&#x547D;&#x540D;&#x7A7A;&#x95F4; Base &#x539F;&#x578B;&#x7EE7;&#x627F;&#x7684;&#x57FA;&#x7840;&#x5BF9;&#x8C61;&#x3002;CryptoJS&#x5E93;&#x4E2D;&#xFF0C;&#x81EA;&#x5DF1;&#x5B9E;&#x73B0;&#x4E86;&#x4E00;&#x5957;&#x7EE7;&#x627F;&#x673A;&#x5236;&#x3002; 1CryptoJS.lib.Base WordArray &#x4E00;&#x4E2A;32&#x4F4D;&#x5B57;&#x7684;&#x6570;&#x7EC4;&#x3002;&#x7EE7;&#x627F;Base&#x3002; 1CryptoJS.lib.WordArray &#x8F6C;&#x6362;&#x4E3A;&#x5B57;&#x7B26;&#x4E32;&#xFF1A; 123var string = wordArray + &apos;&apos;;var string = wordArray.toString();var string = wordArray.toString(CryptoJS.enc.Utf8); toString()&#x65B9;&#x6CD5;&#x6709;&#x4E00;&#x4E2A;encoder&#x53C2;&#x6570;&#xFF0C;&#x9ED8;&#x8BA4;&#x4E3A;CryptoJS.enc.Hex&#x3002; BufferedBlockAlgorithm &#x7F13;&#x51B2;&#x5757;&#x7B97;&#x6CD5;&#x62BD;&#x8C61;&#x6A21;&#x677F;&#x3002;&#x7EE7;&#x627F;Base&#x3002; 1CryptoJS.lib.BufferedBlockAlgorithm Hasher hash&#x7B97;&#x6CD5;&#x62BD;&#x8C61;&#x6A21;&#x677F;&#x3002;&#x7EE7;&#x627F;BufferedBlockAlgorithm&#x3002; 1CryptoJS.lib.Hasher &#x7F16;&#x7801;&#x5668; Hex &#x63D0;&#x4F9B;16&#x8FDB;&#x5236;&#x7F16;&#x89E3;&#x7801;&#x652F;&#x6301;&#x3002; 1CryptoJS.enc.Hex Latin1 ISO 8859-1&#xFF0C;&#x6B63;&#x5F0F;&#x7F16;&#x53F7;&#x4E3A;ISO/IEC 8859-1:1998&#xFF0C;&#x53C8;&#x79F0;Latin-1&#x6216;&#x201C;&#x897F;&#x6B27;&#x8BED;&#x8A00;&#x201D;&#xFF0C;&#x662F;&#x56FD;&#x9645;&#x6807;&#x51C6;&#x5316;&#x7EC4;&#x7EC7;&#x5185;ISO/IEC 8859&#x7684;&#x7B2C;&#x4E00;&#x4E2A;8&#x4F4D;&#x5B57;&#x7B26;&#x96C6;&#x3002;&#x5B83;&#x4EE5;ASCII&#x4E3A;&#x57FA;&#x7840;&#xFF0C;&#x5728;&#x7A7A;&#x7F6E;&#x7684;0xA0-0xFF&#x7684;&#x8303;&#x56F4;&#x5185;&#xFF0C;&#x52A0;&#x5165;96&#x4E2A;&#x5B57;&#x6BCD;&#x53CA;&#x7B26;&#x53F7;&#xFF0C;&#x85C9;&#x4EE5;&#x4F9B;&#x4F7F;&#x7528;&#x9644;&#x52A0;&#x7B26;&#x53F7;&#x7684;&#x62C9;&#x4E01;&#x5B57;&#x6BCD;&#x8BED;&#x8A00;&#x4F7F;&#x7528;&#x3002;&#x8BE6;&#x7EC6;&#x4ECB;&#x7ECD;&#x3002; 1CryptoJS.enc.Hex Utf8 &#x63D0;&#x4F9B;UTF-8&#x7F16;&#x89E3;&#x7801;&#x652F;&#x6301;&#x3002; 1CryptoJS.enc.Utf8 &#x6A21;&#x5757;&#x5217;&#x8868; &#x6838;&#x5FC3;&#x6A21;&#x5757; crypto-js/core crypto-js/x64-core crypto-js/lib-typedarrays &#x54C8;&#x5E0C;&#x7B97;&#x6CD5;&#x6A21;&#x5757; crypto-js/md5 crypto-js/sha1 crypto-js/sha256 crypto-js/sha224 crypto-js/sha512 crypto-js/sha384 crypto-js/sha3 crypto-js/ripemd160 HMAC&#x7B97;&#x6CD5;&#x6A21;&#x5757; crypto-js/hmac-md5 crypto-js/hmac-sha1 crypto-js/hmac-sha256 crypto-js/hmac-sha224 crypto-js/hmac-sha512 crypto-js/hmac-sha384 crypto-js/hmac-sha3 crypto-js/hmac-ripemd160 PBKDF2&#x7B97;&#x6CD5; crypto-js/pbkdf2 &#x52A0;&#x89E3;&#x5BC6;&#x6A21;&#x5757; crypto-js/aes crypto-js/tripledes crypto-js/rc4 crypto-js/rabbit crypto-js/rabbit-legacy crypto-js/evpkdf &#x683C;&#x5F0F;&#x5316;&#x6A21;&#x5757; crypto-js/format-openssl crypto-js/format-hex &#x7F16;&#x89E3;&#x7801;&#x6A21;&#x5757; crypto-js/enc-latin1 crypto-js/enc-utf8 crypto-js/enc-hex crypto-js/enc-utf16 crypto-js/enc-base64 &#x5DE5;&#x4F5C;&#x6A21;&#x5F0F;&#x6A21;&#x5757; crypto-js/mode-cfb crypto-js/mode-ctr crypto-js/mode-ctr-gladman crypto-js/mode-ofb crypto-js/mode-ecb &#x586B;&#x5145;&#x65B9;&#x5F0F;&#x6A21;&#x5757; crypto-js/pad-pkcs7 crypto-js/pad-ansix923 crypto-js/pad-iso10126 crypto-js/pad-iso97971 crypto-js/pad-zeropadding crypto-js/pad-nopadding","categories":[{"name":"javascript","slug":"javascript","permalink":"https://yyhan.github.io/categories/javascript/"}],"tags":[{"name":"CryptoJS","slug":"CryptoJS","permalink":"https://yyhan.github.io/tags/CryptoJS/"},{"name":"AES","slug":"AES","permalink":"https://yyhan.github.io/tags/AES/"},{"name":"BASE64","slug":"BASE64","permalink":"https://yyhan.github.io/tags/BASE64/"},{"name":"MD5","slug":"MD5","permalink":"https://yyhan.github.io/tags/MD5/"},{"name":"SHA","slug":"SHA","permalink":"https://yyhan.github.io/tags/SHA/"}]},{"title":"java AES使用","slug":"java-AES使用","date":"2017-06-26T12:59:59.000Z","updated":"2017-06-26T15:02:46.304Z","comments":true,"path":"2017/06/26/java-AES使用/","link":"","permalink":"https://yyhan.github.io/2017/06/26/java-AES使用/","excerpt":"","text":"java&#x63D0;&#x4F9B;AES&#x7B97;&#x6CD5;&#x652F;&#x6301;&#x3002;&#x652F;&#x6301;&#x7684;&#x5BC6;&#x94A5;&#x957F;&#x5EA6;&#x4E3A;&#xFF1A;128, 192, &#x6216;256&#x4F4D;&#x3002;&#x7531;&#x4E8E;&#x7F8E;&#x56FD;&#x8FDB;&#x51FA;&#x53E3;&#x9650;&#x5236;&#xFF0C;&#x9ED8;&#x8BA4;&#x7684;jre&#x53EA;&#x652F;&#x6301;128&#x4F4D;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;16&#x4E2A;&#x5B57;&#x8282;&#x7684;&#x5BC6;&#x94A5;&#x3002; &#x652F;&#x6301;&#x7684;&#x5DE5;&#x4F5C;&#x6A21;&#x5F0F;&#xFF1A; NONE CBC CCM CFB, CFBx CTR CTS ECB GCM OFB, OFBx PCBC &#x652F;&#x6301;&#x7684;&#x586B;&#x5145;&#x65B9;&#x5F0F;&#xFF1A; NoPadding ISO10126Padding OAEPPadding PKCS1Padding PKCS5Padding SSL3Padding &#x5F53;&#x4F7F;&#x7528;Cipher.getInstance(&quot;AES&quot;)&#x65F6;&#xFF0C;&#x9ED8;&#x8BA4;&#x83B7;&#x53D6;&#x7684;&#x662F;AES/ECB/PKCS5Padding&#x5BF9;&#x5E94;&#x7684;&#x5B9E;&#x4F8B;&#x3002;&#x5B9E;&#x9645;&#x4F7F;&#x7528;&#x4E2D;&#x8FD9;&#x91CC;&#x4E00;&#x5B9A;&#x8981;&#x6CE8;&#x610F;&#x4E00;&#x4E0B;&#xFF0C;&#x5EFA;&#x8BAE;&#x5B9E;&#x9645;&#x5E94;&#x7528;&#x4E2D;&#x4E00;&#x5B9A;&#x8981;&#x663E;&#x793A;&#x6307;&#x5B9A;&#x5DE5;&#x4F5C;&#x6A21;&#x5F0F;&#x548C;&#x586B;&#x5145;&#x65B9;&#x5F0F;&#x3002;&#x82E5;&#x4E0D;&#x663E;&#x793A;&#x6307;&#x5B9A;&#xFF0C;&#x5728;&#x8DE8;&#x8BED;&#x8A00;&#x3001;&#x8DE8;&#x7C7B;&#x5E93;&#x6216;&#x8DE8;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x65F6;&#xFF0C;&#x5BB9;&#x6613;&#x8E29;&#x5751;&#x3002; java aes&#x793A;&#x4F8B; java &#x7248;&#x672C; &#xFF1A; 1.8&#x3002; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.cloudin.commons.security;import javax.crypto.BadPaddingException;import javax.crypto.Cipher;import javax.crypto.IllegalBlockSizeException;import javax.crypto.NoSuchPaddingException;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;import java.io.UnsupportedEncodingException;import java.security.InvalidAlgorithmParameterException;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;import java.util.Base64;/** * Created by YFHan on 2017/4/4 0004. */public class AESHelper { /** * &#x7B97;&#x6CD5;&#x540D;&#x79F0; */ public static final String ALGORITHM_NAME =&quot;AES&quot;; /** * java aes &#x7B97;&#x6CD5;&#x9ED8;&#x8BA4;&#x5DE5;&#x4F5C;&#x6A21;&#x5F0F; */ public static final String DEFAULT_MODE = &quot;ECB&quot;; /** * java aes &#x7B97;&#x6CD5;&#x9ED8;&#x8BA4;&#x586B;&#x5145;&#x65B9;&#x5F0F; */ public static final String DEFAULT_PADDING = &quot;PKCS5Padding&quot;; /** * java aes &#x7B97;&#x6CD5;&#x9ED8;&#x8BA4;&#x7684;&#x5BC6;&#x7801;&#x5B9E;&#x4F8B; */ public static final String DEFAULT_CHIPHER_INSTANCE = &quot;AES/ECB/PKCS5Padding&quot;; /** * &#x5BF9;&#x6307;&#x5B9A;&#x5185;&#x5BB9;&#x4F7F;&#x7528;&#x6307;&#x5B9A;&#x79D8;&#x94A5;&#x8FDB;&#x884C;AES(128)&#x52A0;&#x5BC6;&#xFF0C;&#x5E76;&#x8FD4;&#x56DE;&#x52A0;&#x5BC6;&#x540E;&#x7684;&#x5B57;&#x8282;&#x6570;&#x7EC4; * * @param content &#x5F85;&#x52A0;&#x5BC6;&#x7684;&#x5185;&#x5BB9; * @param password &#x52A0;&#x5BC6;&#x79D8;&#x94A5; * @return */ public static byte[] encrypt(byte[] content, byte[] password) { Cipher cp = null; try { SecretKeySpec skeySpec = new SecretKeySpec(password, ALGORITHM_NAME); cp = Cipher.getInstance(DEFAULT_CHIPHER_INSTANCE); // &#x7B97;&#x6CD5;/&#x6A21;&#x5F0F;/&#x586B;&#x5145; cp.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(new byte[16])); return cp.doFinal(content); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } catch (NoSuchPaddingException e) { e.printStackTrace(); } catch (InvalidKeyException e) { e.printStackTrace(); } catch (BadPaddingException e) { e.printStackTrace(); } catch (IllegalBlockSizeException e) { e.printStackTrace(); } catch (InvalidAlgorithmParameterException e) { e.printStackTrace(); } return null; } /** * &#x5BF9;&#x6307;&#x5B9A;&#x5185;&#x5BB9;&#x4F7F;&#x7528;&#x6307;&#x5B9A;&#x79D8;&#x94A5;&#x8FDB;&#x884C;AES(128)&#x89E3;&#x5BC6;&#xFF0C;&#x5E76;&#x8FD4;&#x56DE;&#x89E3;&#x5BC6;&#x540E;&#x7684;&#x5B57;&#x8282;&#x6570;&#x7EC4; * * @param content &#x5F85;&#x89E3;&#x5BC6;&#x7684;&#x5185;&#x5BB9; * @param password &#x89E3;&#x5BC6;&#x79D8;&#x94A5; * @return */ public static byte[] decrypt(byte[] content, byte[] password) { try { SecretKeySpec skeySpec = new SecretKeySpec(password, ALGORITHM_NAME); Cipher cp = Cipher.getInstance(DEFAULT_CHIPHER_INSTANCE); // &#x7B97;&#x6CD5;/&#x6A21;&#x5F0F;/&#x586B;&#x5145; cp.init(Cipher.DECRYPT_MODE, skeySpec, new IvParameterSpec(new byte[16])); return cp.doFinal(content); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } catch (NoSuchPaddingException e) { e.printStackTrace(); } catch (InvalidKeyException e) { e.printStackTrace(); } catch (BadPaddingException e) { e.printStackTrace(); } catch (IllegalBlockSizeException e) { e.printStackTrace(); } catch (InvalidAlgorithmParameterException e) { e.printStackTrace(); } return null; }} &#x5E38;&#x89C1;&#x95EE;&#x9898; java aes&#x5BC6;&#x94A5;&#x957F;&#x5EA6;&#x9650;&#x5236; &#x7531;&#x4E8E;&#x7F8E;&#x56FD;&#x8FDB;&#x51FA;&#x53E3;&#x9650;&#x5236;&#xFF0C;jre&#x81EA;&#x5E26;&#x7684;aes&#x7B97;&#x6CD5;&#x9650;&#x5236;&#x4E86;&#x5BC6;&#x94A5;&#x957F;&#x5EA6;&#x4E3A;16&#x5B57;&#x8282;&#x3002;&#x8FD9;&#x65F6;&#x9700;&#x8981;&#x4F7F;&#x7528;JCE&#x65E0;&#x9650;&#x5236;&#x6743;&#x9650;&#x7B56;&#x7565;&#x7684;jar&#x5305;&#x8986;&#x76D6;jvm&#x81EA;&#x5E26;&#x7684;jar&#x5305;&#x3002; &#x4E0B;&#x8F7D;&#x5730;&#x5740;: http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html java &#x548C; js&#x4E92;&#x76F8;&#x52A0;&#x89E3;&#x5BC6;&#x95EE;&#x9898; java&#x548C;js&#x4E92;&#x76F8;&#x52A0;&#x89E3;&#x5BC6;&#x65F6;&#xFF0C;&#x5982;&#x679C;&#x4E0D;&#x6307;&#x5B9A;&#x5DE5;&#x4F5C;&#x6A21;&#x5F0F;&#x548C;&#x586B;&#x5145;&#x65B9;&#x5F0F;&#xFF0C;&#x4F1A;&#x5931;&#x8D25;&#x3002;&#x5728;js&#x4E2D;&#xFF0C;&#x4E00;&#x822C;&#x4F7F;&#x7528;crypto-js&#x5E93;&#x6765;&#x52A0;&#x89E3;&#x5BC6;&#x3002;&#x4F46;&#x662F;&#x8BE5;&#x7C7B;&#x5E93;&#x9ED8;&#x8BA4;&#x7684;&#x5DE5;&#x4F5C;&#x6A21;&#x5F0F;&#x662F;CBC&#xFF0C;&#x9ED8;&#x8BA4;&#x586B;&#x5145;&#x65B9;&#x5F0F;PKCS7&#xFF0C;&#x4E0E;java&#x7684;&#x9ED8;&#x8BA4;&#x65B9;&#x5F0F;&#x4E0D;&#x4E00;&#x81F4;&#x3002; &#x5F88;&#x591A;&#x540C;&#x5B66;&#x5728;&#x4F7F;&#x7528;AES&#x7B97;&#x6CD5;&#x65F6;&#xFF0C;&#x4E0D;&#x663E;&#x793A;&#x6307;&#x5B9A;&#x5DE5;&#x4F5C;&#x6A21;&#x5F0F;&#x548C;&#x586B;&#x5145;&#x65B9;&#x5F0F;&#xFF0C;&#x5728;&#x8FD9;&#x91CC;&#x5C31;&#x4F1A;&#x5C61;&#x5C61;&#x51FA;&#x9519;&#x3002;&#x95EE;&#x9898;&#x5C31;&#x51FA;&#x5728;java&#x548C;js&#xFF08;crypto-js&#xFF09;&#x9ED8;&#x8BA4;&#x7684;&#x5DE5;&#x4F5C;&#x6A21;&#x5F0F;&#x548C;&#x586B;&#x5145;&#x65B9;&#x5F0F;&#x4E0D;&#x4E00;&#x81F4;&#x3002;&#x8FD9;&#x91CC;&#x53EA;&#x8981;&#x5C06;&#x4E24;&#x8005;&#x7684;&#x5DE5;&#x4F5C;&#x6A21;&#x5F0F;&#x548C;&#x586B;&#x5145;&#x6307;&#x5B9A;&#x4E00;&#x6837;&#x5373;&#x53EF;&#x3002; &#x63A8;&#x8350;&#x4E00;&#x79CD;&#x65B9;&#x5F0F;&#xFF1A; js&#x91C7;&#x7528;AES/CBC/ZeroPadding&#x65B9;&#x5F0F;&#x52A0;&#x5BC6;&#x3002;&#x7531;&#x4E8E;java&#x6CA1;&#x6709;&#x63D0;&#x4F9B;ZeroPadding&#x586B;&#x5145;&#x65B9;&#x5F0F;&#xFF0C;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;AES/CBC/NoPadding&#x65B9;&#x5F0F;&#x89E3;&#x5BC6;&#xFF0C;&#x89E3;&#x5BC6;&#x540E;&#x4ECE;&#x540E;&#x5F80;&#x524D;&#x4F9D;&#x6B21;&#x5254;&#x9664;0x00&#x7684;&#x5B57;&#x8282;&#xFF0C;&#x9047;&#x5230;&#x975E;0x00&#x7684;&#x5B57;&#x8282;&#x65F6;&#x505C;&#x6B62;&#x3002;&#x5269;&#x4E0B;&#x7684;&#x5B57;&#x8282;&#x5C31;&#x662F;&#x89E3;&#x5BC6;&#x540E;&#x7684;&#x7ED3;&#x679C;&#x3002;&#x4E0D;&#x8FC7;&#xFF0C;&#x8FD9;&#x79CD;&#x65B9;&#x5F0F;&#x9700;&#x8981;&#x6CE8;&#x610F;&#xFF0C;&#x539F;&#x59CB;&#x6587;&#x672C;&#x8F6C;byte&#x6570;&#x7EC4;&#x540E;&#xFF0C;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x5B57;&#x8282;&#x4E0D;&#x80FD;&#x662F;0x00&#x3002;&#x5982;&#x679C;&#x662F;java&#x52A0;&#x5BC6;&#xFF0C;js&#x89E3;&#x5BC6;&#xFF0C;&#x5C06;&#x8FC7;&#x7A0B;&#x53CD;&#x8FC7;&#x6765;&#x5373;&#x53EF;&#x3002; &#x53C2;&#x8003; java&#x5BC6;&#x7801;&#x5B66;&#x4F53;&#x7CFB;&#x6807;&#x51C6;&#x7B97;&#x6CD5;&#x540D;&#x79F0;-jdk8 java &#x5BC6;&#x7801;&#x5B66;&#x4F53;&#x7CFB;&#x6307;&#x5357; java &#x5B89;&#x5168;&#x76F8;&#x5173;&#x6307;&#x5357;&#x7D22;&#x5F15; Android&#x5E94;&#x7528;&#x5B89;&#x5168;&#x5F00;&#x53D1;&#x4E4B;&#x6D45;&#x8C08;&#x52A0;&#x5BC6;&#x7B97;&#x6CD5;&#x7684;&#x5751;","categories":[{"name":"java","slug":"java","permalink":"https://yyhan.github.io/categories/java/"}],"tags":[{"name":"AES","slug":"AES","permalink":"https://yyhan.github.io/tags/AES/"},{"name":"java","slug":"java","permalink":"https://yyhan.github.io/tags/java/"}]},{"title":"hessian 2.0 序列化协议","slug":"hessian-2-0-序列化协议","date":"2017-06-18T03:05:53.000Z","updated":"2017-06-26T16:42:05.615Z","comments":true,"path":"2017/06/18/hessian-2-0-序列化协议/","link":"","permalink":"https://yyhan.github.io/2017/06/18/hessian-2-0-序列化协议/","excerpt":"","text":"Hessian 2.0 &#x5E8F;&#x5217;&#x5316;&#x534F;&#x8BAE;&#x7FFB;&#x8BD1;&#xFF0C;&#x539F;&#x6587;&#x94FE;&#x63A5;http://hessian.caucho.com/doc/hessian-serialization.html &#x4ECB;&#x7ECD; Hessian&#x662F;&#x4E00;&#x79CD;&#x52A8;&#x6001;&#x7C7B;&#x578B;&#x7684;&#x3001;&#x91C7;&#x7528;&#x4E8C;&#x8FDB;&#x5236;&#x5E8F;&#x5217;&#x5316;&#x7684;&#xFF0C;&#x5E76;&#x4E14;&#x88AB;&#x8BBE;&#x8BA1;&#x4E3A;&#x9762;&#x5411;&#x5BF9;&#x8C61;&#x4F20;&#x8F93;&#x7684;Web&#x670D;&#x52A1;&#x534F;&#x8BAE;&#x3002; &#x8BBE;&#x8BA1;&#x76EE;&#x6807; Hessian&#x662F;&#x52A8;&#x6001;&#x7C7B;&#x578B;&#x7684;&#xFF0C;&#x7D27;&#x51D1;&#x7684;&#xFF0C;&#x53EF;&#x8DE8;&#x8BED;&#x8A00;&#x79FB;&#x690D;&#x7684;&#x3002; Hessian&#x534F;&#x8BAE;&#x6709;&#x4EE5;&#x4E0B;&#x51E0;&#x4E2A;&#x8BBE;&#x8BA1;&#x76EE;&#x6807;: It must self-describe the serialized types, i.e. not require external schema or interface definitions. It must be language-independent, including supporting scripting languages. It must be readable or writable in a single pass. It must be as compact as possible. It must be simple so it can be effectively tested and implemented. It must be as fast as possible. It must support Unicode strings. It must support 8-bit binary data without escaping or using attachments. It must support encryption, compression, signature, and transaction context envelopes. Hessian &#x8BED;&#x6CD5; &#x5E8F;&#x5217;&#x5316;&#x8BED;&#x6CD5; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394 # starting productiontop ::= value # 8-bit binary data split into 64k chunksbinary ::= x41 b1 b0 &lt;binary-data&gt; binary # non-final chunk ::= &apos;B&apos; b1 b0 &lt;binary-data&gt; # final chunk ::= [x20-x2f] &lt;binary-data&gt; # binary data of # length 0-15 ::= [x34-x37] &lt;binary-data&gt; # binary data of # length 0-1023 # boolean true/falseboolean ::= &apos;T&apos; ::= &apos;F&apos; # definition for an object (compact map)class-def ::= &apos;C&apos; string int string* # time in UTC encoded as 64-bit long milliseconds since # epochdate ::= x4a b7 b6 b5 b4 b3 b2 b1 b0 ::= x4b b3 b2 b1 b0 # minutes since epoch # 64-bit IEEE doubledouble ::= &apos;D&apos; b7 b6 b5 b4 b3 b2 b1 b0 ::= x5b # 0.0 ::= x5c # 1.0 ::= x5d b0 # byte cast to double # (-128.0 to 127.0) ::= x5e b1 b0 # short cast to double ::= x5f b3 b2 b1 b0 # 32-bit float cast to double # 32-bit signed integerint ::= &apos;I&apos; b3 b2 b1 b0 ::= [x80-xbf] # -x10 to x3f ::= [xc0-xcf] b0 # -x800 to x7ff ::= [xd0-xd7] b1 b0 # -x40000 to x3ffff # list/vectorlist ::= x55 type value* &apos;Z&apos; # variable-length list ::= &apos;V&apos; type int value* # fixed-length list ::= x57 value* &apos;Z&apos; # variable-length untyped list ::= x58 int value* # fixed-length untyped list ::= [x70-77] type value* # fixed-length typed list ::= [x78-7f] value* # fixed-length untyped list # 64-bit signed long integerlong ::= &apos;L&apos; b7 b6 b5 b4 b3 b2 b1 b0 ::= [xd8-xef] # -x08 to x0f ::= [xf0-xff] b0 # -x800 to x7ff ::= [x38-x3f] b1 b0 # -x40000 to x3ffff ::= x59 b3 b2 b1 b0 # 32-bit integer cast to long # map/objectmap ::= &apos;M&apos; type (value value)* &apos;Z&apos; # key, value map pairs ::= &apos;H&apos; (value value)* &apos;Z&apos; # untyped key, value # null valuenull ::= &apos;N&apos; # Object instanceobject ::= &apos;O&apos; int value* ::= [x60-x6f] value* # value reference (e.g. circular trees and graphs)ref ::= x51 int # reference to nth map/list/object # UTF-8 encoded character string split into 64k chunksstring ::= x52 b1 b0 &lt;utf8-data&gt; string # non-final chunk ::= &apos;S&apos; b1 b0 &lt;utf8-data&gt; # string of length # 0-65535 ::= [x00-x1f] &lt;utf8-data&gt; # string of length # 0-31 ::= [x30-x34] &lt;utf8-data&gt; # string of length # 0-1023 # map/list types for OO languagestype ::= string # type name ::= int # type reference # main productionvalue ::= null ::= binary ::= boolean ::= class-def value ::= date ::= double ::= int ::= list ::= long ::= map ::= object ::= ref ::= string &#x5E8F;&#x5217;&#x5316; Hessian&#x7684;&#x5BF9;&#x8C61;&#x5E8F;&#x5217;&#x5316;&#x6709;8&#x4E2A;&#x539F;&#x59CB;&#x7C7B;&#x578B;: raw binary data boolean 64-bit millisecond date 64-bit double 32-bit int 64-bit long null UTF8-encoded string &#x5B83;&#x6709;3&#x4E2A;&#x9012;&#x5F52;&#x7C7B;&#x578B;: list for lists and arrays map for maps and dictionaries object for objects &#x6700;&#x540E;&#xFF0C;&#x5B83;&#x6709;&#x4E00;&#x4E2A;&#x7279;&#x6B8A;&#x7684;&#x6784;&#x9020;: ref for shared and circular object references. Hessian 2.0 &#x6709;&#x4E09;&#x4E2A;&#x5185;&#x7F6E;&#x5F15;&#x7528;&#x7C7B;&#x578B;&#x6620;&#x5C04;: An object/list reference map. An class definition reference map. A type (class name) reference map. &#x4E8C;&#x8FDB;&#x5236;&#x6570;&#x636E; &#x4E8C;&#x8FDB;&#x5236;&#x6570;&#x636E;&#x8BED;&#x6CD5; 123binary ::= b b1 b0 &lt;binary-data&gt; binary ::= B b1 b0 &lt;binary-data&gt; ::= [x20-x2f] &lt;binary-data&gt; &#x4E8C;&#x8FDB;&#x5236;&#x6570;&#x636E;&#x4F7F;&#x7528;&#x5757;&#x7F16;&#x7801;&#x3002;&#x516B;&#x8FDB;&#x5236; 0x42(&apos;B&apos;)&#x7F16;&#x7801;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x5757;&#xFF0C;0x62(&apos;b&apos;)&#x8868;&#x793A;&#x9664;&#x4E86;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x5757;&#x4EE5;&#x5916;&#x7684;&#x5757;&#x3002;&#x6BCF;&#x4E2A;&#x5757;&#x90FD;&#x6709;&#x4E00;&#x4E2A;16&#x4F4D;&#x7684;&#x957F;&#x5EA6;&#x503C;&#x3002;&#x957F;&#x5EA6;&#x503C;&#x516C;&#x5F0F;&#xFF1A; len = 256 * b1 + b0 &#x538B;&#x7F29;&#x77ED;&#x4E8C;&#x8FDB;&#x5236; &#x957F;&#x5EA6;&#x5C0F;&#x4E8E;15&#x7684;&#x4E8C;&#x8FDB;&#x5236;&#x6570;&#x636E;&#x91C7;&#x7528;&#x4E00;&#x4E2A;&#x516B;&#x8FDB;&#x5236;&#x6570;&#x636E;&#x8868;&#x793A;&#x957F;&#x5EA6;&#xFF0C;&#x8BE5;&#x516B;&#x8FDB;&#x5236;&#x6570;&#x636E;&#x53D6;&#x503C;&#x8303;&#x56F4;&#xFF1A;[x20-x2f]&#xFF0C;&#x957F;&#x5EA6;&#x503C;&#x516C;&#x5F0F;&#xFF1A; len = code - 0x20 &#x4E8C;&#x8FDB;&#x5236;&#x793A;&#x4F8B; 1234567x20 # 0&#x957F;&#x5EA6;&#x4E8C;&#x8FDB;&#x5236;&#x6570;&#x636E;x23 x01 x02 x03 # 3&#x4E2A;&#x516B;&#x5B57;&#x8282;&#x6570;&#x636E;B x10 x00 .... # 4k &#x7ED3;&#x5C3E;&#x6570;&#x636E;&#x5757;b x04 x00 .... # 1k &#x975E;&#x7ED3;&#x5C3E;&#x6570;&#x636E;&#x5757; boolean Boolean&#x8BED;&#x6CD5; 12boolean ::= T ::= F &#x5B57;&#x8282; &apos;F&apos; &#x8868;&#x793A;false&#xFF0C;&#x5B57;&#x8282; &apos;T&apos; &#x8868;&#x793A;true Boolean &#x793A;&#x4F8B; 12T # trueF # false date Date &#x8BED;&#x6CD5; 12date ::= x4a b7 b6 b5 b4 b3 b2 b1 b0 ::= x4b b4 b3 b2 b1 b0 &#x65E5;&#x671F;&#x7C7B;&#x578B;&#x4F7F;&#x7528;&#x4E00;&#x4E2A;64&#x4F4D;&#x7684;long&#x6570;&#x503C;&#x8868;&#x793A;&#x4ECE;1970-01-01 00:00:00&#x4EE5;&#x6765;&#x7ECF;&#x8FC7;&#x7684;&#x6BEB;&#x79D2;&#x6570;&#x3002; &#x538B;&#x7F29;&#xFF1A;&#x4F7F;&#x7528;&#x5206;&#x949F;&#x8868;&#x793A;&#x65E5;&#x671F; &#x7B2C;&#x4E8C;&#x79CD;&#x65B9;&#x5F0F;&#x662F;&#x4F7F;&#x7528;&#x4E00;&#x4E2A;32&#x4F4D;&#x7684;int&#x6570;&#x503C;&#x8868;&#x793A;&#x4ECE;1970-01-01 00:00&#x4EE5;&#x6765;&#x7ECF;&#x8FC7;&#x7684;&#x5206;&#x949F;&#x6570;&#x3002; &#x65E5;&#x671F; &#x793A;&#x4F8B; 123x4a x00 x00 x00 xd0 x4b x92 x84 xb8 # 09:51:31 1998&#x5E74;5&#x6708;8&#x65E5;UTCx4b x4b x92 x0b xa0 # 09:51:00 1998&#x5E74;5&#x6708;8&#x65E5;UTC double Double &#x8BED;&#x6CD5; 123456double ::= D b7 b6 b5 b4 b3 b2 b1 b0 ::= x5b ::= x5c ::= x5d b0 ::= x5e b1 b0 ::= x5f b3 b2 b1 b0 &#x4E00;&#x4E2A;64&#x4F4D;&#x7684;IEEE&#x6807;&#x51C6;&#x7684;&#x6D6E;&#x70B9;&#x6570;&#x3002; &#x538B;&#x7F29;&#xFF1A;double zero double&#x7C7B;&#x578B;&#x7684;0.0&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x5B57;&#x8282;x5b&#x8868;&#x793A;&#x3002; &#x538B;&#x7F29;&#xFF1A;double one double&#x7C7B;&#x578B;&#x7684;1.0&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x5B57;&#x8282;x5c&#x8868;&#x793A;&#x3002; &#x538B;&#x7F29;: double octet &#x4ECB;&#x4E8E;-128.0 &#x548C; 127.0 &#x4E4B;&#x95F4;&#xFF0C;&#x4E14;&#x6CA1;&#x6709;&#x5C0F;&#x6570;&#x90E8;&#x5206;&#x7684;double&#x6570;&#x503C;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x4E24;&#x4E2A;&#x5B57;&#x8282;&#x8868;&#x793A;&#x3002;&#x8F6C;&#x6362;&#x516C;&#x5F0F;&#xFF1A; 1value = (double) b0 &#x538B;&#x7F29;: double short &#x4ECB;&#x4E8E;-32768.0 &#x548C; 32767.0 &#x4E4B;&#x95F4;&#xFF0C;&#x4E14;&#x6CA1;&#x6709;&#x5C0F;&#x6570;&#x90E8;&#x5206;&#x7684;double&#x6570;&#x503C;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x4E09;&#x4E2A;&#x5B57;&#x8282;&#x8868;&#x793A;&#x3002;&#x8F6C;&#x6362;&#x516C;&#x5F0F;&#xFF1A; 1value = (double) (256 * b1 + b0) &#x538B;&#x7F29;: double float Doubles which are equivalent to their 32-bit float representation can be represented as the 4-octet float and then cast to double. Double &#x793A;&#x4F8B; 123456789101112x5b # 0.0x5c # 1.0x5d x00 # 0.0x5d x80 # -128.0x5d x7f # 127.0x5e x00 x00 # 0.0x5e x80 x00 # -32768.0x5e x7f xff # 32767.0D x40 x28 x80 x00 x00 x00 x00 x00 # 12.25 int Integer &#x8BED;&#x6CD5;&#xFF1A; 1234int ::= &apos;I&apos; b3 b2 b1 b0 ::= [x80-xbf] ::= [xc0-xcf] b0 ::= [xd0-xd7] b1 b0 A 32-bit signed integer. An integer is represented by the octet x49 (&apos;I&apos;) followed by the 4 octets of the integer in big-endian order. value = (b3 &lt;&lt; 24) + (b2 &lt;&lt; 16) + (b1 &lt;&lt; 8) + b0; &#x538B;&#x7F29;&#xFF1A;&#x5355;&#x5B57;&#x8282;&#x6574;&#x6570; &#x4ECB;&#x4E8E;-16 &#x548C; 47 &#x4E4B;&#x95F4;&#x7684;&#x6574;&#x6570;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x5355;&#x4E2A;&#x4F4D;&#x4E8E;[x80, xbf]&#x8303;&#x56F4;&#x5185;&#x7684;&#x5B57;&#x8282;&#x8868;&#x793A;&#x3002;&#x8F6C;&#x6362;&#x516C;&#x5F0F;&#xFF1A; 1value = code - 0x90 &#x538B;&#x7F29;&#xFF1A;&#x53CC;&#x5B57;&#x8282;&#x6574;&#x6570; &#x4ECB;&#x4E8E;-2048 &#x548C; 2047 &#x4E4B;&#x95F4;&#x7684;&#x6574;&#x6570;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x4E24;&#x4E2A;&#x5B57;&#x8282;&#x8868;&#x793A;&#xFF0C;&#x9996;&#x5B57;&#x8282;&#x4F4D;&#x4E8E;[xc0, xcf]&#x8303;&#x56F4;&#x5185;&#x3002;&#x8F6C;&#x6362;&#x516C;&#x5F0F;&#xFF1A; 1value = ((code - 0xc8) &lt;&lt; 8) + b0; &#x538B;&#x7F29;&#xFF1A;&#x4E09;&#x5B57;&#x8282;&#x6574;&#x6570; &#x4ECB;&#x4E8E;-262144 &#x548C; 262143 &#x4E4B;&#x95F4;&#x7684;&#x6574;&#x6570;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x4E09;&#x4E2A;&#x5B57;&#x8282;&#x8868;&#x793A;&#xFF0C;&#x9996;&#x5B57;&#x8282;&#x4F4D;&#x4E8E;[xd0, xd7]&#x8303;&#x56F4;&#x5185;&#x3002;&#x8F6C;&#x6362;&#x516C;&#x5F0F;&#xFF1A; 1value = ((code - 0xd4) &lt;&lt; 16) + (b1 &lt;&lt; 8) + b0; Integer &#x793A;&#x4F8B; 123456789101112131415x90 # 0x80 # -16xbf # 47xc8 x00 # 0xc0 x00 # -2048xc7 x00 # -256xcf xff # 2047xd4 x00 x00 # 0xd0 x00 x00 # -262144xd7 xff xff # 262143I x00 x00 x00 x00 # 0I x00 x00 x01 x2c # 300 list List &#x8BED;&#x6CD5; 123456list ::= x55 type value* &apos;Z&apos; # variable-length list ::= &apos;V&apos; type int value* # fixed-length list ::= x57 value* &apos;Z&apos; # variable-length untyped list ::= x58 int value* # fixed-length untyped list ::= [x70-77] type value* # fixed-length typed list ::= [x78-7f] value* # fixed-length untyped list An ordered list, like an array. The two list productions are a fixed-length list and a variable length list. Both lists have a type. The type string may be an arbitrary UTF-8 string understood by the service. Each list item is added to the reference list to handle shared and circular elements. See the ref element. Any parser expecting a list must also accept a null or a shared ref. The valid values of type are not specified in this document and may depend on the specific application. For example, a server implemented in a language with static typing which exposes an Hessian interface can use the type information to instantiate the specific array type. On the other hand, a server written in a dynamicly-typed language would likely ignore the contents of type entirely and create a generic array. Compact: fixed length list Hessian 2.0 allows a compact form of the list for successive lists of the same type where the length is known beforehand. The type and length are encoded by integers, where the type is a reference to an earlier specified type. List &#x793A;&#x4F8B; &#x5E8F;&#x5217;&#x5316;&#x4E00;&#x4E2A;&#x6574;&#x6570;&#x6570;&#x7EC4;: int[] = {0, 1} 12345V # fixed length, typed list x04 [int # encoding of int[] type x92 # length = 2 x90 # integer 0 x91 # integer 1 &#x53EF;&#x53D8;&#x957F;&#x5EA6;&#xFF0C;&#x65E0;&#x7C7B;&#x578B;&#xFF1A; list = {0, 1} 1234x57 # variable-length, untyped x90 # integer 0 x91 # integer 1 Z &#x56FA;&#x5B9A;&#x957F;&#x5EA6;&#xFF0C;&#x9650;&#x5236;&#x7C7B;&#x578B;&#xFF1A; 12345678910x72 # typed list length=2 x04 [int # type for int[] (save as type #0) x90 # integer 0 x91 # integer 1x73 # typed list length = 3 x90 # type reference to int[] (integer #0) x92 # integer 2 x93 # integer 3 x94 # integer 4 long Long &#x8BED;&#x6CD5; 12345long ::= L b7 b6 b5 b4 b3 b2 b1 b0 ::= [xd8-xef] ::= [xf0-xff] b0 ::= [x38-x3f] b1 b0 ::= x4c b3 b2 b1 b0 A 64-bit signed integer. An long is represented by the octet x4c (&apos;L&apos; ) followed by the 8-bytes of the integer in big-endian order. 64&#x4F4D;&#x6709;&#x7B26;&#x53F7;&#x7684;&#x6574;&#x6570;&#x3002;&#x4E00;&#x4E2A;long&#x7C7B;&#x578B;&#x6570;&#x503C;&#x4F7F;&#x7528;&#x5B57;&#x8282;0x4c(&apos;L&apos;)&#x5F00;&#x5934;&#xFF0C;&#x540E;&#x9762;&#x8DDF;&#x7740;8&#x4E2A;&#x5B57;&#x8282;&#x7684;&#x5927;&#x7AEF;&#x6574;&#x6570;&#x8868;&#x793A;&#x3002; &#x538B;&#x7F29;&#xFF1A;&#x5355;&#x5B57;&#x8282;long Longs between -8 and 15 are represented by a single octet in the range xd8 to xef. &#x4ECB;&#x4E8E;-8&#x5230;15&#x4E4B;&#x95F4;&#x7684;long&#x7C7B;&#x578B;&#xFF0C;&#x4F7F;&#x7528;&#x4E00;&#x4E2A;&#x53D6;&#x503C;&#x8303;&#x56F4;&#x5728;[0xd8, 0xef]&#x7684;&#x516B;&#x8FDB;&#x5236;&#x8868;&#x793A;&#x3002;&#x8F6C;&#x6362;&#x516C;&#x5F0F;&#xFF1A; value = (code - 0xe0) &#x538B;&#x7F29;&#xFF1A;&#x53CC;&#x5B57;&#x8282;long Longs between -2048 and 2047 are encoded in two octets with the leading byte in the range xf0 to xff. &#x4ECB;&#x4E8E;-2048&#x5230;2047&#x4E4B;&#x95F4;&#x7684;long&#x7C7B;&#x578B;&#xFF0C;&#x4F7F;&#x7528;&#x4E24;&#x4E2A;&#x516B;&#x8FDB;&#x5236;&#x6570;&#x503C;&#x8868;&#x793A;&#xFF0C;&#x5176;&#x4E2D;&#x9996;&#x5B57;&#x8282;&#x53D6;&#x503C;&#x8303;&#x56F4;&#x5728;[0xf0, 0xff]&#x3002;&#x8F6C;&#x6362;&#x516C;&#x5F0F;&#xFF1A; value = ((code - 0xf8) &lt;&lt; 8) + b0 &#x538B;&#x7F29;&#xFF1A;&#x4E09;&#x5B57;&#x8282;long Longs between -262144 and 262143 are encoded in three octets with the leading byte in the range x38 to x3f. &#x4ECB;&#x4E8E;-262144&#x5230;262143&#x4E4B;&#x95F4;&#x7684;long&#x7C7B;&#x578B;&#xFF0C;&#x4F7F;&#x7528;&#x4E09;&#x4E2A;&#x516B;&#x8FDB;&#x5236;&#x6570;&#x503C;&#x8868;&#x793A;&#xFF0C;&#x5176;&#x4E2D;&#x9996;&#x5B57;&#x8282;&#x53D6;&#x503C;&#x8303;&#x56F4;&#x5728;[0x38, 0x3f]&#x3002;&#x8F6C;&#x6362;&#x516C;&#x5F0F;&#xFF1A; value = ((code - 0x3c) &lt;&lt; 16) + (b1 &lt;&lt; 8) + b0 &#x538B;&#x7F29;&#xFF1A;&#x56DB;&#x5B57;&#x8282;long Longs between which fit into 32-bits are encoded in five octets with the leading byte x4c. &#x4E0D;&#x8D85;&#x8FC7;32&#x4F4D;&#x7684;long&#x7C7B;&#x578B;&#x6570;&#x503C;&#xFF0C;&#x91C7;&#x7528;5&#x4E2A;&#x5B57;&#x8282;&#x7F16;&#x7801;&#xFF0C;&#x5176;&#x4E2D;&#x9996;&#x5B57;&#x8282;&#x4E3A;0x4c&#x3002;&#x8F6C;&#x6362;&#x516C;&#x5F0F;&#xFF1A; value = (b3 &lt;&lt; 24) + (b2 &lt;&lt; 16) + (b1 &lt;&lt; 8) + b0 Long &#x793A;&#x4F8B; 1234567891011121314151617xe0 # 0xd8 # -8xef # 15xf8 x00 # 0xf0 x00 # -2048xf7 x00 # -256xff xff # 2047x3c x00 x00 # 0x38 x00 x00 # -262144x3f xff xff # 262143x4c x00 x00 x00 x00 # 0x4c x00 x00 x01 x2c # 300L x00 x00 x00 x00 x00 x00 x01 x2c # 300 map Map &#x8BED;&#x6CD5; 1map ::= M type (value value)* Z Represents serialized maps and can represent objects. The type element describes the type of the map. &#x4EE3;&#x8868;&#x4E00;&#x4E2A;&#x5E8F;&#x5217;&#x5316;&#x7684;map&#xFF0C;&#x4E5F;&#x53EF;&#x4EE5;&#x8868;&#x793A;&#x4E00;&#x4E2A;&#x5BF9;&#x8C61;&#x3002;type&#x5143;&#x7D20;&#x63CF;&#x8FF0;&#x4E86;map&#x7684;&#x7C7B;&#x578B;&#x3002; The type may be empty, i.e. a zero length. The parser is responsible for choosing a type if one is not specified. For objects, unrecognized keys will be ignored. type&#x5143;&#x7D20;&#x53EF;&#x80FD;&#x4E3A;&#x7A7A;&#xFF0C;&#x5373;&#x96F6;&#x957F;&#x5EA6;&#x3002;&#x5F53;type&#x672A;&#x6307;&#x5B9A;&#x65F6;&#xFF0C;&#x7531;&#x89E3;&#x6790;&#x5668;&#x8D1F;&#x8D23;&#x9009;&#x62E9;&#x4E00;&#x4E2A;&#x7C7B;&#x578B;&#x3002;&#x5BF9;&#x4E8E;object&#xFF0C;&#x4E0D;&#x80FD;&#x8BC6;&#x522B;&#x7684;key&#x5C06;&#x4F1A;&#x88AB;&#x5FFD;&#x7565;&#x3002; Each map is added to the reference list. Any time the parser expects a map, it must also be able to support a null or a ref. &#x6BCF;&#x4E00;&#x4E2A;&#x6620;&#x5C04;&#x90FD;&#x5C06;&#x88AB;&#x6DFB;&#x52A0;&#x5230;&#x53C2;&#x8003;&#x96C6;&#x5408;&#x4E2D;&#x3002;&#x4EFB;&#x4F55;&#x65F6;&#x5019;&#xFF0C;&#x89E3;&#x6790;&#x5668;&#x90FD;&#x671F;&#x671B;&#x6709;&#x4E00;&#x4E2A;&#x6620;&#x5C04;&#xFF0C;&#x5B83;&#x5FC5;&#x987B;&#x652F;&#x6301;null&#x6216;&#x8005;&#x4E00;&#x4E2A;&#x5F15;&#x7528;&#x3002; The type is chosen by the service. &#x7C7B;&#x578B;&#x7531;service&#x9009;&#x62E9;&#x3002; Map &#x793A;&#x4F8B; &#x7A00;&#x758F;&#x6570;&#x7EC4;&#xFF1A; 1234map = new HashMap();map.put(new Integer(1), &quot;fee&quot;);map.put(new Integer(16), &quot;fie&quot;);map.put(new Integer(256), &quot;foe&quot;); 1234567891011H # untyped map (HashMap for Java) x91 # 1 x03 fee # &quot;fee&quot; xa0 # 16 x03 fie # &quot;fie&quot; xc9 x00 # 256 x03 foe # &quot;foe&quot; Z Java&#x5BF9;&#x8C61;&#x7684;map&#x8868;&#x793A;&#xFF1A; 12345public class Car implements Serializable { String color = &quot;aquamarine&quot;; String model = &quot;Beetle&quot;; int mileage = 65536;} 123456789101112M x13 com.caucho.test.Car # type x05 color # color field x0a aquamarine x05 model # model field x06 Beetle x07 mileage # mileage field I x00 x01 x00 x00 Z null Null &#x8BED;&#x6CD5; 1null ::= N Null &#x8868;&#x793A;&#x7A7A;&#x6307;&#x9488;&#x3002;&#x5B57;&#x8282; &apos;N&apos; &#x8868;&#x793A;null&#x503C;&#x3002; object Object &#x8BED;&#x6CD5; 1234class-def ::= &apos;C&apos; string int string*object ::= &apos;O&apos; int value* ::= [x60-x6f] value* &#x538B;&#x7F29;: class definition Hessian 2.0 has a compact object form where the field names are only serialized once. Hessian 2.0&#x5177;&#x6709;&#x7D27;&#x51D1;&#x7684;&#x5BF9;&#x8C61;&#x5F62;&#x5F0F;&#xFF0C;&#x5176;&#x4E2D;&#x5B57;&#x6BB5;&#x540D;&#x79F0;&#x4EC5;&#x88AB;&#x5E8F;&#x5217;&#x5316;&#x4E00;&#x6B21;&#x3002; Following objects only need to serialize their values. &#x4E4B;&#x540E;&#x7684;&#x5BF9;&#x8C61;&#xFF0C;&#x53EA;&#x9700;&#x8981;&#x5E8F;&#x5217;&#x5316;&#x5B83;&#x4EEC;&#x7684;&#x503C;&#x3002; The object definition includes a mandatory type string, the number of fields, and the field names. The object definition is stored in the object definition map and will be referenced by object instances with an integer reference. &#x538B;&#x7F29;: object instantiation Hessian 2.0 has a compact object form where the field names are only serialized once. Following objects only need to serialize their values. Hessian 2.0&#x5177;&#x6709;&#x7D27;&#x51D1;&#x7684;&#x5BF9;&#x8C61;&#x5F62;&#x5F0F;&#xFF0C;&#x5176;&#x4E2D;&#x5B57;&#x6BB5;&#x540D;&#x79F0;&#x4EC5;&#x88AB;&#x5E8F;&#x5217;&#x5316;&#x4E00;&#x6B21;&#x3002; The object instantiation creates a new object based on a previous definition. The integer value refers to the object definition. &#x5BF9;&#x8C61;&#x5B9E;&#x4F8B;&#x57FA;&#x4E8E;&#x524D;&#x9762;&#x7684;&#x5B9A;&#x4E49;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x5BF9;&#x8C61;&#x3002;&#x4F7F;&#x7528;&#x4E00;&#x4E2A;&#x6574;&#x6570;&#x6307;&#x5411;&#x5BF9;&#x8C61;&#x7684;&#x5B9A;&#x4E49;&#x3002; Object &#x793A;&#x4F8B; Object &#x5E8F;&#x5217;&#x5316;&#xFF1A; 1234567class Car { String color; String model;}out.writeObject(new Car(&quot;red&quot;, &quot;corvette&quot;));out.writeObject(new Car(&quot;green&quot;, &quot;civic&quot;)); 1234567891011121314C # object definition (#0) x0b example.Car # type is example.Car x92 # two fields x05 color # color field name x05 model # model field nameO # object def (long form) x90 # object definition #0 x03 red # color field value x08 corvette # model field valuex60 # object def #0 (short form) x05 green # color field value x05 civic # model field value &#x679A;&#x4E3E;&#x7C7B;&#x578B;&#xFF1A; 12345678910 enum Color { RED, GREEN, BLUE,}out.writeObject(Color.RED);out.writeObject(Color.GREEN);out.writeObject(Color.BLUE);out.writeObject(Color.GREEN); 12345678910111213141516C # class definition #0 x0b example.Color # type is example.Color x91 # one field x04 name # enumeration field is &quot;name&quot;x60 # object #0 (class def #0) x03 RED # RED valuex60 # object #1 (class def #0) x90 # object definition ref #0 x05 GREEN # GREEN valuex60 # object #2 (class def #0) x04 BLUE # BLUE valuex51 x91 # object ref #1, i.e. Color.GREEN ref Ref &#x8BED;&#x6CD5; 1ref ::= x51 int An integer referring to a previous list, map, or object instance. As each list, map or object is read from the input stream, it is assigned the integer position in the stream, i.e. the first list or map is &apos;0&apos;, the next is &apos;1&apos;, etc. A later ref can then use the previous object. Writers MAY generate refs. Parsers MUST be able to recognize them. &#x4E00;&#x4E2A;&#x6574;&#x6570;&#x6307;&#x5411;&#x4E00;&#x4E2A;&#x524D;&#x9762;&#x7684;list&#x3001;map&#x6216;&#x8005;&#x4E00;&#x4E2A;&#x5BF9;&#x8C61;&#x5B9E;&#x4F8B;&#x3002;&#x5BF9;&#x4E8E;&#x6BCF;&#x4E00;&#x4E2A;&#x4ECE;&#x8F93;&#x5165;&#x6D41;&#x4E2D;&#x8BFB;&#x5230;&#x7684;list&#x3001;map&#x6216;&#x8005;&#x5BF9;&#x8C61;&#xFF0C;&#x5B83;&#x90FD;&#x88AB;&#x6307;&#x5B9A;&#x4E86;&#x4E00;&#x4E2A;&#x6574;&#x6570;&#x7684;&#x4F4D;&#x7F6E;&#xFF0C;&#x5373;&#xFF0C;&#x7B2C;&#x4E00;&#x4E2A;list&#x6216;map&#x7684;&#x4F4D;&#x7F6E;&#x662F;0&#xFF0C;&#x4E0B;&#x4E00;&#x4E2A;&#x662F;1,&#x7B49;&#x7B49;&#x3002;&#x540E;&#x9762;&#x7684;&#x5F15;&#x7528;&#x53EF;&#x4EE5;&#x6307;&#x5411;&#x524D;&#x9762;&#x7684;&#x5BF9;&#x8C61;&#x3002;&#x5199;&#x5165;&#x5668;&#x53EF;&#x80FD;&#x4F1A;&#x751F;&#x6210;&#x5F15;&#x7528;&#xFF0C;&#x89E3;&#x6790;&#x5668;&#x4E00;&#x5B9A;&#x8981;&#x80FD;&#x591F;&#x6CE8;&#x518C;&#x5B83;&#x4EEC;&#x3002; &#x8BD1;&#x8005;&#x6CE8;&#xFF1A;ref&#x53EF;&#x4EE5;&#x7406;&#x89E3;&#x4E3A;&#x6307;&#x9488;&#x3002; ref can refer to incompletely-read items. For example, a circular linked-list will refer to the first link before the entire list has been read. ref&#x53EF;&#x4EE5;&#x6307;&#x5411;&#x4E00;&#x4E2A;&#x5DF2;&#x7ECF;&#x8BFB;&#x53D6;&#x5B8C;&#x7684;&#x9879;&#x3002;&#x4F8B;&#x5982;&#xFF1A;&#x4E00;&#x4E2A;&#x5FAA;&#x73AF;&#x94FE;&#x8868;&#x5728;&#x6574;&#x4E2A;&#x8BFB;&#x53D6;&#x5B8C;&#x4E4B;&#x524D;&#xFF0C;&#x53EF;&#x80FD;&#x4F1A;&#x6307;&#x5411;&#x7B2C;&#x4E00;&#x4E2A;&#x94FE;&#x63A5;&#x3002; A possible implementation would add each map, list, and object to an array as it is read. The ref will return the corresponding value from the array. To support circular structures, the implementation would store the map, list or object immediately, before filling in the contents. Each map or list is stored into an array as it is parsed. ref selects one of the stored objects. The first object is numbered &apos;0&apos;. Ref &#x793A;&#x4F8B; Circular list 1234567891011121314list = new LinkedList();list.data = 1;list.tail = list;---C x0a LinkedList x92 x04 head x04 tailo x90 # object stores ref #0 x91 # data = 1 x51 x90 # next field refers to itself, i.e. ref #0 ref only refers to list, map and objects elements. Strings and binary data, in particular, will only share references if they&apos;re wrapped in a list or map. string String &#x8BED;&#x6CD5; 1234string ::= x52 b1 b0 &lt;utf8-data&gt; string ::= S b1 b0 &lt;utf8-data&gt; ::= [x00-x1f] &lt;utf8-data&gt; ::= [x30-x33] b0 &lt;utf8-data&gt; A 16-bit unicode character string encoded in UTF-8. Strings are encoded in chunks. x53 (&apos;S&apos;) represents the final chunk and x52 (&apos;R&apos;) represents any non-final chunk. Each chunk has a 16-bit unsigned integer length value. String&#x662F;&#x4EE5;UTF-8&#x7F16;&#x7801;&#x7684;16&#x4F4D;&#x7684;unicode&#x5B57;&#x7B26;&#x4E32;&#x3002;String&#x4F7F;&#x7528;&#x5757;&#x7F16;&#x7801;&#x3002;0x53(&apos;S&apos;)&#x8868;&#x793A;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x5757;&#xFF0C;0x52(&apos;R&apos;)&#x8868;&#x793A;&#x9664;&#x4E86;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x5757;&#x4EE5;&#x5916;&#x7684;&#x5757;&#x3002;&#x6BCF;&#x4E2A;&#x5757;&#x90FD;&#x6709;&#x4E00;&#x4E2A;16&#x4F4D;&#x7684;&#x957F;&#x5EA6;&#x503C;&#x3002; The length is the number of 16-bit characters, which may be different than the number of bytes. &#x957F;&#x5EA6;&#x662F;&#x6307;16&#x4F4D;&#x5B57;&#x7B26;&#x7684;&#x957F;&#x5EA6;&#xFF0C;&#x53EF;&#x80FD;&#x548C;&#x5B57;&#x8282;&#x7684;&#x6570;&#x91CF;&#x4E0D;&#x4E00;&#x6837;&#x3002; String chunks may not split surrogate pairs. &#x538B;&#x7F29;: short strings Strings with length less than 32 may be encoded with a single octet length [x00-x1f]. &#x957F;&#x5EA6;&#x5C11;&#x4E8E;32&#x7684;&#x5B57;&#x7B26;&#x4E32;&#x4F7F;&#x7528;&#x4E00;&#x4E2A;&#x8303;&#x56F4;&#x5728;[x00-x1f]&#x7684;&#x516B;&#x8FDB;&#x5236;&#x6570;&#x503C;&#x7F16;&#x7801;&#x5B83;&#x7684;&#x957F;&#x5EA6;&#x3002;&#x8BA1;&#x7B97;&#x516C;&#x5F0F;&#xFF1A; value = code String &#x793A;&#x4F8B; 12345678x00 # &quot;&quot;, empty stringx05 hello # &quot;hello&quot;x01 xc3 x83 # &quot;\\u00c3&quot;S x00 x05 hello # &quot;hello&quot; in long formx52 x00 x07 hello, # &quot;hello, world&quot; split into two chunksx05 world type Type &#x8BED;&#x6CD5; 12type ::= string ::= int A map or list includes a type attribute indicating the type name of the map or list for object-oriented languages. Each type is added to the type map for future reference. &#x538B;&#x7F29;: type &#x5F15;&#x7528; Repeated type strings MAY use the type map to refer to a previously used type. The type reference is zero-based over all the types encountered during parsing. &#x5F15;&#x7528;&#x6620;&#x5C04; Hessian 2.0 &#x6709;&#x4E09;&#x79CD;&#x5185;&#x7F6E;&#x5F15;&#x7528;&#x6620;&#x5C04;: An map/object/list reference map. An class definition map. A type (class name) map. The value reference map lets Hessian support arbitrary graphs, and recursive and circular data structures. The class and type maps improve Hessian efficiency by avoiding repetition of common string data. &#x503C;&#x5F15;&#x7528; Hessian supports arbitrary graphs by adding list, object, and map as it encounters them in the bytecode stream. Parsers MUST store each list, object and map in the reference map as they are encountered. The stored objects can be used with a ref bytecode. class &#x5F15;&#x7528; Each object definition is automatically added to the class-map. Parsers MUST add a class definition to the class map as each is encountered. Following object instances will refer to the defined class. type &#x5F15;&#x7528; The type strings for map and list values are stored in a type map for reference. Parsers MUST add a type string to the type map as each is encountered. &#x5B57;&#x8282;&#x6620;&#x5C04; Hessian is organized as a bytecode protocol. A Hessian reader is essentially a switch statement on the initial octet. &#x5B57;&#x8282;&#x7F16;&#x7801;&#xFF1A; 123456789101112131415161718192021222324252627282930313233343536373839404142434445x00 - x1f # utf-8 string length 0-32x20 - x2f # binary data length 0-16x30 - x33 # utf-8 string length 0-1023x34 - x37 # binary data length 0-1023x38 - x3f # three-octet compact long (-x40000 to x3ffff)x40 # reserved (expansion/escape)x41 # 8-bit binary data non-final chunk (&apos;A&apos;)x42 # 8-bit binary data final chunk (&apos;B&apos;)x43 # object type definition (&apos;C&apos;)x44 # 64-bit IEEE encoded double (&apos;D&apos;)x45 # reservedx46 # boolean false (&apos;F&apos;)x47 # reservedx48 # untyped map (&apos;H&apos;)x49 # 32-bit signed integer (&apos;I&apos;)x4a # 64-bit UTC millisecond datex4b # 32-bit UTC minute datex4c # 64-bit signed long integer (&apos;L&apos;)x4d # map with type (&apos;M&apos;)x4e # null (&apos;N&apos;)x4f # object instance (&apos;O&apos;)x50 # reservedx51 # reference to map/list/object - integer (&apos;Q&apos;)x52 # utf-8 string non-final chunk (&apos;R&apos;)x53 # utf-8 string final chunk (&apos;S&apos;)x54 # boolean true (&apos;T&apos;)x55 # variable-length list/vector (&apos;U&apos;)x56 # fixed-length list/vector (&apos;V&apos;)x57 # variable-length untyped list/vector (&apos;W&apos;)x58 # fixed-length untyped list/vector (&apos;X&apos;)x59 # long encoded as 32-bit int (&apos;Y&apos;)x5a # list/map terminator (&apos;Z&apos;)x5b # double 0.0x5c # double 1.0x5d # double represented as byte (-128.0 to 127.0)x5e # double represented as short (-32768.0 to 327676.0)x5f # double represented as floatx60 - x6f # object with direct typex70 - x77 # fixed list with direct lengthx78 - x7f # fixed untyped list with direct lengthx80 - xbf # one-octet compact int (-x10 to x3f, x90 is 0)xc0 - xcf # two-octet compact int (-x800 to x7ff)xd0 - xd7 # three-octet compact int (-x40000 to x3ffff)xd8 - xef # one-octet compact long (-x8 to xf, xe0 is 0)xf0 - xff # two-octet compact long (-x800 to x7ff, xf8 is 0) &#x4F5C;&#x8005;&#x8054;&#x7CFB;&#x65B9;&#x5F0F; 123456Scott FergusonCaucho Technology Inc.P.O. Box 9001La Jolla, CA 92038USAEmail: ferg@caucho.com 123456Emil OngCaucho Technology Inc.P.O. Box 9001La Jolla, CA 92038USAEmail: emil@caucho.com Full Copyright Statement Copyright &#xA9; The IETF Trust (2007). This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights. This document and the information contained herein are provided on an &#x201C;AS IS&#x201D; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Intellectual Property The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79. Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr. The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.","categories":[{"name":"java","slug":"java","permalink":"https://yyhan.github.io/categories/java/"}],"tags":[{"name":"hessian","slug":"hessian","permalink":"https://yyhan.github.io/tags/hessian/"},{"name":"序列化","slug":"序列化","permalink":"https://yyhan.github.io/tags/序列化/"}]},{"title":"Spring MVC基本配置","slug":"Spring-MVC基本配置","date":"2017-06-15T14:25:45.000Z","updated":"2017-06-15T14:57:09.491Z","comments":true,"path":"2017/06/15/Spring-MVC基本配置/","link":"","permalink":"https://yyhan.github.io/2017/06/15/Spring-MVC基本配置/","excerpt":"","text":"","categories":[{"name":"spring","slug":"spring","permalink":"https://yyhan.github.io/categories/spring/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yyhan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://yyhan.github.io/tags/spring/"}]},{"title":"hessian 常见问题","slug":"hessian-常见问题","date":"2017-06-15T13:22:54.000Z","updated":"2017-06-15T14:24:28.866Z","comments":true,"path":"2017/06/15/hessian-常见问题/","link":"","permalink":"https://yyhan.github.io/2017/06/15/hessian-常见问题/","excerpt":"","text":"hessian&#x63A5;&#x53E3;&#x670D;&#x52A1;&#x7AEF;&#x548C;&#x5BA2;&#x6237;&#x7AEF;&#x5BF9;&#x8C61;&#x4E0D;&#x4E00;&#x81F4;&#x95EE;&#x9898; &#x5B57;&#x6BB5;&#x6570;&#x91CF;&#x4E0D;&#x4E00;&#x81F4; hessian&#x5141;&#x8BB8;&#x5BA2;&#x6237;&#x7AEF;&#x548C;&#x670D;&#x52A1;&#x7AEF;&#x5BF9;&#x8C61;&#x5B57;&#x6BB5;&#x4E0D;&#x4E00;&#x81F4;&#xFF0C;&#x589E;&#x52A0;&#x3001;&#x5220;&#x9664;&#x5B57;&#x6BB5;&#x90FD;&#x4E0D;&#x5F71;&#x54CD;&#xFF0C;&#x4F46;&#x662F;&#x5BF9;&#x4E8E;&#x540C;&#x540D;&#x5B57;&#x6BB5;&#xFF0C;&#x5FC5;&#x987B;&#x4FDD;&#x8BC1;&#x5B57;&#x6BB5;&#x7C7B;&#x578B;&#x4E00;&#x81F4;&#xFF0C;&#x5426;&#x5219;&#x4F1A;&#x62A5;&#x5F02;&#x5E38;&#xFF1A; &#x4F8B;&#x5982;&#x670D;&#x52A1;&#x7AEF;&#x4E3A;BigDecimal&#xFF0C;&#x5BA2;&#x6237;&#x7AEF;&#x4E3A;int&#xFF1A; 1com.caucho.hessian.client.HessianRuntimeException: com.caucho.hessian.io.HessianFieldException: com.demo.entity.DemoBean.number: expected integer at 0x43 java.math.BigDecimal (1233456) &#x63A5;&#x53E3;&#x8FD4;&#x56DE;&#x503C;&#x7C7B;&#x578B;&#x4E0D;&#x4E00;&#x81F4; &#x5F53;&#x670D;&#x52A1;&#x7AEF;&#x8FD4;&#x56DE;&#x5BF9;&#x8C61;&#x548C;&#x5BA2;&#x6237;&#x7AEF;&#x671F;&#x671B;&#x83B7;&#x53D6;&#x7684;&#x5BF9;&#x8C61;&#x4E0D;&#x4E00;&#x81F4;&#x65F6;&#xFF0C;&#x6BD4;&#x5982;&#x670D;&#x52A1;&#x7AEF;&#x8FD4;&#x56DE;&#x7C7B;&#x578B;&#x4E3A;A&#xFF0C;&#x4F46;&#x662F;&#x5BA2;&#x6237;&#x7AEF;&#x63A5;&#x53D7;&#x7684;&#x8FD4;&#x56DE;&#x7C7B;&#x578B;&#x4E3A;B&#xFF0C;&#x6B64;&#x65F6;hessian&#x4F7F;&#x7528;map&#x6620;&#x5C04;&#x7684;&#x65B9;&#x5F0F;&#x89E3;&#x6790;&#xFF0C;&#x6839;&#x636E;&#x5B57;&#x6BB5;&#x540D;&#x6620;&#x5C04;&#xFF0C;&#x4F46;&#x662F;&#x4F1A;&#x8BB0;&#x5F55;&#x4E00;&#x4E9B;&#x8B66;&#x544A;&#x65E5;&#x5FD7;&#xFF1A; 12345678[2017-06-15 22:17:00,267] &#x8B66;&#x544A; com.caucho.hessian.io.SerializerFactory getDeserializer - Hessian/Burlap: &apos;com.demo.entity.DemoBean&apos; is an unknown class in sun.misc.Launcher$AppClassLoader@18b4aac2:java.lang.ClassNotFoundException: com.demo.entity.DemoBean [2017-06-15 22:17:00,282] &#x8F83;&#x8BE6;&#x7EC6; com.caucho.hessian.io.SerializerFactory getDeserializer - java.lang.ClassNotFoundException: com.demo.entity.DemoBean [2017-06-15 22:17:01,194] &#x8B66;&#x544A; com.caucho.hessian.io.SerializerFactory getDeserializer - Hessian/Burlap: &apos;com.demo.entity.DemoBean&apos; is an unknown class in sun.misc.Launcher$AppClassLoader@18b4aac2:java.lang.ClassNotFoundException: com.demo.entity.DemoBean [2017-06-15 22:17:01,194] &#x8F83;&#x8BE6;&#x7EC6; com.caucho.hessian.io.SerializerFactory getDeserializer - java.lang.ClassNotFoundException: com.demo.entity.DemoBean MyHessianServlet.getDeserializer: com.demo.entity.Demo2Bean[2017-06-15 22:17:01,196] &#x8BE6;&#x7EC6; com.caucho.hessian.io.SerializerFactory getObjectDeserializer - hessian: expected deserializer &apos;com.demo.entity.Demo2Bean&apos; at &apos;com.demo.entity.DemoBean&apos; (java.util.HashMap)","categories":[{"name":"hessian","slug":"hessian","permalink":"https://yyhan.github.io/categories/hessian/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yyhan.github.io/tags/java/"},{"name":"hessian","slug":"hessian","permalink":"https://yyhan.github.io/tags/hessian/"}]},{"title":"hessian 序列化BigDecimal问题","slug":"hessian-序列化BigDecimal问题","date":"2017-06-13T14:49:43.000Z","updated":"2017-06-18T13:16:02.180Z","comments":true,"path":"2017/06/13/hessian-序列化BigDecimal问题/","link":"","permalink":"https://yyhan.github.io/2017/06/13/hessian-序列化BigDecimal问题/","excerpt":"","text":"hessian&#x5904;&#x7406;BigDecimal&#x65F6;&#xFF0C;&#x9ED8;&#x8BA4;&#x5C06;BigDecimal&#x4F5C;&#x4E3A;Object&#x5BF9;&#x8C61;&#x5904;&#x7406;&#xFF0C;&#x5C1D;&#x8BD5;&#x5C06;BigDecimal&#x7684;&#x5404;&#x4E2A;&#x5B57;&#x6BB5;&#x5E8F;&#x5217;&#x5316;&#xFF0C;&#x4F1A;&#x5BFC;&#x81F4;&#x4F20;&#x8F93;&#x5230;&#x5BA2;&#x6237;&#x7AEF;&#x7684;BigDecimal&#x4F4D;0&#x3002; &#x76EE;&#x524D;&#x6709;&#x4E09;&#x79CD;&#x89E3;&#x51B3;&#x65B9;&#x6848;&#xFF1A; &#x5BF9;hessian&#x91CD;&#x65B0;&#x6253;&#x5305; &#x5B9E;&#x73B0;&#x76EE;&#x6807;&#x5BF9;&#x8C61;&#x7684;&#x5E8F;&#x5217;&#x5316;&#x548C;&#x5E8F;&#x5217;&#x5316;&#x63A5;&#x53E3; &#x6DFB;&#x52A0;&#x81EA;&#x5B9A;&#x4E49;&#x7684;AbstractSerializerFactory &#x5BF9;hessian&#x91CD;&#x65B0;&#x6253;&#x5305; &#x521B;&#x5EFA;META-INF/hessian/serializers&#x6587;&#x4EF6;&#xFF0C;&#x5728;&#x8BE5;&#x6587;&#x4EF6;&#x4E2D;&#x6DFB;&#x52A0;: 1java.math.BigDecimal=com.caucho.hessian.io.StringValueSerializer &#x521B;&#x5EFA;META-INF/hessian/deserializers&#x6587;&#x4EF6;&#xFF0C;&#x5728;&#x8BE5;&#x6587;&#x4EF6;&#x4E2D;&#x6DFB;&#x52A0;: 1java.math.BigDecimal=com.caucho.hessian.io.BigDecimalDeserializer &#x6307;&#x5B9A;&#x4F7F;&#x7528;StringValueSerializer&#x5E8F;&#x5217;&#x5316;BigDecimal&#x5BF9;&#x8C61;&#xFF0C;&#x4F7F;&#x7528;BigDecimalDeserializer&#x53CD;&#x5E8F;&#x5217;&#x5316;BigDecimal&#x5BF9;&#x8C61;&#x3002; &#x5B9E;&#x73B0;&#x76EE;&#x6807;&#x5BF9;&#x8C61;&#x7684;&#x5E8F;&#x5217;&#x5316;&#x548C;&#x5E8F;&#x5217;&#x5316;&#x63A5;&#x53E3; &#x5B9E;&#x73B0;&#x76EE;&#x6807;&#x5BF9;&#x8C61;&#x7684;&#x5E8F;&#x5217;&#x5316;&#xFF08;com.caucho.hessian.io.Serializer&#xFF09;&#x548C;&#x53CD;&#x5E8F;&#x5217;&#x5316;&#x63A5;&#x53E3;&#xFF08;com.caucho.hessian.io.Deserializer&#xFF09;&#x3002; &#x5E8F;&#x5217;&#x5316;&#x7684;&#x7C7B;&#x540D;&#x5FC5;&#x987B;&#x4E3A; cl.getName() + &quot;HessianSerializer&quot; &#x53CD;&#x5E8F;&#x5217;&#x5316;&#x7684;&#x7C7B;&#x540D;&#x5FC5;&#x987B;&#x4E3A; cl.getName() + &quot;HessianDeserializer&quot; &#x540C;&#x65F6;&#x5FC5;&#x987B;&#x548C;&#x76EE;&#x6807;&#x7C7B;&#x7684;&#x5305;&#x8DEF;&#x5F84;&#x5B8C;&#x5168;&#x4E00;&#x81F4;&#x3002; &#x6DFB;&#x52A0;&#x81EA;&#x5B9A;&#x4E49;&#x7684;AbstractSerializerFactory &#x5B9E;&#x73B0;&#x81EA;&#x5DF1;&#x7684;&#x5E8F;&#x5217;&#x5316;&#x5DE5;&#x5382;&#x7C7B;&#xFF0C;&#x5E76;&#x6DFB;&#x52A0;&#x5230;&#x9ED8;&#x8BA4;&#x7684;&#x5E8F;&#x5217;&#x5316;&#x5DE5;&#x5382;&#x4E2D;&#x3002;&#x6709;&#x4E09;&#x5904;&#x6539;&#x52A8;&#xFF1A; &#x81EA;&#x5B9A;&#x4E49;AbstractSerializerFactory 12345678910111213141516171819202122232425262728293031package com.cloudin.hessian.support;import com.caucho.hessian.io.*;import java.math.BigDecimal;import java.util.HashMap;import java.util.Map;/** * Created by YFHan on 2017/6/15 0015. */public class MyAbstractSerializerFactory extends AbstractSerializerFactory { private Map&lt;String, Serializer&gt; serializerMap = new HashMap&lt;&gt;(); private Map&lt;String, Deserializer&gt; deserializerMap = new HashMap&lt;&gt;(); public MyAbstractSerializerFactory() { serializerMap.put(BigDecimal.class.getName(), new StringValueSerializer()); deserializerMap.put(BigDecimal.class.getName(), new BigDecimalDeserializer()); } @Override public Serializer getSerializer(Class cl) throws HessianProtocolException { return serializerMap.get(cl.getName()); } @Override public Deserializer getDeserializer(Class cl) throws HessianProtocolException { return deserializerMap.get(cl.getName()); }} &#x81EA;&#x5B9A;&#x4E49;HessianServlet 123456789101112131415161718192021222324252627282930package com.cloudin.hessian.support;import com.caucho.hessian.io.*;import com.caucho.hessian.server.HessianServlet;import javax.servlet.ServletException;import java.math.BigDecimal;import java.util.HashMap;import java.util.Map;/** * &#x81EA;&#x5B9A;&#x4E49;HessianServlet * Created by YFHan on 2017/6/12 0012. */public class MyHessianServlet extends HessianServlet { private SerializerFactory serializerFactory; @Override public void init(javax.servlet.ServletConfig config) throws ServletException { super.init(config); serializerFactory = super.getSerializerFactory(); serializerFactory.addFactory(new MyAbstractSerializerFactory()); } @Override public SerializerFactory getSerializerFactory() { return serializerFactory; }} &#x5411;HessianProxyFactory&#x4E2D;&#x6DFB;&#x52A0;&#x81EA;&#x5B9A;&#x4E49;&#x7684;&#x5E8F;&#x5217;&#x5316;&#x5DE5;&#x5382;&#x5B9E;&#x4F8B; 12HessianProxyFactory hessianProxyFactory = new HessianProxyFactory();hessianProxyFactory.getSerializerFactory().addFactory(new MyAbstractSerializerFactory()); &#x603B;&#x7ED3; &#x7B2C;&#x4E00;&#x79CD;&#x65B9;&#x6848;&#xFF0C;&#x4E0D;&#x9700;&#x8981;&#x5199;&#x4EFB;&#x4F55;&#x4EE3;&#x7801;&#xFF0C;&#x4F46;&#x662F;&#x9700;&#x8981;&#x81EA;&#x5DF1;&#x7EF4;&#x62A4;hessian&#x7684;&#x6253;&#x5305; &#x7B2C;&#x4E8C;&#x79CD;&#x65B9;&#x6848;&#xFF0C;&#x81EA;&#x5B9A;&#x4E49;&#x7A0B;&#x5EA6;&#x5F88;&#x9AD8;&#xFF0C;&#x4F46;&#x662F;&#x9700;&#x8981;&#x5BF9;hessian&#x7684;&#x5E8F;&#x5217;&#x5316;&#x534F;&#x8BAE;&#x975E;&#x5E38;&#x4E86;&#x89E3;&#xFF0C;&#x4F46;&#x662F;&#x5DE5;&#x4F5C;&#x91CF;&#x5F88;&#x5927;&#xFF0C;&#x4E00;&#x822C;&#x4E0D;&#x7528; &#x7B2C;&#x4E09;&#x79CD;&#x65B9;&#x6848;&#x548C;&#x7B2C;&#x4E00;&#x79CD;&#x65B9;&#x6848;&#x539F;&#x7406;&#x4E00;&#x81F4;&#xFF0C;&#x867D;&#x7136;&#x9700;&#x8981;&#x4E9B;&#x4EE3;&#x7801;&#xFF0C;&#x4F46;&#x662F;&#x8FD9;&#x4E9B;&#x4EE3;&#x7801;&#x53EF;&#x4EE5;&#x62BD;&#x51FA;&#x4F5C;&#x4E3A;&#x56E2;&#x961F;&#x516C;&#x5171;&#x4EE3;&#x7801;&#xFF0C;&#x57FA;&#x672C;&#x4E0D;&#x9700;&#x8981;&#x8DDF;&#x968F;hessian&#x7248;&#x672C;&#x5347;&#x7EA7;&#x800C;&#x505A;&#x51FA;&#x6539;&#x52A8;&#xFF0C;&#x540C;&#x65F6;&#x5982;&#x679C;&#x6709;&#x9700;&#x8981;&#xFF0C;&#x53EF;&#x4EE5;&#x968F;&#x65F6;&#x6DFB;&#x52A0;&#x81EA;&#x5B9A;&#x4E49;&#x7684;&#x5E8F;&#x5217;&#x5316;&#x65B9;&#x5F0F;&#x3002; &#x4E2A;&#x4EBA;&#x6BD4;&#x8F83;&#x63A8;&#x8350;&#x7B2C;&#x4E09;&#x79CD;&#x65B9;&#x5F0F;&#x3002;","categories":[{"name":"hessian","slug":"hessian","permalink":"https://yyhan.github.io/categories/hessian/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yyhan.github.io/tags/java/"},{"name":"hessian","slug":"hessian","permalink":"https://yyhan.github.io/tags/hessian/"},{"name":"BigDecimal","slug":"BigDecimal","permalink":"https://yyhan.github.io/tags/BigDecimal/"}]},{"title":"hessian 序列化和反序列化","slug":"hessian-序列化和反序列化","date":"2017-06-10T17:29:48.000Z","updated":"2017-06-18T13:21:23.447Z","comments":true,"path":"2017/06/11/hessian-序列化和反序列化/","link":"","permalink":"https://yyhan.github.io/2017/06/11/hessian-序列化和反序列化/","excerpt":"","text":"hessian&#x8BF7;&#x6C42;&#x4EE3;&#x7406; com.caucho.hessian.client.HessianProxy.invoke(Object proxy, Method method, Object []args); // &#x901A;&#x8FC7;&#x4EE3;&#x7406;&#x65B9;&#x5F0F;&#x8C03;&#x7528;&#x8FDC;&#x7A0B;&#x65B9;&#x6CD5;&#xFF0C;&#x5E76;&#x8FD4;&#x56DE;&#x7ED3;&#x679C; com.caucho.hessian.io.Hessian2Input.readReply(Class expectedClass); // &#x8BFB;&#x53D6;&#x8FD4;&#x56DE;&#x7ED3;&#x679C; readObject(Class cl); // &#x8BFB;&#x53D6;&#x4E00;&#x4E2A;&#x7C7B;&#x5BF9;&#x8C61; &#x5E8F;&#x5217;&#x5316;&#x5668;&#x67E5;&#x627E;&#x6D41;&#x7A0B; 1&#x3001;&#x901A;&#x8FC7; SerializerFactory.getObjectSerializer(object.getClass()) &#xFF0C;&#x83B7;&#x53D6;&#x76EE;&#x6807;&#x5BF9;&#x8C61;&#x7684;&#x5E8F;&#x5217;&#x5316;&#x5668; 1.1&#x3001;&#x8C03;&#x7528; SerializerFactory.getSerializer(Class cl) &#x83B7;&#x53D6;&#x76EE;&#x6807;&#x7C7B;&#x7684;&#x5E8F;&#x5217;&#x5316;&#x5668; 1.2&#x3001;&#x5982;&#x679C; _cachedSerializerMap &#x7F13;&#x5B58;&#x4E2D;&#x6709;&#xFF0C;&#x5219;&#x53D6;&#x7F13;&#x5B58;&#x7684;&#x5E8F;&#x5217;&#x5316;&#x5668; 1.3&#x3001;&#x5982;&#x679C;&#x7F13;&#x5B58;&#x6CA1;&#x6709;&#xFF0C;&#x8C03;&#x7528; SerializerFactory.loadSerializer(Class&lt;?&gt; cl) &#x83B7;&#x53D6;&#x76EE;&#x6807;&#x7C7B;&#x7684;&#x5E8F;&#x5217;&#x5316;&#x5668; 1.4&#x3001;&#x904D;&#x5386; SerializerFactory._factories&#xFF08;&#x81EA;&#x884C;&#x6DFB;&#x52A0;&#x7684;&#x5E8F;&#x5217;&#x5316;&#x5668;&#x5DE5;&#x5382;&#xFF09;&#xFF0C;&#x5982;&#x679C;&#x6709;&#x4E00;&#x4E2A;&#x5DE5;&#x5382;&#x63D0;&#x4F9B;&#x76EE;&#x6807;&#x7C7B;&#x7684;&#x5E8F;&#x5217;&#x5316;&#x5668;&#xFF0C;&#x5C31;&#x91C7;&#x7528;&#x8BE5;&#x5DE5;&#x5382;&#x63D0;&#x4F9B;&#x7684;&#x5E8F;&#x5217;&#x5316;&#x5668; 1.5&#x3001;&#x5426;&#x5219;&#xFF08;1.4&#xFF09;&#xFF0C;&#x8C03;&#x7528; SerializerFactory &#x521D;&#x59CB;&#x5316;&#x65F6;&#x6784;&#x9020;&#x7684;&#x4E0A;&#x4E0B;&#x6587;&#x5E8F;&#x5217;&#x5316;&#x5DE5;&#x5382; ContextSerializerFactory.getSerializer(Class cl) &#x67E5;&#x8BE2;&#x5E8F;&#x5217;&#x5316;&#x5668;&#xFF0C;&#x5982;&#x679C;&#x627E;&#x5230;&#xFF0C;&#x5C31;&#x91C7;&#x7528; 1.6&#x3001;&#x5426;&#x5219;&#xFF08;1.5&#xFF09;&#xFF0C;&#x5C31;&#x4F7F;&#x7528;&#x76EE;&#x6807;&#x7C7B;&#x7684;&#x7C7B;&#x52A0;&#x8F7D;&#x5668;&#x6784;&#x9020; ContextSerializerFactory&#xFF0C;&#x5E76;&#x901A;&#x8FC7;&#x8BE5;&#x5E8F;&#x5217;&#x5316;&#x5DE5;&#x5382;&#x7684;getCustomSerializer()&#x67E5;&#x8BE2;&#x5E8F;&#x5217;&#x5316;&#x5668;&#xFF0C;&#x5982;&#x679C;&#x627E;&#x5230;&#xFF0C;&#x5C31;&#x91C7;&#x7528; 1.6.1&#x3001;Class.forName(cl.getName() + &quot;HessianSerializer&quot;, false, cl.getClassLoader())&#x83B7;&#x53D6;&#x5E8F;&#x5217;&#x5316;&#x5668; 1.7&#x3001;&#x5426;&#x5219;&#xFF08;1.6&#xFF09;&#xFF0C;&#x5982;&#x679C;&#x76EE;&#x6807;&#x7C7B;&#x662F;com.caucho.hessian.io.HessianRemoteObject&#x7C7B;&#x578B;&#x6216;&#x5176;&#x5B50;&#x7C7B;&#xFF0C;&#x8FD4;&#x56DE;com.caucho.hessian.io.RemoteSerializer 1.8&#x3001;&#x5426;&#x5219;&#xFF08;1.7&#xFF09;&#xFF0C;&#x5982;&#x679C;&#x76EE;&#x6807;&#x7C7B;&#x662F;com.caucho.burlap.io.BurlapRemoteObject&#x7C7B;&#x578B;&#x6216;&#x5176;&#x5B50;&#x7C7B;&#xFF0C;&#x8FD4;&#x56DE;com.caucho.hessian.io.RemoteSerializer 1.9&#x3001;&#x5426;&#x5219;&#xFF08;1.8&#xFF09;&#xFF0C;&#x5982;&#x679C;&#x76EE;&#x6807;&#x7C7B;&#x62E5;&#x6709;&#x540D;&#x4E3A;writeReplace&#x7684;&#x65E0;&#x53C2;&#x65B9;&#x6CD5;&#xFF0C;&#x5C31;&#x6839;&#x636E;&#x8BE5;&#x65B9;&#x6CD5;&#x6784;&#x9020;&#x4E00;&#x4E2A;WriteReplaceSerializer&#x8FD4;&#x56DE; 1.10&#x3001;&#x5426;&#x5219;&#xFF08;1.9&#xFF09;&#xFF0C;&#x5982;&#x679C;&#x76EE;&#x6807;&#x7C7B;&#x662F;Map&#xFF0C;&#x8FD4;&#x56DE;MapSerializer&#xFF08;&#x61D2;&#x52A0;&#x8F7D;&#xFF09; 1.11&#x3001;&#x5426;&#x5219;&#xFF08;1.10&#xFF09;&#xFF0C;&#x5982;&#x679C;&#x76EE;&#x6807;&#x7C7B;&#x662F;Collection&#xFF0C;&#x8FD4;&#x56DE;CollectionSerializer* &#xFF08;&#x61D2;&#x52A0;&#x8F7D;&#xFF09; 1.12&#x3001;&#x5426;&#x5219;&#xFF08;1.11&#xFF09;&#xFF0C;Array&#x3001;InputStream&#x3001;Iterator&#x3001;Calendar&#x3001;* Enumeration&#x3001;Enum&#x3001;Annotation&#x5206;&#x522B;&#x8FD4;&#x56DE;&#x5BF9;&#x5E94;&#x7684;&#x5185;&#x7F6E;&#x5E8F;&#x5217;&#x5316;&#x5668; 1.13&#x3001;&#x5426;&#x5219;&#xFF08;1.12&#xFF09;&#xFF0C;&#x8C03;&#x7528;SerializerFactory.getDefaultSerializer(Class cl)&#x8FD4;&#x56DE;&#x9ED8;&#x8BA4;&#x7684;&#x5E8F;&#x5217;&#x5316;&#x5668; 1.13.1&#x3001;&#x5982;&#x679C; _defaultSerializer &#x4E0D;&#x4E3A;&#x7A7A;&#xFF0C;&#x5C31;&#x91C7;&#x7528; 1.13.2&#x3001;&#x5982;&#x679C;&#x76EE;&#x6807;&#x7C7B;&#x578B;&#x672A;&#x5B9E;&#x73B0;Serializable&#x63A5;&#x53E3;&#xFF0C;&#x4E14;&#x8BBE;&#x7F6E;&#x4E86;&#x7981;&#x6B62;&#x2018;&#x4E0D;&#x652F;&#x6301;&#x5E8F;&#x5217;&#x5316;&#x7684;&#x7C7B;&#x2019;&#x7684;&#x72B6;&#x6001;_isAllowNonSerializable&#xFF0C;&#x5C06;&#x8DD1;&#x51FA;&#x5F02;&#x5E38;IllegalStateException 1.13.3&#x3001;&#x5982;&#x679C;&#x542F;&#x7528;&#x4E86;&#x4E0D;&#x5B89;&#x5168;&#x7684;&#x5E8F;&#x5217;&#x5316;&#x5668;&#xFF0C;&#x5E76;&#x4E14;&#x76EE;&#x6807;&#x7C7B;&#x6CA1;&#x6709;&#x540D;&#x4E3A;writeReplace&#x7684;&#x65E0;&#x53C2;&#x65B9;&#x6CD5;&#xFF0C;&#x5C31;&#x6784;&#x9020;&#x4E00;&#x4E2A;UnsafeSerializer&#x5E76;&#x8FD4;&#x56DE; 1.13.3.1&#x3001;&#x5982;&#x679C;&#x76EE;&#x6807;&#x7C7B;&#x8BBE;&#x7F6E;&#x4E86;&#x6CE8;&#x89E3;HessianUnshared&#xFF08;&#x4E0D;&#x68C0;&#x6D4B;&#x91CD;&#x590D;&#x6216;&#x5FAA;&#x73AF;&#x5F15;&#x7528;&#xFF09;&#xFF0C;&#x6784;&#x9020;&#x4E00;&#x4E2A;UnsafeUnsharedSerializer&#x5E76;&#x8FD4;&#x56DE; 1.13.3.2&#x3001;&#x5426;&#x5219;&#xFF0C;&#x6784;&#x9020;&#x4E00;&#x4E2A;UnsafeSerializer&#x5E76;&#x8FD4;&#x56DE; 1.13.4&#x3001;&#x5426;&#x5219;&#xFF0C;&#x6784;&#x9020;&#x4E00;&#x4E2A;JavaSerializer&#x5E76;&#x8FD4;&#x56DE; 1.13.4.1&#x3001;&#x5982;&#x679C;&#x76EE;&#x6807;&#x7C7B;&#x8BBE;&#x7F6E;&#x4E86;&#x6CE8;&#x89E3;HessianUnshared&#xFF08;&#x4E0D;&#x68C0;&#x6D4B;&#x91CD;&#x590D;&#x6216;&#x5FAA;&#x73AF;&#x5F15;&#x7528;&#xFF09;&#xFF0C;&#x6784;&#x9020;&#x4E00;&#x4E2A;JavaUnsharedSerializer&#x5E76;&#x8FD4;&#x56DE; 1.13.4.2&#x3001;&#x5426;&#x5219;&#xFF0C;&#x6784;&#x9020;&#x4E00;&#x4E2A;JavaSerializer&#x5E76;&#x8FD4;&#x56DE; 1.4&#x3001;&#x5C06;&#x5F97;&#x5230;&#x7684;&#x5E8F;&#x5217;&#x5316;&#x5668;&#x653E;&#x5165;&#x7F13;&#x5B58; JavaSerializer &#x548C; UnsafeSerializer &#x7684;&#x533A;&#x522B;&#xFF1A; JavaSerializer&#xFF1A;&#x901A;&#x8FC7;&#x53CD;&#x5C04;&#x673A;&#x5236;&#x83B7;&#x53D6;&#x5B57;&#x6BB5;&#x503C; UnsafeSerializer&#xFF1A;&#x901A;&#x8FC7;sun.misc.Unsafe&#x83B7;&#x53D6;&#x5B57;&#x6BB5;&#x7684;&#x503C; &#x53CD;&#x5E8F;&#x5217;&#x5316;&#x8FC7;&#x7A0B; 1&#x3001;&#x4F7F;&#x7528;InputStream&#x6784;&#x9020;AbstractHessianInput&#x5BF9;&#x8C61; 2&#x3001;&#x8C03;&#x7528;AbstractHessianInput.readReply(Class expectedClass)&#x8BFB;&#x53D6;&#x4E00;&#x4E2A;&#x54CD;&#x5E94;&#x5BF9;&#x8C61; 3&#x3001;&#x5982;&#x679C;tag=&apos;R&apos;&#xFF0C;&#x8C03;&#x7528;readObject(Class cl)&#x8BFB;&#x53D6;&#x4E00;&#x4E2A;&#x5BF9;&#x8C61; 4&#x3001;readObjectDefinition(Class&lt;?&gt; cl)&#x8BFB;&#x53D6;&#x4E00;&#x4E2A;&#x5BF9;&#x8C61;&#x5B9A;&#x4E49; 4.1&#x3001;SerializerFactory.getObjectDeserializer(String type, Class cl)&#x83B7;&#x53D6;&#x4E00;&#x4E2A;&#x53CD;&#x5E8F;&#x5217;&#x5316;&#x5668;&#xFF0C;&#x5982;&#x679C;cl&#x4E3A;null &#x6216; cl&#x548C;&#x5E8F;&#x5217;&#x5316;&#x5668;&#x652F;&#x6301;&#x7684;&#x7C7B;&#x578B;&#x4E00;&#x81F4; &#x7B49;&#x60C5;&#x51B5;&#x76F4;&#x63A5;&#x4F7F;&#x7528;&#x8BE5;&#x53CD;&#x5E8F;&#x5217;&#x5316;&#x5668; 4.1.1&#x3001;SerializerFactory.getObjectDeserializer(String type)&#x83B7;&#x53D6;&#x4E00;&#x4E2A;&#x53CD;&#x5E8F;&#x5217;&#x5316;&#x5668; 4.1.1.1&#x3001;SerializerFactory.getDeserializer(String type)&#x83B7;&#x53D6;&#x4E00;&#x4E2A;&#x53CD;&#x5E8F;&#x5217;&#x5316;&#x5668; 4.1.1.1.1&#x3001;&#x5982;&#x679C;type&#x4E3A;[&#x5F00;&#x5934;&#xFF0C;&#x5C31;&#x6784;&#x9020;&#x4E00;&#x4E2A;&#x6570;&#x7EC4;&#x53CD;&#x5E8F;&#x5217;&#x5316;&#x5668;&#xFF0C;&#x6570;&#x7EC4;&#x5185;&#x5BB9;&#xFF0C;&#x4F7F;&#x7528;type.substring(1)&#xFF0C;&#x4F5C;&#x4E3A;&#x53C2;&#x6570;&#x8C03;&#x7528;&#x672C;&#x65B9;&#x6CD5;&#x83B7;&#x53D6;&#x3002; 4.1.1.1.2&#x3001;&#x5426;&#x5219;&#x901A;&#x8FC7;&#x53CD;&#x5C04;Class.forName&#x5F97;&#x5230;type&#x5BF9;&#x5E94;&#x7684;&#x5B9E;&#x4F53;&#x7C7B;&#xFF0C;&#x7136;&#x540E;&#x4F7F;&#x7528;&#x5F97;&#x5230;&#x7684;&#x5B9E;&#x4F53;&#x7C7B;&#x8C03;&#x7528;SerializerFactory.getDeserializer(Class cl)&#x83B7;&#x53D6;&#x4E00;&#x4E2A;&#x53CD;&#x5E8F;&#x5217;&#x5316;&#x5668; 4.2&#x3001;&#x5982;&#x679C;4.1.1&#x5F97;&#x5230;&#x7684;&#x53CD;&#x5E8F;&#x5217;&#x5316;&#x5668;&#x4E0D;&#x7B26;&#x5408;&#x8981;&#x6C42;&#xFF0C;&#x5C31;&#x8C03;&#x7528;SerializerFactory.getDeserializer(Class cl)&#x83B7;&#x53D6;&#x4E00;&#x4E2A;&#x53CD;&#x5E8F;&#x5217;&#x5316;&#x5668; 4.2.1&#x3001;&#x8C03;&#x7528;SerializerFactory.loadDeserializer(Class cl)&#x83B7;&#x53D6;&#x4E00;&#x4E2A;&#x53CD;&#x5E8F;&#x5217;&#x5316;&#x5668; 4.2.1.1&#x3001;&#x904D;&#x5386; SerializerFactory._factories&#xFF08;&#x81EA;&#x884C;&#x6DFB;&#x52A0;&#x7684;&#x5E8F;&#x5217;&#x5316;&#x5668;&#x5DE5;&#x5382;&#xFF09;&#xFF0C;&#x5982;&#x679C;&#x6709;&#x4E00;&#x4E2A;&#x5DE5;&#x5382;&#x63D0;&#x4F9B;&#x76EE;&#x6807;&#x7C7B;&#x7684;&#x53CD;&#x5E8F;&#x5217;&#x5316;&#x5668;&#xFF0C;&#x5C31;&#x91C7;&#x7528;&#x8BE5;&#x5DE5;&#x5382;&#x63D0;&#x4F9B;&#x7684;&#x53CD;&#x5E8F;&#x5217;&#x5316;&#x5668; 4.2.1.2&#x3001;&#x8C03;&#x7528; SerializerFactory &#x521D;&#x59CB;&#x5316;&#x65F6;&#x6784;&#x9020;&#x7684;&#x4E0A;&#x4E0B;&#x6587;&#x5E8F;&#x5217;&#x5316;&#x5DE5;&#x5382; ContextSerializerFactory.getDeserializer(String className) &#x67E5;&#x8BE2;&#x5E8F;&#x53CD;&#x5217;&#x5316;&#x5668;&#xFF0C;&#x5982;&#x679C;&#x627E;&#x5230;&#xFF0C;&#x5C31;&#x91C7;&#x7528; 4.2.1.3&#x3001;&#x4F7F;&#x7528;&#x76EE;&#x6807;&#x7C7B;&#x7684;&#x7C7B;&#x52A0;&#x8F7D;&#x5668;&#x6784;&#x9020; ContextSerializerFactory&#xFF0C;&#x5E76;&#x901A;&#x8FC7;&#x8BE5;&#x5E8F;&#x5217;&#x5316;&#x5DE5;&#x5382;&#x7684;getCustomDeserializer()&#x67E5;&#x8BE2;&#x5E8F;&#x5217;&#x5316;&#x5668;&#xFF0C;&#x5982;&#x679C;&#x627E;&#x5230;&#xFF0C;&#x5C31;&#x91C7;&#x7528; 4.2.1.4&#x3001;Collection&#x3001;Map&#x3001;Iterator&#x3001;Annotation&#x3001;Interface&#xFF08;&#x4F7F;&#x7528;ObjectDeserializer&#xFF09;&#x3001;Array&#x3001;Enumeration&#x3001;Enum&#x3001;Class&#x90FD;&#x6709;&#x5185;&#x7F6E;&#x5BF9;&#x5E94;&#x7684;&#x53CD;&#x5E8F;&#x5217;&#x5316;&#x5668; 4.2.1.5&#x3001;&#x8C03;&#x7528;SerializerFactory.getDefaultDeserializer(Class cl)&#x8FD4;&#x56DE;&#x9ED8;&#x8BA4;&#x7684;&#x5E8F;&#x5217;&#x5316;&#x5668; 4.2.1.5.1&#x3001;&#x5982;&#x679C;&#x76EE;&#x6807;&#x7C7B;&#x578B;&#x4E3A;InputStream&#xFF0C;&#x4F7F;&#x7528;InputStreamDeserializer.DESER&#x4F5C;&#x4E3A;&#x53CD;&#x5E8F;&#x5217;&#x5316;&#x5668; 4.2.1.5.2&#x3001;&#x5982;&#x679C;&#x542F;&#x7528;&#x4E86;&#x4E0D;&#x5B89;&#x5168;&#x7684;&#x5E8F;&#x5217;&#x5316;&#x5668;&#xFF0C;&#x4F7F;&#x7528;UnsafeDeserializer(cl) 4.2.1.5.2.1&#x3001;&#x5982;&#x679C;&#x76EE;&#x6807;&#x7C7B;&#x578B;&#x6709;&#x540D;&#x4E3A;readResolve&#x7684;&#x65E0;&#x53C2;&#x65B9;&#x6CD5;&#xFF0C;&#x6807;&#x8BB0;_readResolve.setAccessible(true) 4.2.1.5.3&#x3001;&#x5426;&#x5219;&#xFF0C;&#x4F7F;&#x7528;JavaDeserializer(cl) 4.2.1.5.3.1&#x3001;&#x5982;&#x679C;&#x76EE;&#x6807;&#x7C7B;&#x578B;&#x6709;&#x540D;&#x4E3A;readResolve&#x7684;&#x65E0;&#x53C2;&#x65B9;&#x6CD5;&#xFF0C;&#x6807;&#x8BB0;_readResolve.setAccessible(true) 5&#x3001;readObjectInstance(Class&lt;?&gt; cl, ObjectDefinition def)&#x6839;&#x636E;&#x4E0A;&#x4E00;&#x6B65;&#x7684;&#x7ED3;&#x679C;&#x8BFB;&#x53D6;&#x4E00;&#x4E2A;&#x5BF9;&#x8C61;&#x5B9E;&#x4F8B; &#x7279;&#x6B8A;&#x95EE;&#x9898; &#x5BA2;&#x6237;&#x7AEF;&#x4E0E;&#x670D;&#x52A1;&#x7AEF;&#x5B57;&#x6BB5;&#x4E0D;&#x4E00;&#x81F4; 1&#x3001;&#x5BA2;&#x6237;&#x7AEF;&#x591A;&#x4E00;&#x4E2A;&#x5B57;&#x6BB5;&#xFF0C;&#x8BE5;&#x5B57;&#x6BB5;&#x53D6;JVM&#x9ED8;&#x8BA4;&#x503C; 2&#x3001;&#x5BA2;&#x6237;&#x7AEF;&#x7F3A;&#x5931;&#x5B57;&#x6BB5;&#xFF0C;&#x8BE5;&#x5B57;&#x6BB5;&#x4E0D;&#x89E3;&#x6790; 3&#x3001;&#x89E3;&#x6790;&#x65F6;&#x8BFB;&#x53D6;&#x5BF9;&#x8C61;&#x7C7B;&#x578B;&#xFF0C;&#x4EE5;&#x8FD4;&#x56DE;&#x7684;&#x6570;&#x636E;&#x4E2D;&#x6307;&#x5B9A;&#x7684;&#x7C7B;&#x578B;&#x4E3A;&#x51C6;","categories":[{"name":"hessian","slug":"hessian","permalink":"https://yyhan.github.io/categories/hessian/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yyhan.github.io/tags/java/"},{"name":"hessian","slug":"hessian","permalink":"https://yyhan.github.io/tags/hessian/"}]},{"title":"Spring @Value注解","slug":"Spring-Value","date":"2017-05-16T15:45:22.000Z","updated":"2017-06-18T13:21:21.385Z","comments":true,"path":"2017/05/16/Spring-Value/","link":"","permalink":"https://yyhan.github.io/2017/05/16/Spring-Value/","excerpt":"","text":"Spring @Value&#x6CE8;&#x89E3;&#x7684;&#x7528;&#x6CD5;&#x3002; &#x57FA;&#x672C;&#x4F7F;&#x7528; 1@Value(&quot;${user.name}&quot;) SpELl&#x65B9;&#x5F0F; systemProperties&#x662F;spring&#x81EA;&#x52A8;&#x6CE8;&#x5165;&#x7684;&#x7CFB;&#x7EDF;&#x53D8;&#x91CF;&#x96C6;&#x5408;&#xFF0C;&#x4E5F;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x81EA;&#x5DF1;&#x6CE8;&#x5165;&#x7684;&#x53D8;&#x91CF;&#x96C6;&#x5408;&#x3002; 1@Value(&quot;#{systemProperties[&apos;user.name&apos;]}&quot;) &#x8BBE;&#x7F6E;&#x9ED8;&#x8BA4;&#x503C; 1@Value(&quot;${user.name:root}&quot;) SpEl&#x65B9;&#x5F0F;&#x8BBE;&#x7F6E;&#x9ED8;&#x8BA4;&#x503C; 1@Value(&quot;#{systemProperties[&apos;user.name&apos;] ?: &apos;root&apos;}&quot;) //&#x6CE8;&#x610F;&#x5B57;&#x7B26;&#x4E32;&#x8981;&#x52A0;&#x5355;&#x5F15;&#x53F7; &#x8BBE;&#x7F6E;null&#x503C; 123@Value(&quot;${user.name:#{null}}&quot;) //&#x6DF7;&#x5408;&#x65B9;&#x5F0F;@Value(&quot;#{systemProperties[&apos;user.name&apos;] ?: null}&quot;) //&#x7EAF;SpEl&#x65B9;&#x5F0F; &#x68C0;&#x67E5;&#x662F;&#x5426;&#x4E3A;null&#x6216;&#x8005;&#x7A7A;&#x5B57;&#x7B26;&#x4E32; 1@Value(value = &quot;#{systemProperties[&apos;user.name&apos;] == null ? null : &apos;&apos;.equals(systemProperties[&apos;user.name&apos;]) ? null : systemProperties[&apos;user.name&apos;]}&quot;)","categories":[{"name":"spring","slug":"spring","permalink":"https://yyhan.github.io/categories/spring/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yyhan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://yyhan.github.io/tags/spring/"},{"name":"value","slug":"value","permalink":"https://yyhan.github.io/tags/value/"},{"name":"注解","slug":"注解","permalink":"https://yyhan.github.io/tags/注解/"}]},{"title":"Log4j2配置","slug":"Log4j2配置","date":"2017-05-16T15:25:40.000Z","updated":"2017-09-24T15:01:55.594Z","comments":true,"path":"2017/05/16/Log4j2配置/","link":"","permalink":"https://yyhan.github.io/2017/05/16/Log4j2配置/","excerpt":"","text":"&#x4F7F;&#x7528;xml&#x65B9;&#x5F0F;&#x521D;&#x59CB;&#x5316;Log4j2 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt; &lt;Properties&gt; &lt;Property name=&quot;log.dir&quot;&gt;D:/logs/demo&lt;/Property&gt; &lt;/Properties&gt; &lt;Appenders&gt; &lt;!-- &#x63A7;&#x5236;&#x53F0;appender --&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger - %msg %ex %n&quot;/&gt; &lt;/Console&gt; &lt;RollingFile name=&quot;appFileLog&quot; fileName=&quot;${log.dir}/app.log&quot; filePattern=&quot;${log.dir}/app-%d{yyyy-MM-dd}.log&quot;&gt; &lt;PatternLayout pattern=&quot;%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger - %msg %ex %n&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy /&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;!-- &#x9ED8;&#x8BA4;&#x65E5;&#x5FD7;&#x7EA7;&#x522B; debug --&gt; &lt;Root level=&quot;debug&quot;&gt; &lt;!-- &#x9ED8;&#x8BA4;&#x65E5;&#x5FD7;&#x8F93;&#x51FA;&#x5230; &#x63A7;&#x5236;&#x53F0; --&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;AppenderRef ref=&quot;appFileLog&quot; /&gt; &lt;/Root&gt; &lt;!-- &#x6253;&#x5370;spring info&#x65E5;&#x5FD7; --&gt; &lt;logger name=&quot;org.springframework&quot; level=&quot;info&quot; /&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; &#x4F7F;&#x7528;java&#x65B9;&#x5F0F;&#x521D;&#x59CB;&#x5316;Log4j2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166package com.demo.utils.log;import org.apache.logging.log4j.Level;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import org.apache.logging.log4j.core.Appender;import org.apache.logging.log4j.core.LoggerContext;import org.apache.logging.log4j.core.appender.ConsoleAppender;import org.apache.logging.log4j.core.config.*;import org.apache.logging.log4j.core.config.builder.api.ConfigurationBuilder;import org.apache.logging.log4j.core.config.builder.api.ConfigurationBuilderFactory;import org.apache.logging.log4j.core.config.builder.api.RootLoggerComponentBuilder;import org.apache.logging.log4j.core.config.builder.impl.BuiltConfiguration;import org.apache.logging.log4j.core.layout.PatternLayout;import java.util.Map;/** * log4j2 &#x5DE5;&#x5177;&#x7C7B;&#xFF0C;&#x63D0;&#x4F9B;java&#x65B9;&#x5F0F;&#x521D;&#x59CB;&#x5316;log4j2&#xFF0C;&#x6216;&#x8005;&#x5176;&#x4ED6;&#x64CD;&#x4F5C;log4j2&#x7684;&#x65B9;&#x6CD5; */public class Log4jHelper { private static LoggerContext loggerContext = null; public static final String DEFAULT_APPENDER = &quot;STDOUT&quot;; public static void resetSimpleRootLogger(String rootLoggerLevel) { resetSimpleRootLogger(rootLoggerLevel, true); } /** * &#x91CD;&#x7F6E;&#x4E00;&#x4E2A;&#x7B80;&#x5316;&#x7684;rootLogger&#xFF0C;&#x5C06;&#x6240;&#x6709;&#x65E5;&#x5FD7;&#x8F93;&#x51FA;&#x7684;&#x63A7;&#x5236;&#x53F0;&#x3002;&#x5F53;&#x65E0;&#x6CD5;&#x786E;&#x5B9A; log4j2 &#x662F;&#x5426;&#x5DF2;&#x7ECF;&#x52A0;&#x8F7D;&#x65F6;&#xFF0C;&#x53EF;&#x7528;&#x6B64;&#x65B9;&#x6CD5;&#x3002; * * @param rootLoggerLevel rootLogger &#x65E5;&#x5FD7;&#x7EA7;&#x522B; * @param isRemoveOldAppender &#x662F;&#x5426;&#x79FB;&#x9664;&#x73B0;&#x6709;&#x7684;appender */ public static void resetSimpleRootLogger(String rootLoggerLevel, boolean isRemoveOldAppender) { loggerContext = (LoggerContext) LogManager.getContext(false); Configuration config = loggerContext.getConfiguration(); ConsoleAppender.Builder builder = ConsoleAppender.newBuilder(); builder.withName(DEFAULT_APPENDER).withLayout(PatternLayout.newBuilder().withPattern(&quot;%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger - %msg %ex %n&quot;).build()); Appender stdoutAppender = builder.setTarget(ConsoleAppender.Target.SYSTEM_OUT).build(); config.addAppender(stdoutAppender); LoggerConfig rootLoggerConfig = config.getRootLogger(); if (isRemoveOldAppender) { Map&lt;String, Appender&gt; appenderMap = rootLoggerConfig.getAppenders(); if (!appenderMap.isEmpty()) { for (String key : appenderMap.keySet()) { rootLoggerConfig.removeAppender(key); } } } rootLoggerConfig.setLevel(Level.valueOf(rootLoggerLevel)); rootLoggerConfig.addAppender(stdoutAppender, Level.DEBUG, null); loggerContext.updateLoggers(); } /** * &#x521D;&#x59CB;&#x5316;Log4j2 &#xFF0C;&#x9700;&#x8981;&#x786E;&#x4FDD;&#x8BE5;&#x65B9;&#x6CD5;&#x5728;&#x6240;&#x6709;&#x65E5;&#x5FD7;&#x64CD;&#x4F5C;&#x524D;&#x6267;&#x884C; * * @param rootLoggerLevel &#x9876;&#x7EA7;logger &#x65E5;&#x5FD7;&#x7EA7;&#x522B; */ public static void init(String rootLoggerLevel) { ConfigurationBuilder&lt;BuiltConfiguration&gt; builder = ConfigurationBuilderFactory.newConfigurationBuilder(); builder.setStatusLevel(Level.WARN); builder.setConfigurationName(&quot;Log4jHelper&quot;); builder.add( builder.newAppender(DEFAULT_APPENDER, &quot;CONSOLE&quot;) .addAttribute(&quot;target&quot;, ConsoleAppender.Target.SYSTEM_OUT) .add( builder.newLayout(&quot;PatternLayout&quot;) .addAttribute(&quot;pattern&quot;, &quot;%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg %ex %n&quot;) )); builder.add(builder.newLogger(&quot;org.apache.logging.log4j&quot;, Level.DEBUG) .add(builder.newAppenderRef(DEFAULT_APPENDER))); builder.add(builder.newRootLogger(Level.DEBUG).add(builder.newAppenderRef(&quot;STDOUT&quot;))); loggerContext = Configurator.initialize(builder.build()); } public static void init() { init(&quot;DEBUG&quot;); } /** * &#x5411;&#x5F53;&#x524D; log4j2 &#x4E0A;&#x4E0B;&#x6587;&#x4E2D;&#x6DFB;&#x52A0;&#x4E00;&#x4E2A;logger&#xFF0C;&#x8BE5;logger&#x4F1A;&#x88AB;&#x8F93;&#x51FA;&#x5230;&#x63A7;&#x5236;&#x53F0;&#x3002; * * @param name logger &#x540D;&#x79F0; * @param level &#x65E5;&#x5FD7;&#x7EA7;&#x522B; */ public static void addLogger(String name, String level) { addLogger(name, level, DEFAULT_APPENDER); } /** * &#x5411;&#x5F53;&#x524D; log4j2 &#x4E0A;&#x4E0B;&#x6587;&#x4E2D;&#x6DFB;&#x52A0;&#x4E00;&#x4E2A;logger * * @param name logger &#x540D;&#x79F0; * @param level &#x65E5;&#x5FD7;&#x7EA7;&#x522B; * @param appenderName appenderName */ public static void addLogger(String name, String level, String appenderName) { final Configuration config = loggerContext.getConfiguration(); Appender stdoutAppender = config.getAppender(appenderName); LoggerConfig loggerConfig = LoggerConfig.createLogger(false, Level.DEBUG, name, &quot;false&quot;, new AppenderRef[]{}, new Property[]{}, config, null); loggerConfig.addAppender(stdoutAppender, Level.valueOf(level), null); loggerConfig.setLevel(Level.valueOf(level)); loggerConfig.setAdditive(false); config.addLogger(name, loggerConfig); loggerContext.updateLoggers(); } /** * &#x8BBE;&#x7F6E;root&#x65E5;&#x5FD7;&#x7EA7;&#x522B; * * @param loggerName * @param level */ public static void setRootLevel(String level) { Configuration config = loggerContext.getConfiguration(); LoggerConfig loggerConfig = config.getRootLogger(); loggerConfig.setLevel(Level.valueOf(level)); loggerContext.updateLoggers(); } /** * &#x8BBE;&#x7F6E;&#x65E5;&#x5FD7;&#x7EA7;&#x522B; * * @param loggerName * @param level */ public static void setLevel(String loggerName, String level) { Configuration config = loggerContext.getConfiguration(); LoggerConfig loggerConfig = config.getLoggerConfig(loggerName); loggerConfig.setLevel(Level.valueOf(level)); loggerContext.updateLoggers(); } public static void main(String[] args) {// Log4jHelper.resetSimpleRootLogger(&quot;debug&quot;); Log4jHelper.init();// Log4jHelper.addLogger(&quot;accessLog&quot;, &quot;info&quot;); Logger accessLog = LogManager.getLogger(&quot;accessLog&quot;); accessLog.debug(&quot;accessLog: debug&quot;); accessLog.info(&quot;accessLog: info&quot;); accessLog.error(&quot;accessLog: error&quot;); Logger rootLogger = LogManager.getRootLogger(); rootLogger.debug(&quot;rootLogger: debug&quot;); rootLogger.info(&quot;rootLogger: info&quot;); rootLogger.error(&quot;rootLogger: error&quot;); }}","categories":[{"name":"log4j2","slug":"log4j2","permalink":"https://yyhan.github.io/categories/log4j2/"}],"tags":[{"name":"log4j2","slug":"log4j2","permalink":"https://yyhan.github.io/tags/log4j2/"},{"name":"java","slug":"java","permalink":"https://yyhan.github.io/tags/java/"}]},{"title":"SSH配置和使用","slug":"ssh配置和使用","date":"2017-05-16T13:18:47.000Z","updated":"2017-06-26T15:33:01.472Z","comments":true,"path":"2017/05/16/ssh配置和使用/","link":"","permalink":"https://yyhan.github.io/2017/05/16/ssh配置和使用/","excerpt":"","text":"&#x751F;&#x6210;ssh&#x5BC6;&#x94A5; &#x5728;linux&#x4E0A;&#x751F;&#x6210; &#x5728;linux&#x4E0A;&#xFF0C;&#x4F7F;&#x7528;ssh-keygen&#x547D;&#x4EE4;&#x751F;&#x6210;ssh&#x5BC6;&#x94A5;&#x3002; 1ssh-keygen -t rsa &#x4F7F;&#x7528;xshell&#x751F;&#x6210; &#x5DE5;&#x5177; &gt; &#x65B0;&#x5EFA;&#x7528;&#x6237;&#x5BC6;&#x94A5;&#x751F;&#x6210;&#x5411;&#x5BFC;&#xFF0C;&#x7136;&#x540E;&#x6839;&#x636E;&#x5411;&#x5BFC;&#x751F;&#x6210;&#x5BC6;&#x94A5;&#x3002; &#x90E8;&#x7F72;ssh&#x516C;&#x94A5;&#x548C;&#x79C1;&#x94A5; &#x5C06;ssh&#x516C;&#x94A5;&#x8FFD;&#x52A0;&#x5230;&#x76EE;&#x6807;&#x670D;&#x52A1;&#x5668;&#x7684;${remote_user_home}/.ssh/authorized_keys&#x6587;&#x4EF6;&#x4E2D;&#xFF0C;&#x5E76;&#x6307;&#x5B9A;&#x76F8;&#x5173;&#x6587;&#x4EF6;&#x6743;&#x9650;&#xFF1A; &#x6587;&#x4EF6;&#x6216;&#x76EE;&#x5F55; &#x6743;&#x9650; .ssh/ 700 .ssh/authorized_keys 600 &#x66F4;&#x591A;&#x6587;&#x4EF6;&#x6743;&#x9650;&#x8BBE;&#x7F6E;&#x53C2;&#x8003;&#xFF1A;http://man.openbsd.org/ssh.1 &#x539F;&#x6587;&#x6458;&#x8981;&#x5982;&#x4E0B;&#xFF1A; &#x4F7F;&#x7528;ssh&#x767B;&#x5F55;&#x8FDC;&#x7A0B;&#x670D;&#x52A1;&#x5668; &#x4ECE;&#x4E00;&#x53F0;linux&#x670D;&#x52A1;&#x5668;&#x767B;&#x5F55;&#x5230;&#x53E6;&#x4E00;&#x53F0;&#x670D;&#x52A1;&#x5668; &#x4F7F;&#x7528;ssh&#x4ECE;&#x4E00;&#x53F0;linux&#x670D;&#x52A1;&#x5668;&#x767B;&#x5F55;&#x5230;&#x53E6;&#x4E00;&#x53F0;&#x670D;&#x52A1;&#x5668;&#x65F6;&#xFF0C;&#x5FC5;&#x987B;&#x5C06;&#x672C;&#x673A;&#x7684;ssh&#x516C;&#x94A5;&#x8FFD;&#x52A0;&#x5230;&#x76EE;&#x6807;&#x670D;&#x52A1;&#x5668;&#x7684;${remote_user_home}/.ssh/authorized_keys&#x6587;&#x4EF6;&#x4E2D;&#x3002;&#x540C;&#x65F6;&#x5C06;&#x79C1;&#x94A5;&#x653E;&#x7F6E;&#x5728;${local_user_home}/.ssh/id_rsa&#x6587;&#x4EF6;&#x4E2D;&#x3002; &#x5C06;&#x516C;&#x94A5;&#x53D1;&#x9001;&#x5230;&#x8FDC;&#x7A0B;&#x670D;&#x52A1;&#x5668;&#xFF1A; 1ssh-copy-id remote_user@remote_host &#x4F7F;&#x7528;ssh&#x767B;&#x5F55;&#x8FDC;&#x7A0B;&#x670D;&#x52A1;&#x5668;&#xFF1A; 1ssh remote_user@remote_host &#x4ECE;&#x4E00;&#x53F0;windows&#x670D;&#x52A1;&#x5668;&#x767B;&#x5F55;&#x5230;&#x53E6;&#x4E00;&#x53F0;&#x670D;&#x52A1;&#x5668; &#x4F7F;&#x7528;xshell ssh&#x914D;&#x7F6E;&#x591A;&#x4E2A;&#x8FDC;&#x7A0B;&#x4E3B;&#x673A; &#x5F53;&#x4F7F;&#x7528;&#x591A;&#x4E2A;&#x516C;&#x94A5;&#x8BBF;&#x95EE;&#x4E0D;&#x901A;&#x7684;&#x8FDC;&#x7A0B;&#x670D;&#x52A1;&#x5668;&#x65F6;&#xFF0C;&#x5728;${local_user_home}/.ssh/config&#x6587;&#x4EF6;&#x4E2D;&#x6DFB;&#x52A0;&#x5982;&#x4E0B;&#x914D;&#x7F6E;&#xFF1A; 123456789101112Host github.com HostName github.com IdentityFile D:/ssh/yyhan_github.ppk User gitHost git.coding.net HostName git.coding.net IdentityFile D:/ssh/coding_net.ppk User gitHost 192.168.1.* HostName 192.168.1.1 IdentityFile D:/ssh/root_192_168_1_1.ppk User root &#x914D;&#x7F6E;&#x9879;&#x63CF;&#x8FF0;&#x5982;&#x4E0B;&#xFF1A; &#x914D;&#x7F6E;&#x9879; &#x63CF;&#x8FF0; Host &#x4E3B;&#x673A;&#x522B;&#x540D;&#xFF0C;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x6A21;&#x5F0F;&#x5339;&#x914D; HostName &#x4E3B;&#x673A;&#x771F;&#x5B9E;&#x540D;&#x79F0;&#x6216;&#x5730;&#x5740; IdentityFile &#x5BC6;&#x94A5;&#x6587;&#x4EF6;&#x5730;&#x5740; User &#x8FDC;&#x7A0B;&#x4E3B;&#x673A;&#x7528;&#x6237;&#x540D; &#x66F4;&#x591A;&#x914D;&#x7F6E;&#x53C2;&#x8003;&#xFF1A;http://man.openbsd.org/ssh_config.5 &#x9644;&#x5F55; SSH&#x5DE5;&#x5177; openSSH&#xFF08;linux&#xFF09; xShell&#xFF08;windows&#xFF09; secureCRT&#xFF08;windows&#xFF09; FileZilla&#xFF08;windows&#x548C;linux&#xFF09;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;ssh&#x7684;FTP&#x5BA2;&#x6237;&#x7AEF;&#x5DE5;&#x5177; &#x53C2;&#x8003;&#x6587;&#x6863; &#x962E;&#x4E00;&#x5CF0;&#xFF1A;&#x300A;SSH&#x539F;&#x7406;&#x4E0E;&#x8FD0;&#x7528;&#xFF08;&#x4E00;&#xFF09;&#xFF1A;&#x8FDC;&#x7A0B;&#x767B;&#x5F55;&#x300B; &#x962E;&#x4E00;&#x5CF0;&#xFF1A;&#x300A;SSH&#x539F;&#x7406;&#x4E0E;&#x8FD0;&#x7528;&#xFF08;&#x4E8C;&#xFF09;&#xFF1A;&#x8FDC;&#x7A0B;&#x64CD;&#x4F5C;&#x4E0E;&#x7AEF;&#x53E3;&#x8F6C;&#x53D1;&#x300B; OpenSSh&#x5B98;&#x7F51;&#xFF1A;OpenSSH","categories":[{"name":"ssh","slug":"ssh","permalink":"https://yyhan.github.io/categories/ssh/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"https://yyhan.github.io/tags/ssh/"},{"name":"linux","slug":"linux","permalink":"https://yyhan.github.io/tags/linux/"},{"name":"多个远程主机","slug":"多个远程主机","permalink":"https://yyhan.github.io/tags/多个远程主机/"}]},{"title":"tomcat setenv脚本","slug":"tomcat-setenv脚本","date":"2016-12-25T15:18:56.000Z","updated":"2016-12-27T06:52:52.681Z","comments":true,"path":"2016/12/25/tomcat-setenv脚本/","link":"","permalink":"https://yyhan.github.io/2016/12/25/tomcat-setenv脚本/","excerpt":"","text":"setenv.bat(linux&#x4E0B;&#x662F;setenv.sh)&#x6587;&#x4EF6;&#x662F;tomcat&#x7684;&#x81EA;&#x5B9A;&#x4E49;&#x53D8;&#x91CF;&#x811A;&#x672C;&#x6587;&#x4EF6;&#xFF0C;&#x8BE5;&#x811A;&#x672C;&#x6587;&#x4EF6;&#x653E;&#x7F6E;&#x5728;CATALINA_HOME\\bin\\&#x6216;CATALINA_BASE\\bin\\&#x76EE;&#x5F55;&#x4E0B;&#xFF0C;&#x8BE5;&#x6587;&#x4EF6;&#x9700;&#x8981;&#x7528;&#x6237;&#x81EA;&#x5DF1;&#x521B;&#x5EFA;&#x3002;&#x5728;&#x8BE5;&#x6587;&#x4EF6;&#x4E2D;&#x53EF;&#x4EE5;&#x6307;&#x5B9A;java&#x73AF;&#x5883;&#x53D8;&#x91CF;&#x3001;jvm&#x53C2;&#x6570;&#x3001;catalina&#x53C2;&#x6570;&#x7B49;&#x3002;&#x53EF;&#x4EE5;&#x8BBE;&#x7F6E;&#x7684;&#x53C2;&#x6570;&#x5982;&#x4E0B;&#xFF1A; &#x53D8;&#x91CF;&#x540D; &#x63CF;&#x8FF0; CATALINA_HOME tomcat&#x7684;&#x5B89;&#x88C5;&#x76EE;&#x5F55; CATALINA_BASE tomcat&#x5B9E;&#x4F8B;&#x7684;&#x5DE5;&#x4F5C;&#x76EE;&#x5F55; CATALINA_OPTS start&#x3001;run&#x6216;&#x8005;debug&#x547D;&#x4EE4;&#x6267;&#x884C;&#x65F6;&#x7684;Java&#x865A;&#x62DF;&#x673A;&#x53C2;&#x6570;&#x3002;&#x53EA;&#x80FD;&#x88AB;tomcat&#x81EA;&#x8EAB;&#x4F7F;&#x7528;&#xFF0C;&#x4F46;&#x5728;stop&#x548C;version&#x547D;&#x4EE4;&#x6267;&#x884C;&#x65F6;&#x4E0D;&#x4F7F;&#x7528;&#x3002;&#x6CE8;&#x610F;&#x533A;&#x5206;JAVA_OPTS JAVA_HOME Java&#x5F00;&#x53D1;&#x5DE5;&#x5177;&#x5B89;&#x88C5;&#x8DEF;&#x5F84;&#xFF0C;&#x4EC5;&#x5728;&#x4F7F;&#x7528;debug&#x53C2;&#x6570;&#x542F;&#x52A8;&#x65F6;&#x6709;&#x7528; JRE_HOME Java&#x8FD0;&#x884C;&#x65F6;&#x5B89;&#x88C5;&#x8DEF;&#x5F84;&#xFF0C;&#x5982;&#x679C;&#x8BE5;&#x53C2;&#x6570;&#x4E3A;&#x7A7A;&#xFF0C;&#x5C06;&#x4F7F;&#x7528;JAVA_HOME&#x7684;&#x503C;&#xFF0C;&#x5982;&#x679C;JAVA_HOME&#x548C;JRE_HOME&#x90FD;&#x8BBE;&#x7F6E;&#x4E86;&#xFF0C;&#x5C06;&#x4F7F;&#x7528;JRE_HOME JAVA_OPTS &#x7528;&#x4E8E;&#x6267;&#x884C;&#x4EFB;&#x4F55;&#x547D;&#x4EE4;&#x65F6;&#x7684;Java&#x865A;&#x62DF;&#x673A;&#x53C2;&#x6570;&#xFF0C;&#x65E2;&#x80FD;&#x88AB;tomcat&#x81EA;&#x8EAB;&#x4F7F;&#x7528;&#xFF0C;&#x4E5F;&#x5728;stop&#x548C;version&#x547D;&#x4EE4;&#x6267;&#x884C;&#x65F6;&#x4F7F;&#x7528;&#x3002;&#x6CE8;&#x610F;&#x533A;&#x5206;CATALINA_OPTS LOGGING_CONFIG tomcat&#x65E5;&#x5FD7;&#x914D;&#x7F6E;&#x53D8;&#x91CF;&#x3002;&#x4F8B;&#x5982;&#xFF1A; set LOGGING_CONFIG=&quot;-Djava.util.logging.config.file=%CATALINA_BASE%\\conf\\logging.properties&quot; LOGGING_MANAGER tomcat&#x65E5;&#x5FD7;&#x7BA1;&#x7406;&#x53D8;&#x91CF;&#x3002;&#x4F8B;&#x5982;&#xFF1A; set LOGGING_MANAGER=&quot;-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager&quot; &#x4EE5;&#x4E0A;&#x53EA;&#x662F;&#x5E38;&#x7528;&#x7684;&#x53D8;&#x91CF;&#xFF0C;&#x5173;&#x4E8E;setenv&#x811A;&#x672C;&#x7684;&#x66F4;&#x591A;&#x8BE6;&#x7EC6;&#x5185;&#x5BB9;&#x8BF7;&#x53C2;&#x8003;CATALINA_HOME\\bin\\&#x76EE;&#x5F55;&#x4E0B;&#x7684;catalina.bat&#x6216;catalina.sh&#x6587;&#x4EF6;&#x4E2D;&#x7684;&#x4ECB;&#x7ECD;&#x3002; &lt;!-- more --&gt; setenv.bat&#x6587;&#x4EF6;&#x793A;&#x4F8B; 123456789101112131415@echo offecho ======== setenv start ========rem &#x8BBE;&#x7F6E;JRE&#x6839;&#x76EE;&#x5F55;set JRE_HOME=D:\\Program Files\\Java\\jdk1.8.0_102\\jrerem &#x8BBE;&#x7F6E;JAVA&#x6839;&#x76EE;&#x5F55;set JAVA_HOME=D:\\Program Files\\Java\\jdk1.8.0_102rem &#x8BBE;&#x7F6E;JAVA_OPTSset JAVA_OPTS=%JAVA_OPTS%rem &#x8BBE;&#x7F6E;CATALINA_OPTSset CATALINA_OPTS=-Dfile.encoding=UTF-8 -Duser.timezone=GMT+8echo Using JRE_HOME: %JRE_HOME%echo Using JAVA_HOME: %JAVA_HOME%echo Using JAVA_OPTS: %JAVA_OPTS%echo Using CATALINA_OPTS: %CATALINA_OPTS%echo ======== setenv over ======== &#x5173;&#x4E8E;CATALINA_HOME &#x548C; CATALINA_BASE CATALINA_HOME&#x662F;tomcat&#x7684;&#x5B89;&#x88C5;&#x76EE;&#x5F55;&#xFF0C;CATALINA_BASE&#x662F;tomcat&#x5B9E;&#x4F8B;&#x7684;&#x5DE5;&#x4F5C;&#x76EE;&#x5F55;&#x3002;&#x5B89;&#x88C5;&#x76EE;&#x5F55;&#x53EA;&#x6709;&#x4E00;&#x4E2A;&#xFF0C;&#x4F46;&#x662F;&#x5B9E;&#x4F8B;&#x53EF;&#x4EE5;&#x6709;&#x591A;&#x4E2A;&#x3002; CATALINA_BASE&#x5305;&#x542B;&#x4EE5;&#x4E0B;&#x76EE;&#x5F55;&#x548C;&#x6587;&#x4EF6;&#xFF1A; bin - &#x53EA;&#x5305;&#x542B;&#x4EE5;&#x4E0B;&#x6587;&#x4EF6;: * setenv.sh (*nix) or setenv.bat (Windows), * tomcat-juli.jar The setenv scripts were described above. The tomcat-juli library is documented in the Logging chapter in the User Guide. conf - &#x670D;&#x52A1;&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x76EE;&#x5F55; (including server.xml) lib - &#x5E93;&#x6587;&#x4EF6;&#x76EE;&#x5F55;&#x3002;&#x5EFA;&#x8BAE;&#x5C06;&#x81EA;&#x5DF1;&#x7684;&#x548C;&#x7B2C;&#x4E09;&#x65B9;&#x7684;&#x5E93;&#x6587;&#x4EF6;&#x653E;&#x7F6E;&#x5728;&#x8BE5;&#x76EE;&#x5F55;&#x4E0B; logs - &#x65E5;&#x5FD7;&#x548C;&#x8F93;&#x51FA;&#x76EE;&#x5F55; webapps - &#x81EA;&#x52A8;&#x52A0;&#x8F7D;&#x7684;web&#x5E94;&#x7528;&#x76EE;&#x5F55; work - web&#x5E94;&#x7528;&#x7684;&#x4E34;&#x65F6;&#x5DE5;&#x4F5C;&#x76EE;&#x5F55; temp - JVM&#x4E34;&#x65F6;&#x6587;&#x4EF6;&#x76EE;&#x5F55;(java.io.tmpdir) CATALINA_HOME&#x5305;&#x542B;&#x4EE5;&#x4E0B;&#x76EE;&#x5F55;&#x548C;&#x6587;&#x4EF6;&#xFF1A; bin - &#x542F;&#x52A8;&#x548C;&#x5173;&#x95ED;&#x811A;&#x672C;&#x6587;&#x4EF6;&#x76EE;&#x5F55; &#x5F53;&#x4EE5;&#x4E0B;&#x6587;&#x4EF6;&#x4E0D;&#x5728;`CATALINA_BASE/bin`&#x76EE;&#x5F55;&#x65F6;&#x5C06;&#x4F1A;&#x88AB;&#x4F7F;&#x7528;: setenv.sh (*nix), setenv.bat (Windows), tomcat-juli.jar lib - &#x5E93;&#x6587;&#x4EF6;&#x76EE;&#x5F55;&#x3002;&#x5EFA;&#x8BAE;&#x53EA;&#x653E;&#x7F6E;&#x6807;&#x51C6;tomcat&#x5E93;&#x6587;&#x4EF6; &#x5173;&#x4E8E;CATALINA_HOME &#x548C; CATALINA_BASE&#x53EF;&#x4EE5;&#x53C2;&#x8003;RUNNING.txt &#x5176;&#x4E2D;&#x5173;&#x4E8E;&#x8FD9;&#x4E24;&#x4E2A;&#x53C2;&#x6570;&#x7684;&#x539F;&#x6587;&#x63CF;&#x8FF0;&#x5982;&#x4E0B;&#xFF1A; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354==================================================Advanced Configuration - Multiple Tomcat Instances==================================================In many circumstances, it is desirable to have a single copy of a Tomcatbinary distribution shared among multiple users on the same server. To makethis possible, you can set the CATALINA_BASE environment variable to thedirectory that contains the files for your &apos;personal&apos; Tomcat instance.When running with a separate CATALINA_HOME and CATALINA_BASE, the filesand directories are split as following:In CATALINA_BASE: * bin - Only the following files: * setenv.sh (*nix) or setenv.bat (Windows), * tomcat-juli.jar The setenv scripts were described above. The tomcat-juli library is documented in the Logging chapter in the User Guide. * conf - Server configuration files (including server.xml) * lib - Libraries and classes, as explained below * logs - Log and output files * webapps - Automatically loaded web applications * work - Temporary working directories for web applications * temp - Directory used by the JVM for temporary files (java.io.tmpdir)In CATALINA_HOME: * bin - Startup and shutdown scripts The following files will be used only if they are absent in CATALINA_BASE/bin: setenv.sh (*nix), setenv.bat (Windows), tomcat-juli.jar * lib - Libraries and classes, as explained belowIn the default configuration the JAR libraries and classes both inCATALINA_BASE/lib and in CATALINA_HOME/lib will be added to the commonclasspath, but the ones in CATALINA_BASE will be added first and thus willbe searched first.The idea is that you may leave the standard Tomcat libraries inCATALINA_HOME/lib and add other ones such as database drivers intoCATALINA_BASE/lib.","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://yyhan.github.io/categories/工具使用/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"https://yyhan.github.io/tags/tomcat/"},{"name":"setenv","slug":"setenv","permalink":"https://yyhan.github.io/tags/setenv/"}]},{"title":"hadoop集群搭建","slug":"hadoop集群搭建","date":"2016-12-22T03:29:20.000Z","updated":"2017-06-18T13:19:00.469Z","comments":true,"path":"2016/12/22/hadoop集群搭建/","link":"","permalink":"https://yyhan.github.io/2016/12/22/hadoop集群搭建/","excerpt":"","text":"&#x7CFB;&#x7EDF;&#x53CA;&#x8F6F;&#x4EF6;&#x7248;&#x672C; ubuntu server 16.10 jdk 1.8.0_111 hadoop 2.7.3 &#x96C6;&#x7FA4;&#x914D;&#x7F6E; IP&#x53CA;&#x57DF;&#x540D;&#x5206;&#x914D; &#x4E3B;&#x673A;&#x540D; ip master 192.168.2.100 slave1 192.168.2.101 slave2 192.168.2.102 &#x96C6;&#x7FA4;&#x642D;&#x5EFA;&#x5728;VM&#x865A;&#x62DF;&#x673A;&#x4E0A;&#xFF0C;&#x5404;&#x865A;&#x62DF;&#x673A;&#x91C7;&#x7528;nat&#x65B9;&#x5F0F;&#x8FDE;&#x63A5;&#xFF0C;&#x5B50;&#x7F51;ip&#xFF1A;192.168.2.0&#xFF0C;&#x4E3B;&#x673A;&#x540D;&#x914D;&#x7F6E;&#x5728;&#x5404;&#x865A;&#x62DF;&#x673A;host&#x6587;&#x4EF6;&#x4E2D;&#x3002;&#xFF08;&#x63D0;&#x793A;&#xFF1A;&#x4E00;&#x53F0;&#x673A;&#x5668;&#x914D;&#x7F6E;&#x597D;&#x540E;&#xFF0C;&#x590D;&#x5236;&#x4E09;&#x4EFD;&#x5373;&#x53EF;&#xFF09; &#x4F7F;&#x7528;&#x865A;&#x62DF;&#x673A;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x6CE8;&#x610F;&#x8981;&#x5C06;&#x865A;&#x62DF;&#x673A;&#x6539;&#x4E3A;&#x9759;&#x6001;ip&#xFF0C;&#x907F;&#x514D;&#x91CD;&#x542F;&#x540E;ip&#x6539;&#x53D8;&#xFF0C;&#x5BFC;&#x81F4;host&#x914D;&#x7F6E;&#x5931;&#x6548;&#x3002; &#x7528;&#x6237; &#x5355;&#x72EC;&#x5EFA;&#x7ACB;hadoop&#x7528;&#x6237;&#xFF0C;&#x7528;&#x4E8E;&#x8FD0;&#x884C;hadoop&#x8FDB;&#x7A0B; &#x8F6F;&#x4EF6;&#x5B89;&#x88C5; jdk &#x548C; Hadoop&#x5B89;&#x88C5; jdk&#x5B89;&#x88C5;&#x8DEF;&#x5F84;&#xFF1A;/usr/bin/java/jdk1.8.0_111 Hadoop&#x5B89;&#x88C5;&#x8DEF;&#x5F84;&#xFF1A;/home/hadoop/hadoop/hadoop-2.7.3(hadoop&#x7528;&#x6237;&#x7684;&#x4E3B;&#x76EE;&#x5F55;&#x5373;&#x53EF;) &#x5728;/etc/profile&#x6587;&#x4EF6;&#x4E2D;&#x8FFD;&#x52A0;&#x4EE5;&#x4E0B;&#x4EE3;&#x7801;&#xFF1A; 1234export JAVA_HOME=/usr/bin/java/jdk1.8.0_111export JRE_HOME=$JAVA_HOME/jreexport HADOOP_HOME=/home/hadoop/hadoop/hadoop-2.7.3export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin:$HADOOP_HOME/bin Hadoop&#x914D;&#x7F6E; Hadoop&#x7684;&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x90FD;&#x5728;$HADOOP_HOME/etc/hadoop &#x76EE;&#x5F55;&#x4E0B;&#xFF0C;&#x4EE5;&#x4E0B;&#x64CD;&#x4F5C;&#x5747;&#x5728;&#x8BE5;&#x76EE;&#x5F55;&#x4E0B;&#x6267;&#x884C;&#x3002; hadoop-env.sh &#x627E;&#x5230;&#x8BE5;&#x6587;&#x4EF6;&#x91CC;&#x7684;JAVA_HOME&#x914D;&#x7F6E;&#x9879;&#xFF0C;&#x5E76;&#x6307;&#x5B9A;jdk&#x7684;&#x7EDD;&#x5BF9;&#x8DEF;&#x5F84;&#xFF08;&#x5FC5;&#x987B;&#x662F;&#x7EDD;&#x5BF9;&#x8DEF;&#x5F84;&#xFF09;: 1export JAVA_HOME=/usr/bin/java/jdk1.8.0_111 core-site.xml 12345678910&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/home/hadoop/hadoop/tmp&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://master:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hdfs-site.xml 123456789101112131415161718192021222324252627&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.http-address&lt;/name&gt; &lt;value&gt;master:50070&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt; &lt;value&gt;slave1:50070&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;2&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/home/hadoop/hadoop/tmp/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.data.dir&lt;/name&gt; &lt;value&gt;file:/home/hadoop/hadoop/tmp/dfs/data&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.permissions.enabled&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; mapred-site.xml &#x8BE5;&#x6587;&#x4EF6;&#x5728;&#x539F;&#x59CB;&#x538B;&#x7F29;&#x6587;&#x4EF6;&#x91CC;&#x6CA1;&#x6709;&#xFF0C;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;mv mapred-site.xml.template mapred-site.xml&#x521B;&#x5EFA;&#x3002; 1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt; &lt;value&gt;master:10020&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt; &lt;value&gt;master:19888&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; yarn-site.xml 1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;master&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-service&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-service.mapreduce.shuffle.class&lt;/name&gt; &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; masters &#x8BE5;&#x6587;&#x4EF6;&#x7528;&#x4E8E;&#x914D;&#x7F6E;&#x4E3B;&#x8282;&#x70B9;&#x4FE1;&#x606F;&#xFF0C;&#x6BCF;&#x884C;&#x914D;&#x7F6E;&#x4E00;&#x4E2A;&#x4E3B;&#x673A;&#x540D;&#x79F0;&#x3002;&#x8BE5;&#x6587;&#x4EF6;&#x5728;&#x539F;&#x59CB;&#x538B;&#x7F29;&#x6587;&#x4EF6;&#x91CC;&#x6CA1;&#x6709;&#xFF0C;&#x9700;&#x8981;&#x65B0;&#x5EFA;&#x4E00;&#x4E2A;&#x3002; 1slave1 slaves &#x8BE5;&#x6587;&#x4EF6;&#x7528;&#x4E8E;&#x914D;&#x7F6E;&#x4ECE;&#x8282;&#x70B9;&#x4FE1;&#x606F;&#xFF0C;&#x6BCF;&#x884C;&#x914D;&#x7F6E;&#x4E00;&#x4E2A;&#x4E3B;&#x673A;&#x540D;&#x79F0;&#x3002; 12slave1slave2 &#x4EE5;&#x4E0A;&#x914D;&#x7F6E;&#x7ED3;&#x675F;&#x540E;&#xFF0C;&#x5C31;&#x53EF;&#x4EE5;&#x5C06;&#x865A;&#x62DF;&#x673A;&#x590D;&#x5236;&#x4E24;&#x4EFD;&#xFF0C;&#x5E76;&#x5C06;ip&#xFF0C;&#x5206;&#x522B;&#x6307;&#x5B9A;&#x4E3A;192.168.2.101&#x548C;192.168.2.102&#x3002; ssh&#x914D;&#x7F6E; &#x751F;&#x6210;ssh&#x5BC6;&#x94A5;&#xFF0C;&#x6267;&#x884C;&#x4EE5;&#x4E0B;&#x547D;&#x4EE4;&#xFF0C;&#x4E00;&#x8DEF;&#x56DE;&#x8F66;&#x5373;&#x53EF;&#x3002; 1ssh-keygen -t rsa &#x5C06;&#x516C;&#x94A5;&#x62F7;&#x8D1D;&#x5230;&#x5176;&#x5B83;&#x673A;&#x5668;&#x4E0A;&#xFF0C;&#x5B9E;&#x73B0;&#x514D;&#x5BC6;&#x7801;&#x767B;&#x5F55;&#xFF1A; 123ssh-copy-id masterssh-copy-id slave1ssh-copy-id slave2 &#x8FD9;&#x6837;&#x4F1A;&#x5728;&#x6BCF;&#x53F0;&#x673A;&#x5668;&#x7684;hadoop&#x7528;&#x6237;&#x4E3B;&#x76EE;&#x5F55;&#x4E0B;&#x7684;.ssh&#x76EE;&#x5F55;&#x4E0B;&#x751F;&#x6210;&#x4E00;&#x4E2A;authorized_keys&#x6587;&#x4EF6;&#xFF0C;&#x8BE5;&#x6587;&#x4EF6;&#x5C31;&#x8BB0;&#x5F55;&#x4E86;&#x521A;&#x624D;&#x751F;&#x6210;&#x7684;&#x516C;&#x94A5;&#x5185;&#x5BB9;&#x3002; &#x542F;&#x52A8; &#x4F7F;&#x7528;hadoop&#x7528;&#x6237;&#x767B;&#x5F55;&#x3002; &#x7B2C;&#x4E00;&#x6B21;&#x542F;&#x52A8;&#x9700;&#x8981;&#x683C;&#x5F0F;&#x5316;&#xFF0C;&#x5728;$HADOOP_HOME&#x76EE;&#x5F55;&#x4E0B;&#x6267;&#x884C;: 1./bin/hdfs namenode -format &#x542F;&#x52A8;hdfs&#xFF1A; 1./sbin/start-dfs.sh &#x542F;&#x52A8;hdfs&#x547D;&#x4EE4;&#x6267;&#x884C;&#x7ED3;&#x679C;&#x663E;&#x793A;&#x5982;&#x4E0B;&#xFF1A; 123456Starting namenodes on [master]master: starting namenode, logging to /home/hadoop/hadoop/hadoop-2.7.3/logs/hadoop-hadoop-namenode-ubuntu.outslave1: starting datanode, logging to /home/hadoop/hadoop/hadoop-2.7.3/logs/hadoop-hadoop-datanode-ubuntu.outslave2: starting datanode, logging to /home/hadoop/hadoop/hadoop-2.7.3/logs/hadoop-hadoop-datanode-ubuntu.outStarting secondary namenodes [slave1]slave1: starting secondarynamenode, logging to /home/hadoop/hadoop/hadoop-2.7.3/logs/hadoop-hadoop-secondarynamenode-ubuntu.out &#x542F;&#x52A8;yarn&#xFF1A; 1./sbin/start-yarn.sh &#x542F;&#x52A8;yarn&#x547D;&#x4EE4;&#x6267;&#x884C;&#x7ED3;&#x679C;&#x663E;&#x793A;&#x5982;&#x4E0B;&#xFF1A; 1234starting yarn daemonsstarting resourcemanager, logging to /home/hadoop/hadoop/hadoop-2.7.3/logs/yarn-hadoop-resourcemanager-ubuntu.outslave1: starting nodemanager, logging to /home/hadoop/hadoop/hadoop-2.7.3/logs/yarn-hadoop-nodemanager-ubuntu.outslave2: starting nodemanager, logging to /home/hadoop/hadoop/hadoop-2.7.3/logs/yarn-hadoop-nodemanager-ubuntu.out &#x4F7F;&#x7528;jps&#x547D;&#x4EE4;&#x67E5;&#x770B;&#x8FDB;&#x7A0B;&#x662F;&#x5426;&#x542F;&#x52A8;&#xFF0C;&#x663E;&#x793A;&#x4EE5;&#x4E0B;&#x5185;&#x5BB9;&#x8868;&#x793A;&#x542F;&#x52A8;&#x6210;&#x529F;&#xFF1A; 1231257 NameNode1530 ResourceManager1787 Jps &#x901A;&#x8FC7;&#x6D4F;&#x89C8;&#x5668;&#x67E5;&#x770B;hdfs&#xFF1A;192.168.2.100:50070 &#x901A;&#x8FC7;&#x6D4F;&#x89C8;&#x5668;&#x67E5;&#x770B;yarn&#xFF1A;192.168.2.100:8088 &#x7ED3;&#x675F;&#x3002;","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://yyhan.github.io/categories/工具使用/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://yyhan.github.io/tags/hadoop/"}]},{"title":"HttpClient库使用示例","slug":"HttpClient库使用示例","date":"2016-12-12T14:42:31.000Z","updated":"2016-12-12T15:08:10.980Z","comments":true,"path":"2016/12/12/HttpClient库使用示例/","link":"","permalink":"https://yyhan.github.io/2016/12/12/HttpClient库使用示例/","excerpt":"","text":"HttpClient&#x662F;apache common&#x4E0B;&#x7684;&#x5B50;&#x9879;&#x76EE;&#xFF0C;&#x7528;&#x6765;&#x63D0;&#x4F9B;&#x9AD8;&#x6548;&#x7684;&#x3001;&#x529F;&#x80FD;&#x4E30;&#x5BCC;&#x7684;&#x652F;&#x6301;Http&#x534F;&#x8BAE;&#x7684;&#x5BA2;&#x6237;&#x7AEF;&#x7F16;&#x7A0B;&#x5DE5;&#x5177;&#x5305;&#x3002; &#x5B98;&#x7F51; &#x4F9D;&#x8D56;&#x7248;&#x672C;&#xFF1A; 12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpcore&lt;/artifactId&gt; &lt;version&gt;4.4.3&lt;/version&gt;&lt;/dependency&gt; &#x4EE3;&#x7801;&#xFF1A; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204package com.demo.utils.lang;import org.apache.commons.lang3.CharEncoding;import org.apache.http.HttpEntity;import org.apache.http.HttpException;import org.apache.http.HttpStatus;import org.apache.http.StatusLine;import org.apache.http.client.ClientProtocolException;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.client.methods.RequestBuilder;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import java.io.IOException;import java.util.Map;/*** Created by hyf on 2016/8/31.*/public class HttpUtil { private CloseableHttpClient httpClient; private static HttpUtil ourInstance = new HttpUtil(); public static HttpUtil getInstance() { return ourInstance; } private HttpUtil() { httpClient = HttpClients.createDefault(); } private CloseableHttpClient getHttpClient() { return this.httpClient; } /** * &#x53D1;&#x9001;get&#x8BF7;&#x6C42; * * @param uri &#x8BF7;&#x6C42;&#x5730;&#x5740; * @return * @throws IOException * @throws ClientProtocolException */ public String get(String uri) throws HttpException, IOException { CloseableHttpResponse response = null; HttpEntity entity = null; try { response = getHttpClient().execute(new HttpGet(uri)); StatusLine statusLine = response.getStatusLine(); if (statusLine.getStatusCode() == HttpStatus.SC_OK) { return EntityUtils.toString(response.getEntity()); } else { throw new HttpException(statusLine.toString()); } } finally { try { if (entity != null) { EntityUtils.consume(entity); } } catch (IOException e) { e.printStackTrace(); } try { if (response != null) { response.close(); } } catch (IOException e) { e.printStackTrace(); } } } /** * get&#x65B9;&#x5F0F;&#x53D1;&#x9001;form&#x8868;&#x5355; * * @param uri &#x8BF7;&#x6C42;&#x5730;&#x5740; * @param parameters &#x8868;&#x5355;&#x53C2;&#x6570; * @return * @throws Exception */ public String get(String uri, Map&lt;String, ?&gt; parameters) throws HttpException, IOException { return send(uri, parameters, HttpGet.METHOD_NAME); } /** * post&#x65B9;&#x5F0F;&#x53D1;&#x9001;form&#x8868;&#x5355; * * @param uri &#x8BF7;&#x6C42;&#x5730;&#x5740; * @param parameters &#x8868;&#x5355;&#x53C2;&#x6570; * @return * @throws Exception */ public String post(String uri, Map&lt;String, ?&gt; parameters) throws HttpException, IOException { return send(uri, parameters, HttpPost.METHOD_NAME); } /** * post&#x65B9;&#x5F0F;&#x53D1;&#x9001;form&#x8868;&#x5355; * * @param uri &#x8BF7;&#x6C42;&#x5730;&#x5740; * @param parameters &#x8868;&#x5355;&#x53C2;&#x6570; * @return * @throws Exception */ public String send(String uri, Map&lt;String, ?&gt; parameters, final String method) throws HttpException, IOException { CloseableHttpResponse response = null; HttpEntity entity = null; try { RequestBuilder builder = RequestBuilder.create(method).setUri(uri); for (String k : parameters.keySet()) { Object v = parameters.get(k); if (v == null) { builder.addParameter(k, &quot;&quot;); } else { builder.addParameter(k, v.toString()); } } response = getHttpClient().execute(builder.build()); StatusLine statusLine = response.getStatusLine(); if (statusLine.getStatusCode() == HttpStatus.SC_OK) { return EntityUtils.toString(response.getEntity()); } else { throw new HttpException(statusLine.toString()); } } finally { try { if (entity != null) { EntityUtils.consume(entity); } } catch (IOException e) { e.printStackTrace(); } try { if (response != null) { response.close(); } } catch (IOException e) { e.printStackTrace(); } } } /** * &#x6839;&#x636E;request&#x548C;uri&#x83B7;&#x5F97;&#x54CD;&#x5E94;&#x4FE1;&#x606F;,&#x4F7F;&#x7528;post&#x65B9;&#x5F0F;&#x83B7;&#x53D6;,&#x4F7F;&#x7528;UTF-8&#x7F16;&#x7801; * * @param uri &#x8BF7;&#x6C42;&#x5730;&#x5740; * @param bodyTxt http&#x8BF7;&#x6C42;body&#x5185;&#x5BB9; * @return * @throws IOException */ public String post(String uri, String bodyTxt) throws IOException, HttpException { return post(uri, bodyTxt, CharEncoding.UTF_8); } /** * &#x53D1;&#x9001;post&#x8BF7;&#x6C42; * * @param uri &#x8BF7;&#x6C42;&#x5730;&#x5740; * @param bodyTxt http&#x8BF7;&#x6C42;body&#x5185;&#x5BB9; * @param encoding &#x7F16;&#x7801;&#x7C7B;&#x578B; * @return * @throws IOException * @throws HttpException */ public String post(String uri, String bodyTxt, String encoding) throws IOException, HttpException { CloseableHttpResponse response = null; HttpEntity entity = null; try { response = getHttpClient().execute( RequestBuilder.post(uri) .setEntity(new StringEntity(bodyTxt, encoding)) .build()); StatusLine statusLine = response.getStatusLine(); if (statusLine.getStatusCode() == HttpStatus.SC_OK) { entity = response.getEntity(); return EntityUtils.toString(entity); } else { throw new HttpException(statusLine.toString()); } } finally { try { if (entity != null) { EntityUtils.consume(entity); } } catch (IOException e) { e.printStackTrace(); } try { if (response != null) { response.close(); } } catch (IOException e) { e.printStackTrace(); } } }}","categories":[{"name":"代码示例","slug":"代码示例","permalink":"https://yyhan.github.io/categories/代码示例/"}],"tags":[{"name":"HttpClient","slug":"HttpClient","permalink":"https://yyhan.github.io/tags/HttpClient/"},{"name":"http","slug":"http","permalink":"https://yyhan.github.io/tags/http/"}]},{"title":"idea乱码问题","slug":"idea乱码问题","date":"2016-12-12T13:02:58.000Z","updated":"2017-06-18T13:19:54.358Z","comments":true,"path":"2016/12/12/idea乱码问题/","link":"","permalink":"https://yyhan.github.io/2016/12/12/idea乱码问题/","excerpt":"","text":"idea&#x4E71;&#x7801;&#x95EE;&#x9898;&#x4E3B;&#x8981;&#x6D89;&#x53CA;&#x51E0;&#x4E2A;&#x65B9;&#x9762;&#xFF1A; idea&#x542F;&#x52A8;&#x65F6;&#x7684;java&#x865A;&#x62DF;&#x673A;&#x7F16;&#x7801; java&#x6E90;&#x4EE3;&#x7801;&#x6587;&#x4EF6;&#x7F16;&#x7801; maven&#x547D;&#x4EE4;&#x8FD0;&#x884C;&#x65F6;&#xFF08;&#x7F16;&#x8BD1;&#x3001;&#x6253;&#x5305;&#x7B49;&#xFF09;&#x7F16;&#x7801; java&#x9879;&#x76EE;&#x8FD0;&#x884C;&#x65F6;&#xFF08;&#x5728;idea&#x4E2D;&#x8FD0;&#x884C;&#xFF09;&#x7F16;&#x7801; &#x8FD9;&#x51E0;&#x4E2A;&#x70B9;&#x4E5F;&#x4F1A;&#x4E92;&#x76F8;&#x5F71;&#x54CD;&#xFF0C;&#x4E0D;&#x4E00;&#x5B9A;&#x8BF4;&#x5355;&#x72EC;&#x6539;&#x4E86;&#x54EA;&#x4E2A;&#x914D;&#x7F6E;&#x80FD;&#x89E3;&#x51B3;&#x4E71;&#x7801;&#x95EE;&#x9898;&#xFF0C;&#x6700;&#x597D;&#x662F;&#x7EDF;&#x4E00;&#x6240;&#x6709;&#x7F16;&#x7801;&#x4E3A;UTF-8&#x3002; &#x5728;windows&#x4E0B;&#xFF0C;git&#x548C;kdiff3(git&#x9ED8;&#x8BA4;&#x7684;&#x5BF9;&#x6BD4;&#x5DE5;&#x5177;)&#x7684;&#x9ED8;&#x8BA4;&#x7F16;&#x7801;&#x4E3A;&#x64CD;&#x4F5C;&#x7CFB;&#x7EDF;&#x7F16;&#x7801;&#xFF0C;&#x5982;&#x679C;&#x4F7F;&#x7528;git&#x89E3;&#x51B3;&#x51B2;&#x7A81;&#x7684;&#x8BDD;&#xFF0C;&#x6587;&#x4EF6;&#x7F16;&#x7801;&#x53EF;&#x80FD;&#x4F1A;&#x88AB;&#x6539;&#x6389;&#xFF0C;&#x4E00;&#x5B9A;&#x8981;&#x6CE8;&#x610F;&#x4FEE;&#x6539;git&#x548C;kdiff3&#x7684;&#x7F16;&#x7801;&#x4E3A;UTF-8 idea&#x542F;&#x52A8;&#x65F6;&#x7684;java&#x865A;&#x62DF;&#x673A;&#x7F16;&#x7801; &#x73B0;&#x8C61;: &#x63A7;&#x5236;&#x53F0;&#x4E71;&#x7801; &#x89E3;&#x51B3;&#xFF1A; &#x627E;&#x5230;IDEA_HOME\\bin\\idea.exe.vmoptions&#x6216;IDEA_HOME\\bin\\idea64.exe.vmoptions&#xFF0C;&#x8FFD;&#x52A0;&#x4EE5;&#x4E0B;&#x914D;&#x7F6E;&#xFF1A; 1-Dfile.encoding=UTF-8 java&#x6E90;&#x4EE3;&#x7801;&#x6587;&#x4EF6;&#x7F16;&#x7801; &#x73B0;&#x8C61;: java&#x6E90;&#x4EE3;&#x7801;&#x5408;&#x5E76;&#x3001;&#x6216;&#x7528;&#x5176;&#x5B83;&#x7F16;&#x8F91;&#x5668;&#x6253;&#x5F00;&#x65F6;&#x51FA;&#x73B0;&#x4E71;&#x7801; &#x89E3;&#x51B3;&#xFF1A; &#x5C06;&#x5DF2;&#x6709;&#x7684;java&#x6E90;&#x7801;&#x6587;&#x4EF6;&#x5168;&#x90E8;&#x6539;&#x6210;UTF-8&#x7F16;&#x7801; File -&gt; Settings -&gt; Editor -&gt; File Encodings &#x8FDB;&#x884C;&#x4EE5;&#x4E0B;&#x8BBE;&#x7F6E;&#xFF08;&#x4FDD;&#x8BC1;&#x4EE5;&#x540E;&#x65B0;&#x6DFB;&#x52A0;&#x7684;&#x6587;&#x4EF6;&#x7F16;&#x7801;&#x90FD;&#x662F;UTF-8&#x7F16;&#x7801;&#xFF09;&#xFF1A; IDE Encoding : UTF-8 Project Encoding : UTF-8 Default encoding for properties files : UTF-8 maven&#x547D;&#x4EE4;&#x8FD0;&#x884C;&#x65F6;&#xFF08;&#x7F16;&#x8BD1;&#x3001;&#x6253;&#x5305;&#x7B49;&#xFF09;&#x7F16;&#x7801; &#x73B0;&#x8C61;: &#x6267;&#x884C;maven&#x547D;&#x4EE4;&#x65F6;&#x63A7;&#x5236;&#x53F0;&#x8F93;&#x51FA;&#x4E71;&#x7801; &#x89E3;&#x51B3;&#xFF1A; &#x5728;pom.xml&#x6587;&#x4EF6;&#x4E2D;&#x914D;&#x7F6E;&#x5982;&#x4E0B;&#xFF1A; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;build&gt; &lt;plugins&gt; &lt;!-- &#x6307;&#x5B9A;maven&#x7F16;&#x8BD1;&#x65F6;&#x7684;java&#x7248;&#x672C; --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;${maven-compiler-plugin.version}&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- &#x6307;&#x5B9A;maven&#x8D44;&#x6E90;&#x6587;&#x4EF6;&#x7F16;&#x7801; --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- &#x89E3;&#x51B3;maven test&#x547D;&#x4EE4;&#x65F6;console&#x51FA;&#x73B0;&#x4E2D;&#x6587;&#x4E71;&#x7801;&#x4E71;&#x7801; --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.19.1 &lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.maven.surefire&lt;/groupId&gt; &lt;artifactId&gt;surefire-junit47&lt;/artifactId&gt; &lt;version&gt;2.19.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;configuration&gt; &lt;argLine&gt;-Dfile.encoding=UTF-8&lt;/argLine&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;forkMode&gt;never&lt;/forkMode&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- &#x6307;&#x5B9A;maven&#x6253;war&#x5305;&#x65F6;&#x8D44;&#x6E90;&#x6587;&#x4EF6;&#x7F16;&#x7801; --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;configuration&gt; &lt;resourceEncoding&gt;UTF-8&lt;/resourceEncoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 4. java&#x9879;&#x76EE;&#x8FD0;&#x884C;&#x65F6;&#xFF08;&#x5728;idea&#x4E2D;&#x8FD0;&#x884C;&#xFF09;&#x7F16;&#x7801; &#x73B0;&#x8C61;: &#x8FD0;&#x884C;java&#x9879;&#x76EE;&#x65F6;&#x63A7;&#x5236;&#x53F0;&#x8F93;&#x51FA;&#x4E71;&#x7801;&#xFF08;&#x4F7F;&#x7528;tomcat&#x65F6;&#xFF0C;&#x53EF;&#x80FD;&#x4F1A;&#x51FA;&#x73B0;&#x9875;&#x9762;&#x4E71;&#x7801;&#xFF09; &#x89E3;&#x51B3;&#xFF1A; &#x5728;java&#x9879;&#x76EE;&#x7684;Run/Debug Configurations&#x7684;VM options&#x4E2D;&#x6DFB;&#x52A0;&#x4EE5;&#x4E0B;&#x6307;&#x4EE4;&#xFF1A; 1-Dfile.encoding=UTF-8","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://yyhan.github.io/categories/工具使用/"}],"tags":[{"name":"idea","slug":"idea","permalink":"https://yyhan.github.io/tags/idea/"},{"name":"乱码","slug":"乱码","permalink":"https://yyhan.github.io/tags/乱码/"}]},{"title":"hexo搭建博客教程汇总","slug":"hexo搭建博客教程汇总","date":"2016-12-12T12:39:23.000Z","updated":"2016-12-12T12:59:24.461Z","comments":true,"path":"2016/12/12/hexo搭建博客教程汇总/","link":"","permalink":"https://yyhan.github.io/2016/12/12/hexo搭建博客教程汇总/","excerpt":"","text":"&#x4E00;&#x76F4;&#x60F3;&#x505A;&#x4E2A;&#x81EA;&#x5DF1;&#x7684;&#x535A;&#x5BA2;&#xFF0C;&#x4F46;&#x662F;&#x81EA;&#x5DF1;&#x8D70;&#x7684;&#x662F;java&#x8DEF;&#x7EBF;&#xFF0C;&#x56E0;&#x4E3A;&#x4E0D;&#x4F1A;&#x7528;php&#x653E;&#x5F03;&#x4E86;WordPress&#xFF0C;&#x56E0;&#x4E3A;&#x89C9;&#x5F97;jekyll&#x73AF;&#x5883;&#x642D;&#x5EFA;&#x9EBB;&#x70E6;&#x800C;&#x653E;&#x5F03;&#x4E86;jekyll&#x3002;&#x4E2D;&#x95F4;&#x5C1D;&#x8BD5;&#x8FC7;&#x81EA;&#x5DF1;&#x5199;&#x9759;&#x6001;&#x7AD9;&#x70B9;&#xFF0C;&#x901A;&#x8FC7;&#x5F02;&#x6B65;&#x52A0;&#x8F7D;markdown&#x6587;&#x6863;&#xFF0C;&#x4F7F;&#x7528;&#x6D4F;&#x89C8;&#x5668;&#x6E32;&#x67D3;&#x7684;&#x65B9;&#x5F0F;&#x5448;&#x73B0;&#x535A;&#x5BA2;&#x3002;&#x4F46;&#x662F;&#x56E0;&#x4E3A;&#x76EE;&#x5F55;&#x7ED3;&#x6784;&#x9700;&#x8981;&#x7EAF;&#x624B;&#x5DE5;&#x5199;&#xFF0C;&#x4E0D;&#x652F;&#x6301;&#x5206;&#x9875;&#xFF0C;&#x4E0D;&#x652F;&#x6301;&#x6458;&#x8981;&#xFF0C;&#x800C;&#x4E2D;&#x9014;&#x653E;&#x5F03;&#x4F7F;&#x7528;&#x3002;&#x540E;&#x6765;&#x770B;&#x5230;&#x4E86;hexo&#x535A;&#x5BA2;&#x7CFB;&#x7EDF;&#xFF08;&#x53EA;&#x9700;&#x8981;&#x4F9D;&#x8D56;nodejs&#xFF0C;&#x5F3A;&#x8FEB;&#x60A3;&#x8005;&#x53EA;&#x559C;&#x6B22;&#x4F9D;&#x8D56;&#x5C11;&#x7684;&#x4EA7;&#x54C1;^_^&#xFF09;&#xFF0C;&#x8FD9;&#x4E24;&#x5929;&#x5C31;&#x5F00;&#x59CB;&#x6298;&#x817E;hexo&#x3002;&#x672C;&#x60F3;&#x5199;&#x4E00;&#x7BC7;&#x535A;&#x5BA2;&#xFF0C;&#x5206;&#x4EAB;&#x4E0B;&#x6298;&#x817E;&#x7ECF;&#x9A8C;&#xFF0C;&#x7136;&#x800C;&#x53D1;&#x73B0;&#x7F51;&#x4E0A;&#x5DF2;&#x6709;&#x5F88;&#x591A;&#x540C;&#x5B66;&#x5206;&#x4EAB;&#x975E;&#x5E38;&#x8BE6;&#x7EC6;&#x7684;&#x6559;&#x7A0B;&#xFF0C;&#x5C31;&#x4E0D;&#x518D;&#x91CD;&#x590D;&#x9020;&#x8F6E;&#x5B50;&#xFF0C;&#x5728;&#x8FD9;&#x91CC;&#x5217;&#x51FA;&#xFF0C;&#x6298;&#x817E;&#x8FC7;&#x7A0B;&#x4E2D;&#x53C2;&#x8003;&#x7684;&#x6559;&#x7A0B;&#x6216;&#x7F51;&#x7AD9;&#xFF0C;&#x4F9B;&#x5404;&#x4F4D;&#x53C2;&#x8003;&#x3002; Xuanwo&apos;s Blog&#x53F2;&#x4E0A;&#x6700;&#x8BE6;&#x7EC6;&#x7684;Hexo&#x535A;&#x5BA2;&#x642D;&#x5EFA;&#x56FE;&#x6587;&#x6559;&#x7A0B; &#x5C60;&#x592B;9441&#x7684;&#x535A;&#x5BA2;&#x5927;&#x9053;&#x81F3;&#x7B80;&#x2014;&#x2014;Hexo&#x7B80;&#x6D01;&#x4E3B;&#x9898;&#x63A8;&#x8350; hexo&#x5B98;&#x7F51;&#x6587;&#x6863; &#x6DD8;&#x5B9D;NPM&#x955C;&#x50CF; npm&#x5B98;&#x65B9;&#x6587;&#x6863; git","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://yyhan.github.io/categories/工具使用/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://yyhan.github.io/tags/hexo/"},{"name":"博客系统","slug":"博客系统","permalink":"https://yyhan.github.io/tags/博客系统/"}]},{"title":"maven常用命令","slug":"maven常用命令","date":"2016-12-12T12:26:51.000Z","updated":"2016-12-12T12:36:50.472Z","comments":true,"path":"2016/12/12/maven常用命令/","link":"","permalink":"https://yyhan.github.io/2016/12/12/maven常用命令/","excerpt":"","text":"mvn package -DskipTests &#x8DF3;&#x8FC7;&#x6D4B;&#x8BD5;&#x6B65;&#x9AA4;&#x6253;&#x5305;&#x3002; mvn package -Dmaven.test.skip=true &#x8DF3;&#x8FC7;&#x6D4B;&#x8BD5;&#x4EE3;&#x7801;&#x7F16;&#x8BD1;&#x548C;&#x6267;&#x884C;&#x6B65;&#x9AA4;&#x6253;&#x5305;&#x3002; mvn compile &#x7F16;&#x8BD1;java&#x4EE3;&#x7801;&#xFF0C;&#x62F7;&#x8D1D;&#x7F16;&#x8BD1;&#x7ED3;&#x679C;&#x548C;resources&#x76EE;&#x5F55;&#x4E0B;&#x7684;&#x6587;&#x4EF6;&#x5230;target/classes&#x76EE;&#x5F55;&#x4E0B;&#x3002; mvn clean &#x6E05;&#x7406;&#x7F16;&#x8BD1;&#x548C;&#x6253;&#x5305;&#x7ED3;&#x679C;&#xFF0C;&#x5220;&#x9664;target&#x76EE;&#x5F55;&#x4E0B;&#x7684;&#x6240;&#x6709;&#x6587;&#x4EF6;&#x3002; mvn clean package &#x6E05;&#x7406;&#x7F16;&#x8BD1;&#x548C;&#x6253;&#x5305;&#x7ED3;&#x679C;&#x5E76;&#x6253;&#x5305;&#x3002;","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://yyhan.github.io/categories/工具使用/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://yyhan.github.io/tags/maven/"},{"name":"mvn","slug":"mvn","permalink":"https://yyhan.github.io/tags/mvn/"}]},{"title":"maven常用配置","slug":"maven常用配置","date":"2016-12-12T12:14:31.000Z","updated":"2017-06-06T15:16:44.467Z","comments":true,"path":"2016/12/12/maven常用配置/","link":"","permalink":"https://yyhan.github.io/2016/12/12/maven常用配置/","excerpt":"","text":"&#x4ECB;&#x7ECD;maven&#x5E38;&#x7528;&#x7684;&#x914D;&#x7F6E;&#xFF0C;&#x4E71;&#x7801;&#x95EE;&#x9898;&#x5904;&#x7406;&#xFF0C;&#x5E38;&#x7528;&#x6307;&#x4EE4;&#x4ECB;&#x7ECD;&#x7B49;&#x3002; &lt;!-- more --&gt; maven scope&#x8BF4;&#x660E; compile&#xFF0C;&#x7F3A;&#x7701;&#x503C;&#xFF0C;&#x9002;&#x7528;&#x4E8E;&#x6240;&#x6709;&#x9636;&#x6BB5;&#xFF0C;&#x4F1A;&#x968F;&#x7740;&#x9879;&#x76EE;&#x4E00;&#x8D77;&#x53D1;&#x5E03;&#x3002; provided&#xFF0C;&#x7C7B;&#x4F3C;compile&#xFF0C;&#x671F;&#x671B;JDK&#x3001;&#x5BB9;&#x5668;&#x6216;&#x4F7F;&#x7528;&#x8005;&#x4F1A;&#x63D0;&#x4F9B;&#x8FD9;&#x4E2A;&#x4F9D;&#x8D56;&#x3002;&#x5982;servlet.jar&#x3002; runtime&#xFF0C;&#x53EA;&#x5728;&#x8FD0;&#x884C;&#x65F6;&#x4F7F;&#x7528;&#xFF0C;&#x5982;JDBC&#x9A71;&#x52A8;&#xFF0C;&#x9002;&#x7528;&#x8FD0;&#x884C;&#x548C;&#x6D4B;&#x8BD5;&#x9636;&#x6BB5;&#x3002; test&#xFF0C;&#x53EA;&#x5728;&#x6D4B;&#x8BD5;&#x65F6;&#x4F7F;&#x7528;&#xFF0C;&#x7528;&#x4E8E;&#x7F16;&#x8BD1;&#x548C;&#x8FD0;&#x884C;&#x6D4B;&#x8BD5;&#x4EE3;&#x7801;&#x3002;&#x4E0D;&#x4F1A;&#x968F;&#x9879;&#x76EE;&#x53D1;&#x5E03;&#x3002; system&#xFF0C;&#x7C7B;&#x4F3C;provided&#xFF0C;&#x9700;&#x8981;&#x663E;&#x5F0F;&#x63D0;&#x4F9B;&#x5305;&#x542B;&#x4F9D;&#x8D56;&#x7684;jar&#xFF0C;Maven&#x4E0D;&#x4F1A;&#x5728;Repository&#x4E2D;&#x67E5;&#x627E;&#x5B83;&#x3002; war&#x5305;&#x8D44;&#x6E90;&#x8DEF;&#x5F84;&#x548C;&#x4E2D;&#x6587;&#x7F16;&#x7801; 1234567891011&lt;build&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;configuration&gt; &lt;resourceEncoding&gt;UTF-8&lt;/resourceEncoding&gt; &lt;outputDirectory&gt;${war.outputDirectory}&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/build&gt; &#x4E71;&#x7801;&#x95EE;&#x9898;&#x5904;&#x7406; &#x5728;pom.xml&#x4E2D;&#x7EDF;&#x4E00;&#x6307;&#x5B9A;UTF-8&#x7F16;&#x7801;&#x3002; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/plugin&gt; &lt;!-- &#x6307;&#x5B9A;&#x7F16;&#x8BD1;&#x65F6;java&#x6E90;&#x6587;&#x4EF6;&#x7F16;&#x7801; --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- &#x6307;&#x5B9A;&#x8D44;&#x6E90;&#x6587;&#x4EF6;&#x7F16;&#x7801; --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- &#x89E3;&#x51B3;maven test&#x547D;&#x4EE4;&#x65F6;console&#x51FA;&#x73B0;&#x4E2D;&#x6587;&#x4E71;&#x7801;&#x4E71;&#x7801; --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.19.1&lt;/version&gt; &lt;configuration&gt; &lt;argLine&gt;-Dfile.encoding=UTF-8&lt;/argLine&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;forkMode&gt;never&lt;/forkMode&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;configuration&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- &#x6307;&#x5B9A;web&#x8D44;&#x6E90;&#x6587;&#x4EF6;&#x7F16;&#x7801; --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;configuration&gt; &lt;resourceEncoding&gt;UTF-8&lt;/resourceEncoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt;&lt;/build&gt; &#x6DFB;&#x52A0;&#x963F;&#x91CC;&#x5DF4;&#x5DF4;maven&#x955C;&#x50CF; &#x7B2C;&#x4E00;&#x79CD;&#x529E;&#x6CD5;&#xFF0C;&#x5728;setting.xml&#x4E2D;&#x914D;&#x7F6E;&#xFF0C;&#x5168;&#x5C40;&#x6709;&#x6548;&#xFF0C;&#x914D;&#x7F6E;&#x5982;&#x4E0B;&#xFF1A; 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; &#x7B2C;&#x4E8C;&#x79CD;&#x529E;&#x6CD5;&#xFF0C;&#x5728;pom.xml&#x4E2D;&#x914D;&#x7F6E;&#xFF0C;&#x5F53;&#x524D;&#x9879;&#x76EE;&#x6709;&#x6548;&#xFF0C;&#x914D;&#x7F6E;&#x5982;&#x4E0B;&#xFF1A; 1234567&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://yyhan.github.io/categories/工具使用/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://yyhan.github.io/tags/maven/"},{"name":"pom","slug":"pom","permalink":"https://yyhan.github.io/tags/pom/"}]},{"title":"java操作mongodb示例","slug":"java操作mongodb示例","date":"2016-12-11T14:57:48.000Z","updated":"2016-12-12T11:57:17.380Z","comments":true,"path":"2016/12/11/java操作mongodb示例/","link":"","permalink":"https://yyhan.github.io/2016/12/11/java操作mongodb示例/","excerpt":"","text":"java&#x64CD;&#x4F5C;mongodb&#x57FA;&#x672C;&#x5B9E;&#x73B0;&#x3002; &lt;!-- more --&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697package com.demo.utils.db;import com.mongodb.Block;import com.mongodb.MongoClient;import com.mongodb.MongoClientURI;import com.mongodb.ReadPreference;import com.mongodb.bulk.BulkWriteResult;import com.mongodb.client.*;import com.mongodb.client.model.*;import org.apache.commons.lang3.StringUtils;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import org.bson.Document;import org.bson.conversions.Bson;import org.bson.types.ObjectId;import org.joda.time.DateTime;import java.util.ArrayList;import java.util.List;public class MongoHelper { private Logger logger = LogManager.getLogger(this); public final static String AUTO_ID = &quot;_id&quot;; public final static String UpdateDate = &quot;_UpdateDate&quot;; public final static int MaxSize = 1000; private String hosts; private String databaseName; private MongoClient masterClusterClient; private MongoDatabase masterClusterDB; private MongoClient readClusterClient; private MongoDatabase readClusterDB; public MongoHelper(String hosts, String databaseName) { this.hosts = hosts; this.databaseName = databaseName; masterClusterClient = new MongoClient(new MongoClientURI(this.hosts)); masterClusterClient.setReadPreference(ReadPreference.secondaryPreferred()); masterClusterDB = masterClusterClient.getDatabase(this.databaseName); this.readClusterClient = this.masterClusterClient; this.readClusterDB = this.masterClusterDB; } public MongoHelper(String masterClusterHosts, String masterClusterDatabaseName, String readClusterHosts, String readClusterDatabaseName) { if (StringUtils.isEmpty(masterClusterHosts)) { throw new IllegalArgumentException(&quot;the &apos;masterClusterHosts&apos; is null or empty&quot;); } if (StringUtils.isEmpty(masterClusterDatabaseName)) { throw new IllegalArgumentException(&quot;the &apos;masterClusterDatabaseName&apos; is null or empty&quot;); } if (logger.isDebugEnabled()) { logger.debug(&quot;masterClusterHosts:{}&quot;, masterClusterHosts); logger.debug(&quot;masterClusterDatabaseName:{}&quot;, masterClusterDatabaseName); } masterClusterClient = new MongoClient(new MongoClientURI(masterClusterHosts)); masterClusterClient.setReadPreference(ReadPreference.secondaryPreferred()); masterClusterDB = masterClusterClient.getDatabase(masterClusterDatabaseName); if (StringUtils.isEmpty(readClusterHosts) || StringUtils.isEmpty(readClusterDatabaseName)) { this.readClusterClient = this.masterClusterClient; this.readClusterDB = this.masterClusterDB; } else { if (logger.isDebugEnabled()) { logger.debug(&quot;readClusterHosts:{}&quot;, readClusterHosts); logger.debug(&quot;readClusterDatabaseName:{}&quot;, readClusterDatabaseName); } if (masterClusterHosts.equals(readClusterHosts) &amp;&amp; masterClusterDatabaseName.equals(readClusterDatabaseName)) { this.readClusterClient = this.masterClusterClient; this.readClusterDB = this.masterClusterDB; } else { readClusterClient = new MongoClient(new MongoClientURI(readClusterHosts)); readClusterDB = readClusterClient.getDatabase(readClusterDatabaseName); } } } /** * &#x6267;&#x884C;mongo&#x547D;&#x4EE4; * * @param document * @return */ public Document runCommand(Document document) { if (document == null || document.isEmpty()) { throw new IllegalArgumentException(&quot;the &apos;document&apos; can not be null or empty&quot;); } if (document.containsKey(&quot;insert&quot;) || document.containsKey(&quot;update&quot;) || document.containsKey(&quot;delete&quot;)) { return this.masterClusterDB.runCommand(document, ReadPreference.primary()); } else { return this.readClusterDB.runCommand(document, ReadPreference.secondaryPreferred()); } } /** * &#x83B7;&#x53D6;&#x6570;&#x636E;&#x5E93;&#x540D;&#x79F0;&#x5217;&#x8868; * * @return &#x6240;&#x6709;&#x6570;&#x636E;&#x5E93;&#x540D;&#x79F0;&#x5217;&#x8868; &#x9700;&#x8981;&#x6743;&#x9650; */ public List&lt;String&gt; getAllDBNames() { MongoIterable&lt;String&gt; dbnames = masterClusterClient.listDatabaseNames(); if (dbnames == null) { return new ArrayList&lt;String&gt;(); } List&lt;String&gt; _list = new ArrayList&lt;String&gt;(); for (String s : dbnames) { _list.add(s); } return _list; } /** * &#x83B7;&#x53D6;mongo&#x96C6;&#x7FA4;DB&#x5B9E;&#x4F8B; * * @return */ public MongoDatabase getDB() { return getDB(databaseName, false); } /** * &#x83B7;&#x53D6;mongo&#x96C6;&#x7FA4;DB&#x5B9E;&#x4F8B; * * @param dbName &#x6570;&#x636E;&#x5E93;&#x540D;&#x5927;&#x5C0F;&#x5199; * @param isRead &#x662F;&#x5426;&#x8BFB;&#x5E93; * @return */ public MongoDatabase getDB(String dbName, Boolean isRead) { if (dbName != null &amp;&amp; !&quot;&quot;.equals(dbName)) { MongoDatabase database = isRead ? masterClusterClient.getDatabase(dbName) : masterClusterClient.getDatabase(dbName); return database; } return null; } /** * @return &#x67E5;&#x8BE2;&#x9ED8;&#x8BA4;DB&#x4E0B;&#x7684;&#x6240;&#x6709;&#x96C6;&#x5408; */ public List&lt;String&gt; getAllCollectionNames() { MongoIterable&lt;String&gt; colls = masterClusterDB.listCollectionNames(); if (colls == null) { return new ArrayList&lt;String&gt;(); } List&lt;String&gt; _list = new ArrayList&lt;String&gt;(); for (String s : colls) { _list.add(s); } return _list; } /** * &#x67E5;&#x8BE2;&#x6307;&#x5B9A;DB&#x4E0B;&#x7684;&#x6240;&#x6709;&#x96C6;&#x5408; * * @param dbName &#x6307;&#x5B9A;DB * @return &#x6307;&#x5B9A;DB&#x4E0B;&#x7684;&#x6240;&#x6709;&#x96C6;&#x5408;&#x540D;&#x79F0; */ public List&lt;String&gt; getAllCollectionNames(String dbName) { MongoDatabase db = masterClusterClient.getDatabase(dbName); if (db == null) { return new ArrayList&lt;String&gt;(); } MongoIterable&lt;String&gt; colls = db.listCollectionNames(); if (colls == null) { return new ArrayList&lt;String&gt;(); } List&lt;String&gt; _list = new ArrayList&lt;String&gt;(); for (String s : colls) { _list.add(s); } return _list; } /** * &#x4ECE;&#x9ED8;&#x8BA4;&#x8BFB;&#x5E93;&#x83B7;&#x53D6;collection&#x96C6;&#x5408;&#x5BF9;&#x8C61; * * @param collName &#x96C6;&#x5408;&#x540D;&#x5B57;&#x5927;&#x5C0F;&#x5199; * @return &#x96C6;&#x5408;&#x5BF9;&#x8C61; */ private MongoCollection&lt;Document&gt; getCollection(String collName) { return getCollection(collName, ReadPreference.secondaryPreferred()); } /** * &#x83B7;&#x53D6;Mongodb&#x96C6;&#x5408; * * @param collName &#x96C6;&#x5408;&#x540D;&#x79F0; * @param readPreference &#x8BFB;&#x64CD;&#x4F5C;&#x4F18;&#x5148;&#x987A;&#x5E8F; * @return */ private MongoCollection&lt;Document&gt; getCollection(String collName, ReadPreference readPreference) { if (StringUtils.isEmpty(collName)) { throw new IllegalArgumentException(&quot;the &apos;collName&apos; is null or empty&quot;); } MongoCollection&lt;Document&gt; collection = this.masterClusterDB.getCollection(collName).withReadPreference(readPreference); return collection; } /** * &#x83B7;&#x53D6;&#x7528;&#x4E8E;&#x8BFB;&#x7684;&#x96C6;&#x5408;&#x3002;readClusterDB * * @param collName * @return */ private MongoCollection&lt;Document&gt; getCollectionOfRead(String collName) { if (StringUtils.isEmpty(collName)) { throw new IllegalArgumentException(&quot;the &apos;collName&apos; is null or empty&quot;); } MongoCollection&lt;Document&gt; collection = this.readClusterDB.getCollection(collName); return collection; } /** * &#x83B7;&#x53D6;&#x7528;&#x4E8E;&#x5199;&#x7684;&#x96C6;&#x5408;&#x3002;ReadPreference.primary * * @param collName * @return */ private MongoCollection&lt;Document&gt; getCollectionOfWrite(String collName) { if (StringUtils.isEmpty(collName)) { throw new IllegalArgumentException(&quot;the &apos;collName&apos; is null or empty&quot;); } MongoCollection&lt;Document&gt; collection = this.masterClusterDB.getCollection(collName).withReadPreference(ReadPreference.primary()); return collection; } /** * &#x4ECE;&#x9ED8;&#x8BA4;&#x8BFB;&#x5E93;&#x83B7;&#x53D6;collection&#x96C6;&#x5408;&#x5BF9;&#x8C61; * * @param collName &#x96C6;&#x5408;&#x540D;&#x5B57;&#x5927;&#x5C0F;&#x5199; * @return &#x96C6;&#x5408;&#x5BF9;&#x8C61; */ public List&lt;Document&gt; getDocuments(String collName, Document condition) { final List&lt;Document&gt; docs = new ArrayList&lt;&gt;(); if (StringUtils.isEmpty(collName)) { return docs; } FindIterable&lt;Document&gt; iterable = this.getCollectionOfRead(collName).find(condition); iterable.forEach(new Block&lt;Document&gt;() { @Override public void apply(final Document doc) { docs.add(doc); } }); return docs; } /** * &#x5411;&#x6307;&#x5B9A;&#x96C6;&#x5408;&#x4E2D;&#x63D2;&#x5165;&#x4E00;&#x6761;&#x6570;&#x636E; * * @param collName &#x96C6;&#x5408;&#x540D;&#x79F0; * @param doc &#x8981;&#x63D2;&#x5165;&#x7684;&#x6570;&#x636E; * @return &#x662F;&#x5426;&#x63D2;&#x5165;&#x6210;&#x529F; */ public String insertOne(String collName, Document doc) { MongoCollection&lt;Document&gt; collection = this.getCollectionOfWrite(collName); if (collection == null) { return null; } doc.append(UpdateDate, DateTime.now().toString(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;)); collection.insertOne(doc); if (doc.containsKey(MongoHelper.AUTO_ID)) { return doc.get(MongoHelper.AUTO_ID).toString(); } return null; } /** * &#x5411;&#x6307;&#x5B9A;&#x96C6;&#x5408;&#x4E2D;&#x63D2;&#x5165;&#x591A;&#x6761;&#x6570;&#x636E; * * @param collName &#x96C6;&#x5408;&#x540D;&#x79F0; * @param docs &#x8981;&#x63D2;&#x5165;&#x7684;&#x6570;&#x636E;&#x96C6;&#x5408; * @return &#x63D2;&#x5165;&#x662F;&#x5426;&#x6210;&#x529F; */ public boolean insertMany(String collName, List&lt;Document&gt; docs) { MongoCollection&lt;Document&gt; collection = this.getCollectionOfWrite(collName); if (collection == null) { return false; } String dateStr = DateTime.now().toString(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;); for (Document doc : docs) { doc.append(UpdateDate, dateStr); } collection.insertMany(docs); return true; } /** * &#x67E5;&#x8BE2;&#x96C6;&#x5408;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x6587;&#x6863; * * @param collName &#x96C6;&#x5408;&#x540D;&#x79F0; * @return &#x8FD4;&#x56DE;&#x7B2C;&#x4E00;&#x4E2A;&#x6587;&#x6863; */ public Document findOne(String collName) { MongoCollection&lt;Document&gt; coll = this.getCollectionOfRead(collName); if (coll == null) { return null; } FindIterable&lt;Document&gt; iterable = coll.find().limit(1); if (iterable == null) { return null; } return iterable.first(); } /** * &#x67E5;&#x8BE2;&#x6587;&#x6863; * * @param collName * @param filter * @return */ public Document findOne(String collName, Bson filter) { MongoCollection&lt;Document&gt; coll = this.getCollectionOfRead(collName); if (coll == null) { return null; } FindIterable&lt;Document&gt; iterable = coll.find(filter).limit(1); if (iterable == null) { return null; } return iterable.first(); } /** * &#x67E5;&#x8BE2;&#x6587;&#x6863; * * @param collName &#x96C6;&#x5408;&#x540D;&#x79F0; * @param filter &#x8FC7;&#x6EE4;&#x6761;&#x4EF6; * @param fields &#x8F93;&#x51FA;&#x5B57;&#x6BB5; * @return */ public Document findOne(String collName, Bson filter, String... fields) { MongoCollection&lt;Document&gt; coll = this.getCollectionOfRead(collName); if (coll == null) { return null; } FindIterable&lt;Document&gt; iterable = coll.find(filter).limit(1); if (iterable == null) { return null; } return iterable.projection(Projections.include(fields)).first(); } /** * &#x67E5;&#x8BE2;&#x6587;&#x6863; * * @param collName &#x96C6;&#x5408;&#x540D;&#x79F0; * @param filter &#x8FC7;&#x6EE4;&#x6761;&#x4EF6; * @param projection &#x5B57;&#x6BB5;&#x6295;&#x5F71; * @return */ public Document findOne(String collName, Bson filter, Bson projection) { MongoCollection&lt;Document&gt; coll = this.getCollectionOfRead(collName); if (coll == null) { return null; } FindIterable&lt;Document&gt; iterable = coll.find(filter).limit(1); if (iterable == null) { return null; } return iterable.projection(projection).first(); } /** * &#x67E5;&#x8BE2;&#x6587;&#x6863; * * @param collName &#x96C6;&#x5408;&#x540D;&#x79F0; * @param filter &#x8FC7;&#x6EE4;&#x6761;&#x4EF6; * @param projections &#x5B57;&#x6BB5;&#x6295;&#x5F71; * @param orderField &#x6392;&#x5E8F;&#x5B57;&#x6BB5; * @param ascding &#x662F;&#x5426;&#x5347;&#x5E8F; * @return */ public Document findOne(String collName, Bson filter, Bson projections, String orderField, boolean ascding) { MongoCollection&lt;Document&gt; coll = this.getCollectionOfRead(collName); if (coll == null) { return null; } FindIterable&lt;Document&gt; iterable = coll .find(filter) .sort(ascding ? Sorts.ascending(orderField) : Sorts.descending(orderField)) .limit(1); if (iterable == null) { return null; } return iterable.projection(projections).first(); } /** * &#x67E5;&#x8BE2;&#x6307;&#x5B9A;id&#x7684;&#x6587;&#x6863; * * @param collName &#x96C6;&#x5408;&#x540D;&#x79F0; * @param id &#x6587;&#x6863;&#x4E3B;&#x952E;id * @return */ public Document findRowById(String collName, String id) { if (ObjectId.isValid(id)) { MongoCollection&lt;Document&gt; coll = this.getCollectionOfRead(collName); if (coll == null) { return null; } FindIterable&lt;Document&gt; iterable = coll.find(Filters.eq(&quot;_id&quot;, new ObjectId(id))).limit(1); if (iterable == null) { return null; } return iterable.first(); } else { return null; } } /** * &#x67E5;&#x8BE2;&#x6587;&#x6863;&#x96C6;&#x5408; * * @param collName &#x96C6;&#x5408;&#x540D;&#x79F0; * @param filter &#x8FC7;&#x6EE4;&#x6761;&#x4EF6; * @param projections &#x5B57;&#x6BB5;&#x6295;&#x5F71; * @return &#x6700;&#x591A;&#x8FD4;&#x56DE; @MaxSize &#x4E2A;&#x6587;&#x6863;&#xFF0C;&#x907F;&#x514D;&#x5185;&#x5B58;&#x5360;&#x7528;&#x8FC7;&#x5927;&#x3002;&#x8FD4;&#x56DE;&#x7ED3;&#x679C;&#x6309;&#x7167;_id&#x5B57;&#x6BB5;&#x964D;&#x5E8F;&#x6392;&#x5217; */ public List&lt;Document&gt; findRows(String collName, Bson filter, Bson projections) { return findRows(collName, filter, projections, null, false); } /** * &#x67E5;&#x8BE2;&#x6587;&#x6863;&#x96C6;&#x5408;&#xFF0C;&#x5E76;&#x6309;&#x7167;&#x6307;&#x5B9A;&#x5B57;&#x6BB5;&#x6392;&#x5E8F; * * @param collName &#x96C6;&#x5408;&#x540D;&#x79F0; * @param filter &#x8FC7;&#x6EE4;&#x6761;&#x4EF6; * @param projections &#x5B57;&#x6BB5;&#x6295;&#x5F71; * @param orderField &#x6392;&#x5E8F;&#x5B57;&#x6BB5; * @param ascding &#x662F;&#x5426;&#x5347;&#x5E8F; * @return &#x6700;&#x591A;&#x8FD4;&#x56DE; @MaxSize &#x4E2A;&#x6587;&#x6863;&#xFF0C;&#x907F;&#x514D;&#x5185;&#x5B58;&#x5360;&#x7528;&#x8FC7;&#x5927; */ public List&lt;Document&gt; findRows(String collName, Bson filter, Bson projections, String orderField, boolean ascding) { List&lt;Document&gt; list = new ArrayList&lt;Document&gt;(); MongoCollection&lt;Document&gt; coll = this.getCollectionOfRead(collName); if (coll == null) { return list; } FindIterable&lt;Document&gt; iterable = null; if (filter == null) { iterable = coll.find(); } else { iterable = coll.find(filter); } if (iterable == null) { return list; } MongoCursor&lt;Document&gt; cursor = null; try { if (StringUtils.isEmpty(orderField)) { if (projections == null) { cursor = iterable .sort(ascding ? Sorts.ascending(&quot;_id&quot;) : Sorts.descending(&quot;_id&quot;)) .limit(MaxSize) .iterator(); } else { cursor = iterable.projection(projections) .sort(ascding ? Sorts.ascending(&quot;_id&quot;) : Sorts.descending(&quot;_id&quot;)) .limit(MaxSize) .iterator(); } } else { if (projections == null) { cursor = iterable .sort(ascding ? Sorts.ascending(orderField) : Sorts.descending(orderField)) .limit(MaxSize) .iterator(); } else { cursor = iterable.projection(projections) .sort(ascding ? Sorts.ascending(orderField) : Sorts.descending(orderField)) .limit(MaxSize) .iterator(); } } if (cursor != null &amp;&amp; cursor.hasNext()) { while (cursor.hasNext()) { list.add(cursor.next()); } } return list; } finally { if (cursor != null) cursor.close(); } } /** * @param collName &#x96C6;&#x5408;&#x540D;&#x79F0; * @param filter &#x8FC7;&#x6EE4;&#x6761;&#x4EF6; * @return */ public long getRowsCount(String collName, Bson filter) { MongoCollection&lt;Document&gt; coll = this.getCollectionOfRead(collName); if (coll == null) { return 0; } if (filter == null) { return coll.count(); } return coll.count(filter); } /** * &#x67E5;&#x8BE2;&#x5206;&#x9875;&#x6587;&#x6863;&#x96C6;&#x5408;,&#x6309;&#x7167;_id&#x5B57;&#x6BB5;&#x964D;&#x5E8F;&#x6392;&#x5217; * * @param collName &#x96C6;&#x5408;&#x540D;&#x79F0; * @param filter &#x8FC7;&#x6EE4;&#x6761;&#x4EF6; * @param projections &#x5B57;&#x6BB5;&#x6295;&#x5F71; * @param pageNo &#x5F53;&#x524D;&#x9875;&#x7F16;&#x53F7;&#xFF0C;&#x4ECE;0&#x5F00;&#x59CB; * @param pageSize &#x6BCF;&#x9875;&#x5BB9;&#x91CF; * @return * @throws Exception */ public List&lt;Document&gt; findPagedRows(String collName, Bson filter, Bson projections, int pageNo, int pageSize) { return findPagedRows(collName, filter, projections, null, false, pageNo, pageSize); } /** * &#x67E5;&#x8BE2;&#x5206;&#x9875;&#x6587;&#x6863;&#x96C6;&#x5408;,&#x9ED8;&#x8BA4;&#x6309;&#x7167;_id&#x5B57;&#x6BB5;&#x6392;&#x5E8F; * * @param collName &#x96C6;&#x5408;&#x540D;&#x79F0; * @param filter &#x8FC7;&#x6EE4;&#x6761;&#x4EF6; * @param projections &#x5B57;&#x6BB5;&#x6295;&#x5F71; * @param orderField &#x6392;&#x5E8F;&#x5B57;&#x6BB5; * @param ascding &#x662F;&#x5426;&#x5347;&#x5E8F; * @param pageNo &#x5F53;&#x524D;&#x9875;&#x7F16;&#x53F7;&#xFF0C;&#x4ECE;0&#x5F00;&#x59CB; * @param pageSize &#x6BCF;&#x9875;&#x5BB9;&#x91CF; * @return */ public List&lt;Document&gt; findPagedRows(String collName, Bson filter, Bson projections, String orderField, boolean ascding, int pageNo, int pageSize) { List&lt;Document&gt; list = new ArrayList&lt;Document&gt;(pageSize); MongoCollection&lt;Document&gt; coll = this.getCollectionOfRead(collName); if (coll == null) { return list; } FindIterable&lt;Document&gt; iterable = null; if (filter == null) { iterable = coll.find(); } else { iterable = coll.find(filter); } if (iterable == null) { return list; } MongoCursor&lt;Document&gt; cursor = null; try { if (StringUtils.isEmpty(orderField)) { cursor = iterable.projection(projections) .sort(ascding ? Sorts.ascending(&quot;_id&quot;) : Sorts.descending(&quot;_id&quot;)) .skip((pageNo - 1) * pageSize) .limit(pageSize) .iterator(); } else { cursor = iterable.projection(projections) .sort(Sorts.ascending(orderField)) .sort(ascding ? Sorts.ascending(orderField) : Sorts.descending(orderField)) .skip((pageNo - 1) * pageSize) .limit(pageSize) .iterator(); } if (cursor != null &amp;&amp; cursor.hasNext()) { while (cursor.hasNext()) { list.add(cursor.next()); } } return list; } finally { if (cursor != null) cursor.close(); } } /** * &#x6839;&#x636E;&#x4E3B;&#x952E;id&#x5220;&#x9664;&#x6587;&#x6863; * * @param collName &#x96C6;&#x5408;&#x540D;&#x79F0; * @param id &#x6587;&#x6863;id * @return &#x88AB;&#x5220;&#x9664;&#x7684;&#x6587;&#x6863;&#x6570;&#x91CF; */ public long deleteById(String collName, String id) { if (ObjectId.isValid(id)) { MongoCollection&lt;Document&gt; coll = this.getCollectionOfWrite(collName); if (coll == null) { return 0; } return coll.deleteOne(Filters.eq(&quot;_id&quot;, new ObjectId(id))) .getDeletedCount(); } else { return 0; } } /** * &#x6839;&#x636E;&#x6307;&#x5B9A;filter&#x5220;&#x9664;&#x6587;&#x6863; * * @param collName * @param filter * @return &#x88AB;&#x5220;&#x9664;&#x6587;&#x6863;&#x7684;&#x6570;&#x91CF; */ public long delete(String collName, Bson filter) { if (filter == null) { return 0; } else { MongoCollection&lt;Document&gt; coll = this.getCollectionOfWrite(collName); if (coll == null) { return 0; } return coll.deleteOne(filter) .getDeletedCount(); } } /** * &#x66F4;&#x65B0;&#x6587;&#x6863; * * @param collName &#x96C6;&#x5408;&#x540D;&#x79F0; * @param filter &#x8FC7;&#x6EE4;&#x6761;&#x4EF6; * @param update &#x66F4;&#x65B0;&#x8BED;&#x53E5; * @return &#x66F4;&#x65B0;&#x7684;&#x6587;&#x6863;&#x6570;&#x91CF; */ public long update(String collName, Bson filter, Bson update) { MongoCollection&lt;Document&gt; coll = this.getCollectionOfWrite(collName); if (coll == null) { return 0; } return coll.updateOne(filter, Updates.combine( update, Updates.set(UpdateDate, DateTime.now().toString(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;))) ).getModifiedCount(); } /** * &#x66F4;&#x65B0;&#x6587;&#x6863; * * @param collName &#x96C6;&#x5408;&#x540D;&#x79F0; * @param updates &#x66F4;&#x65B0;&#x8BED;&#x53E5; * @return &#x66F4;&#x65B0;&#x7684;&#x6587;&#x6863;&#x6570;&#x91CF; */ public long updateMany(String collName, List&lt;WriteModel&lt;Document&gt;&gt; updates) { MongoCollection&lt;Document&gt; coll = this.getCollectionOfWrite(collName); if (coll == null || updates == null || updates.size() == 0) { return 0; } BulkWriteResult bulkWriteResult = coll.bulkWrite(updates); return bulkWriteResult.getModifiedCount(); } /** * &#x66F4;&#x65B0;&#x6587;&#x6863;&#xFF0C;&#x6307;&#x5B9A;&#x6587;&#x6863;&#x5B58;&#x5728;&#x5219;&#x66F4;&#x65B0;&#xFF0C;&#x4E0D;&#x5B58;&#x5728;&#x5219;&#x63D2;&#x5165; * * @param collName &#x96C6;&#x5408;&#x540D;&#x79F0; * @param filter &#x8FC7;&#x6EE4;&#x6761;&#x4EF6; * @param update &#x66F4;&#x65B0;&#x8BED;&#x53E5; * @return &#x66F4;&#x65B0;&#x7684;&#x6587;&#x6863;&#x6570;&#x91CF; */ public long upsert(String collName, Bson filter, Bson update) { MongoCollection&lt;Document&gt; coll = this.getCollectionOfWrite(collName); if (coll == null) { return 0; } ; return coll.updateOne(filter, Updates.combine( update, Updates.set(UpdateDate, DateTime.now().toString(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;)) ), new UpdateOptions().upsert(true) ).getModifiedCount(); } public List&lt;Document&gt; aggregate(String collName, List&lt;Bson&gt; pipelines) { MongoCollection&lt;Document&gt; coll = this.getCollectionOfRead(collName); MongoCursor&lt;Document&gt; cursor = null; List&lt;Document&gt; documents = new ArrayList&lt;&gt;(); try { cursor = coll.aggregate(pipelines).iterator(); if (cursor != null &amp;&amp; cursor.hasNext()) { while (cursor.hasNext()) { documents.add(cursor.next()); } } return documents; } finally { if (cursor != null) cursor.close(); } }}","categories":[{"name":"代码示例","slug":"代码示例","permalink":"https://yyhan.github.io/categories/代码示例/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yyhan.github.io/tags/java/"},{"name":"mongodb","slug":"mongodb","permalink":"https://yyhan.github.io/tags/mongodb/"}]},{"title":"npm入门指南","slug":"npm入门指南","date":"2016-12-11T14:50:40.000Z","updated":"2017-06-18T13:21:22.457Z","comments":true,"path":"2016/12/11/npm入门指南/","link":"","permalink":"https://yyhan.github.io/2016/12/11/npm入门指南/","excerpt":"","text":"NPM&#x662F;&#x968F;&#x540C;NodeJS&#x4E00;&#x8D77;&#x5B89;&#x88C5;&#x7684;&#x5305;&#x7BA1;&#x7406;&#x5DE5;&#x5177;&#xFF0C;&#x80FD;&#x89E3;&#x51B3;NodeJS&#x4EE3;&#x7801;&#x90E8;&#x7F72;&#x4E0A;&#x7684;&#x5F88;&#x591A;&#x95EE;&#x9898;&#xFF0C;&#x5E38;&#x89C1;&#x7684;&#x4F7F;&#x7528;&#x573A;&#x666F;&#x6709;&#x4EE5;&#x4E0B;&#x51E0;&#x79CD;&#xFF1A; &#x5141;&#x8BB8;&#x7528;&#x6237;&#x4ECE;NPM&#x670D;&#x52A1;&#x5668;&#x4E0B;&#x8F7D;&#x522B;&#x4EBA;&#x7F16;&#x5199;&#x7684;&#x7B2C;&#x4E09;&#x65B9;&#x5305;&#x5230;&#x672C;&#x5730;&#x4F7F;&#x7528;&#x3002; &#x5141;&#x8BB8;&#x7528;&#x6237;&#x4ECE;NPM&#x670D;&#x52A1;&#x5668;&#x4E0B;&#x8F7D;&#x5E76;&#x5B89;&#x88C5;&#x522B;&#x4EBA;&#x7F16;&#x5199;&#x7684;&#x547D;&#x4EE4;&#x884C;&#x7A0B;&#x5E8F;&#x5230;&#x672C;&#x5730;&#x4F7F;&#x7528;&#x3002; &#x5141;&#x8BB8;&#x7528;&#x6237;&#x5C06;&#x81EA;&#x5DF1;&#x7F16;&#x5199;&#x7684;&#x5305;&#x6216;&#x547D;&#x4EE4;&#x884C;&#x7A0B;&#x5E8F;&#x4E0A;&#x4F20;&#x5230;NPM&#x670D;&#x52A1;&#x5668;&#x4F9B;&#x522B;&#x4EBA;&#x4F7F;&#x7528;&#x3002; &#x7531;&#x4E8E;&#x65B0;&#x7248;&#x7684;nodejs&#x5DF2;&#x7ECF;&#x96C6;&#x6210;&#x4E86;npm&#xFF0C;&#x6240;&#x4EE5;&#x4E4B;&#x524D;npm&#x4E5F;&#x4E00;&#x5E76;&#x5B89;&#x88C5;&#x597D;&#x4E86;&#x3002;&#x540C;&#x6837;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x8F93;&#x5165; &quot;npm -v&quot; &#x6765;&#x6D4B;&#x8BD5;&#x662F;&#x5426;&#x6210;&#x529F;&#x5B89;&#x88C5;&#x3002;&#x547D;&#x4EE4;&#x5982;&#x4E0B;&#xFF0C;&#x51FA;&#x73B0;&#x7248;&#x672C;&#x63D0;&#x793A;&#x8868;&#x793A;&#x5B89;&#x88C5;&#x6210;&#x529F;: 12$ npm -v3.10.8 npm &#x5B98;&#x7F51; npm &#x6587;&#x6863; &#x4F7F;&#x7528;package.json package.json&#x6587;&#x4EF6;&#x793A;&#x4F8B;&#xFF1A; 1234567891011121314151617181920212223{ &quot;name&quot;: &quot;demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;demo&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;dev&quot;: &quot;node build/dev-server.js&quot; }, &quot;repository&quot;: { &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://github.com/yyhan/demo.git&quot; }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;bugs&quot;: { &quot;url&quot;: &quot;https://github.com/yyhan/demo/issues&quot; }, &quot;homepage&quot;: &quot;https://github.com/yyhan/demo#readme&quot;, &quot;devDependencies&quot;: { &quot;express&quot;: &quot;^4.14.0&quot;, &quot;opn&quot;: &quot;^4.0.2&quot; }} &#x5E38;&#x7528;&#x547D;&#x4EE4; npm init &#x521D;&#x59CB;&#x5316;package.json&#x6587;&#x4EF6; npm install &lt;package_name&gt; &#x5B89;&#x88C5;&lt;package_name&gt;&#x4F9D;&#x8D56;&#x5230;&#x5F53;&#x524D;&#x76EE;&#x5F55;&#xFF0C;&#x5982;&#x679C;&#x5DF2;&#x7ECF;&#x5728;package.json&#x91CC;&#x914D;&#x7F6E;&#x597D;&#x4E86;&#x4E00;&#x5207;&#x4F9D;&#x8D56;&#xFF0C;&#x53EA;&#x9700;&#x8981;&#x8FD0;&#x884C;npm install&#xFF0C;npm&#x4F1A;&#x81EA;&#x52A8;&#x5B89;&#x88C5;package.json&#x91CC;&#x6307;&#x5B9A;&#x7684;&#x4F9D;&#x8D56; npm install &lt;package_name&gt; -g &#x5B89;&#x88C5;&lt;package_name&gt;&#x4F9D;&#x8D56;&#x5230;&#x5168;&#x5C40;&#x73AF;&#x5883;&#xFF0C;&#x4E00;&#x822C;&#x7528;&#x4E8E;&#x4E00;&#x4E9B;js&#x5DE5;&#x5177;&#x6216;&#x547D;&#x4EE4;&#x7C7B;&#x7684;&#x5B89;&#x88C5;&#x5305; npm install &lt;package_name&gt; --save &#x5B89;&#x88C5;&lt;package_name&gt;&#x4F9D;&#x8D56;&#x5230;&#x5F53;&#x524D;&#x76EE;&#x5F55;&#xFF0C;&#x5E76;&#x5C06;&#x8BE5;&#x4F9D;&#x8D56;&#x6DFB;&#x52A0;&#x5230;package.json &#x6587;&#x4EF6;&#x7684;&#x4F9D;&#x8D56;(dependencies)&#x9879;&#x4E2D; npm install &lt;package_name&gt; --save-dev &#x5B89;&#x88C5;&lt;package_name&gt;&#x4F9D;&#x8D56;&#x5230;&#x5F53;&#x524D;&#x76EE;&#x5F55;&#xFF0C;&#x5E76;&#x5C06;&#x8BE5;&#x4F9D;&#x8D56;&#x6DFB;&#x52A0;&#x5230;package.json &#x6587;&#x4EF6;&#x7684;&#x5F00;&#x53D1;&#x73AF;&#x5883;&#x4F9D;&#x8D56;(devDependencies)&#x9879;&#x4E2D; npm uninstall &lt;package_name&gt; &#x79FB;&#x9664;&lt;package_name&gt;&#x4F9D;&#x8D56; npm&#x955C;&#x50CF; &#x6DD8;&#x5B9D;npm&#x955C;&#x50CF;&#x5730;&#x5740;&#xFF1A;https://npm.taobao.org/ 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org &#x6216;&#x8005;&#x901A;&#x8FC7;&#x76F4;&#x63A5;&#x6DFB;&#x52A0;npm&#x53C2;&#x6570;alias&#x4E00;&#x4E2A;&#x65B0;&#x547D;&#x4EE4;&#xFF1A; 12345678910alias cnpm=&quot;npm --registry=https://registry.npm.taobao.org \\--cache=$HOME/.npm/.cache/cnpm \\--disturl=https://npm.taobao.org/dist \\--userconfig=$HOME/.cnpmrc&quot;# Or alias it in .bashrc or .zshrc$ echo &apos;\\n#alias for cnpm\\nalias cnpm=&quot;npm --registry=https://registry.npm.taobao.org \\ --cache=$HOME/.npm/.cache/cnpm \\ --disturl=https://npm.taobao.org/dist \\ --userconfig=$HOME/.cnpmrc&quot;&apos; &gt;&gt; ~/.zshrc &amp;&amp; source ~/.zshrc &#x7136;&#x540E;&#x5C31;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;cnpm&#x6765;&#x4EE3;&#x66FF;npm&#x9664;&#x4E86;publish&#x4E4B;&#x5916;&#x7684;&#x6240;&#x6709;&#x64CD;&#x4F5C;&#xFF1A; 1$ cnpm install [pk_name] &#x901A;&#x8FC7;cnpm&#x63D0;&#x4F9B;&#x7684;sync&#x547D;&#x4EE4;&#x540C;&#x6B65;&#x4E00;&#x4E2A;&#x6A21;&#x5757;&#xFF1A; 1$ cnpm sync [pk_name]","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://yyhan.github.io/categories/工具使用/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://yyhan.github.io/tags/npm/"},{"name":"入门指南","slug":"入门指南","permalink":"https://yyhan.github.io/tags/入门指南/"}]}]}